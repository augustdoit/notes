{"./":{"url":"./","title":"前言","keywords":"","body":"前言 年龄大了，即使系统学过的东西也全忘，打算开始构建个人知识库，先系统的梳理然后再分析总结。 碎片化信息通过 OneNote 及 Typora 收集整理吸纳后存放在 Hexo Blog 以便日常查询 梳理过后建立体系，形成文档，通过 Wiki 程序或在线协同的文档管理系统（个人和企业知识管理）来实现 简单调研分下类： 企业级-自行部署 MediaWiki 大名鼎鼎，维基百科 DokuWiki 小巧易用,不需数据库 开源wiki系统，支持多人协作，以及丰富的后台管理设置,官方没有docker,有团队写自行搜索。 confluence 专业的企业知识管理与协同软件 企业级-在线创作、协同、分享、托管 语雀 在线文档编辑与协同工具 示例:帮助文档 看云 技术文档在线创作、阅读、分享和托管 示例:序言 · ThinkPHP3.2.3完全开发手册 · 看云 开源轻量级 Gitbook 写作和出版的平台，开源可自行搭建。 gollum Github自己的wiki Docsifty 开源轻量级 开源轻量级 可以托管在Github page 演示 Docute 开源轻量级 开源轻量级 可以托管在Github page 演示以及文档 Wikitten开源在线文档，可以托管在Github page等平台 官网 MinDoc 开源接口文档在线管理系统 演示及说明 MkDocs 开源 Hexo Blog用的这个，使用Wikitten主题就可以了 海量文档的管理系统 BookStack 开源在线文档管理系统，相当完备，需要有一台服务器自建 演示 选择 如果希望协同、分享交流、托管、变现的 Gitbook 或者 看云 如果仅用于个人知识梳理，轻量级的 gitbook docsify,内容较多则 DokuWiki 真不想折腾的话就看云或云雀吧 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"pkb/pkb.html":{"url":"pkb/pkb.html","title":"构建个人知识库","keywords":"","body":"构建个人知识库（待修订） 知识库 什么是知识库 管理知识的仓库。 它跟搜索引擎不同，它存储着经过你的分析和总结的知识点，而搜索引擎搜到的是原始的信息。 它跟博客不一样，知识库以多种形式保存知识，而博客只是以文章形式保存。 另外，知识库还可以存放不便于对外公布的知识。 为什么要建立知识库 为了不遗忘重要的、有价值的事情，就要立刻记下来。日后可以反复查阅； 笔记能够记录有价值的思考过程和结论，避免重复推论，节省时间。 构建知识库是为了将大量知识经验从大脑转移到硬盘，释放大脑负担，同时可以通过工具来快速获取知识。 知识的层次 在学习方法论之前，先介绍关于知识的三个层面。知识的金字塔： 智慧 Wisdom -------------- 知识 Knowledge --------------------- 信息 Data/Information 我们生活中充斥着庞大的，冗余的，杂乱的，低价值的信息。 因此需要从信息海洋中过滤出有意义的信息，再将信息中有价值的部分提取出来，于是我们获得了「知识」。 一个个知识是独立没有联系的片段，我们需要对相关的知识建立多方面的关联，然后便形成了「知识体系」。 随着知识体系的设立与增长，对已有重叠的知识体系或者知识点进行重构，精炼。于是获得了「智慧」。 了解信息、知识、智慧的差别是构建知识库的基础，后续所有行为都是围绕着这三者。 三个目的 构建知识库的主要目的，我归纳为这三种： 一、管理知识 将信息加工成有用的知识，将知识归类，建立索引。不能被索引的知识，只是单纯的信息，一旦遗忘就很难找回。 二、建立体系 任何知识点在没有系统思考和组织下，都是分散的知识片段。 三、查询知识 为了再次查询知识，通过电子技术来快速索引到知识点。 构建个人知识库 准备 随身笔记，能够以最快速度记录下想法，比如印象笔记，OneNote。 整理归纳的电子工具;暂时使用Gitbook，docsify，后期可以考虑思维导图。 构建知识库的过程 收集 → 记录 → 总结 → 输出 → 查询 ↑ │ └───────────────────┘ 你需要构成一个正反馈环，这套执行系统才会持续运行下去，终身受益。 收集信息 收集信息是第一步 网站 书签、邮件订阅。 专业APP 收集与消费的博弈 信息越来越多。会发现这些信息难以处理（消费），你需要权衡接收与消费信息的比率。 当消费速度远小于收集速度，冗余信息太多导致无法有效过滤聚合知识； 当消费速度远大于收集速度，信息太少难以产生更多想法。 另外，如果消费和收集速度一直保持不变，这意味着你的知识增长是线性的，然而线性增长在这个时代是不够的，你需要指数级的增长。锻炼提高你的信息处理能力吧。 记录知识 阅读并思考，核对内容的真实性，判断内容的对错。然后提取出你觉得有用的知识点，记录下来。重要的知识不会只读一遍，当你日后需要使用它的时候，能在一分钟之内立刻就找到它。 将知识内化，不是肤浅的阅读和记录。你需要思考，思考问题的本质，思考为什么存在，思考如何解决，思考优点是什么，思考缺点是什么，思考什么是最优解…… 经过各种角度的分析，你会得到一些结论，把这些写下来。 个人目前碎片化信息通过 OneNote 及 Typora 收集整理吸纳后存放在 Hexo Blog 以便日常查询，梳理过后建立体系，形成文档，通过 Wiki 程序或在线协同的文档管理系统（个人和企业知识管理）来实现。 Todo List 必不可少，将那些来不及思考的信息，添加到这个列表里，以后处理。 总结智慧 当有了很多知识点，形成了一定规模的知识体系。你可以尝试分析现有的资料，产生新的观点，预测领域或行业发展。 查询知识库 根据 Tag 索引 根据分类浏览 根据关键词索引 参考 构建个人知识库 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:59:33 "},"gitbook/intro.html":{"url":"gitbook/intro.html","title":"简介","keywords":"","body":"简介 GitBook 已经放弃对 CLI 的开发维护，专注于 GitBook.com 平台。 GitBook Toolchain （工具链）是一个使用 Git 和 Markdown 来构建书籍的工具。它可以将你的书输出很多格式：pdf，equb，mobi，或者输出为静态网页。源码可以在 GitHub 上获取。 GitBook.com 是一个使用工具链来创建和托管书籍的在线平台。 如今，GitBook 和 GitBook.com 的文档已拆分,仍可以使用的官方文档： GitBook Documentation GitBook Toolchain Documentation 旧版中文文档 GitBook文档（中文版） 本文档于2020年9月整理。已无法使用的功能文中会标记。至于为什么还要整理不再维护的工具，详见 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/set.html":{"url":"gitbook/set.html","title":"安装","keywords":"","body":"安装 Gitbook 的 安装指引 环境要求 NodeJS (v4.0.0 and above is recommended) Windows, Linux, Unix, or Mac OS X Node.js 官方下载及安装教程 这里只记录下 Ubuntu Debain 系的安装过程。 安装 Node.js 法一 标准库安装（不推荐） sudo apt update sudo apt install nodejs npm # 查看版本 node -v v10.21.0 npm -v 5.8.0 看似安装顺利，实际 npm 版本低，安装 gitbook 时会报错 npm does not support Node.js v10.21.0 法二 从 NodeSource 储存库安装 # 长期支持版本12.x，不要使用最新版本14.x # 切换到root curl -sL https://deb.nodesource.com/setup_lts.x | bash - apt-get install -y nodejs # 查看版本 node -v v12.18.3 node -v 6.14.6 # 安裝 development tools apt-get install gcc g++ make 法三 Node Version Manager Node Version Manager 即 nvm 是一个bash脚本，用于管理多个已发布的 Node.js 版本。它允许您执行安装，卸载，切换版本等操作。 安装 Gitbook npm install gitbook-cli -g # 輸出如下表示成功 root@debian:~# npm install gitbook-cli -g /usr/bin/gitbook -> /usr/lib/node_modules/gitbook-cli/bin/gitbook.js + gitbook-cli@2.3.2 updated 3 packages in 16.865s 错误汇总 報錯如下： Installing GitBook 3.2.3 /usr/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /usr/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (fs.js:177:5) 解決方法： sudo vi /usr/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js # 一般模式下輸入 :set nu # 注釋掉62-64 // fs.stat = statFix(fs.stat) // fs.fstat = statFix(fs.fstat) // fs.lstat = statFix(fs.lstat) Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/instructions.html":{"url":"gitbook/instructions.html","title":"创建及使用","keywords":"","body":"创建及使用 Gitbook 的基本用法非常简单，基本上就只有两步： 使用 gitbook init 初始化书籍目录 使用 gitbook serve 编译預覽书籍 创建书籍 格式 自述和介绍 章节设置 多语言 忽略目录和文件 术语表 封面 模板 待添加 内容引用 gitbook指令集 创建书籍 mkdir book cd book gitbook init #輸出 warn: no summary file in this book info: create README.md info: create SUMMARY.md info: initialization is finished 使用tree命令查看目录树 tree #輸出 . ├── README.md └── SUMMARY.md README.md 及 SUMMARY.md 是两个必要文件 格式 GitBook 约定了下面这些文件的作用： README：书本的介绍 SUMMARY：章节结构 LANGS：多语言书籍 GLOSSARY：术语描述的清单 至少需要一个 README 和 SUMMARY 文件来构建一本书。 自述和介绍 书本的第一页内容是从文件 README.md 中提取的。如果这个文件名没有出现在 SUMMARY 中，那么它会被添加为章节的第一个条目。 使用其他文件替代README.md 一些托管在 GitBook 上的书更加喜欢将 README.md 文件作为项目的介绍而不是书的介绍。 可以在 book.json 中定义某个文件作为 README 。 章节设置 通过 SUMMARY.md 定义目录结构，通过 gitbook init 自动生成目录结构对应的文件夹和 Markdown 文件。也可以先创建好章节目录及文件，再回来编辑目录。 目录示例 #Summary * [第一章](chapter1.md) * [第二章](chapter2.md) * [第三章](chapter3.md) 多层结构目录示例 #Summary * [第一章](section1/README.md) * [第一节](section1/example1.md) * [第二节](section1/example2.md) * [第二章](section2/README.md) * [第一节](section2/example1.md) 使用标题或水平分割线将目录分成几个部分 # Summary ### Part I * [Introduction](README.md) * [Writing is nice](part1/writing.md) * [GitBook is nice](part1/gitbook.md) ### Part II * [We love feedback](part2/feedback_please.md) * [Better tools for authors](part2/better_tools.md) ---- * [Last part without title](part3/title.md) 多语言 GitBook 支持多种语言编写图书。每种语言必须是一个子目录，子目录结构与 GitBook 结构相同（拥有各自的 README.md 、 SUMMARY.md 以及实际内容文件）， LANGS.md 在外层父目录（书籍项目根目录），其内容格式如下： LANGS.md * [English](en/) * [zh-hans](zh-hans/) * [zh-tw](zh-tw/) 示例：Learn Git 忽略目录和文件 GitBook 会读取 .gitignore,.bookignore 以及 .ignore 这三个档案，根据里面的内容，忽略特定的文件或子目录。（格式为一行一个文件或目录。） .gitignore # 忽略 test.md 文件 test.md # 忽略 \"bin\" 目录下所有文件 bin/* 术语表 在术语表中指定要显示的术语和其各自的定义。基于这些条件 gitbook 会自动建立索引，并在内容页面中高亮显示这些术语。注意不支持中文术语 GLOSSARY.md # git 是一个分布式版本控制软件，最初由林纳斯·托瓦兹创作，于2005年以GPL发布。最初目的是为更好地管理Linux内核开发而设计。应注意的是，这与GNU Interactive Tools 一个类似Norton Commander界面的文件管理器）不同。 # GitHub GitHub是通过Git进行版本控制的软件源代码托管服务平台，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。 封面 cover.jpg 和 cover_small.jpg缩略图 最佳尺寸 大 缩略图 文件 cover.jpg cover_small.jpg 大小 1800x2360 200x262 插件 autocover 同样可以实现，参照 https://github.com/GitbookIO/plugin-autocover 模板 待添加 注意与配置中 variables 有关 内容引用 内容参考 (conref) 是便于用来重复使用其他文件和书本内容。 导入本地文件 使用 include 标签导入其他文件的内容真的很简单： {% include \"./test.md\" %} 从其他书本导入文件 GitBook 同样能处理使用了git协议的include路径： {% include \"git+https://github.com/GitbookIO/documentation.git/README.md#0.0.1\" %} git的url格式是： git+https://[email protected]/project/blah.git/file#commit-ish 真实的git url应该以 .git 结尾，导入的文件名从 .git 之后的 url 片段提取。 commit-ish 可以是任何可以作为 git checkout 参数的标签，sha，或分支。默认是 master。 继承 模板继承是一种重复使用模板的简单方式。当写完一个模板，你可以定义 \"block\" 让字模板来替换。继承链可以任意长。 block 在模板中定义了一个区域并用一个名字标识了它。基类模板可以指定一些块，而子类可以用新的内容替换它们。 {% extends \"./mypage.md\" %} {% block pageContent %} # This is my page content {% endblock %} 在文件 mypage.md 中，你应该指定用来替换内容的块。 {% block pageContent %} This is the default content {% endblock %} # License {% import \"./LICENSE\" %} gitbook指令集 gitbook help 指令查看所有指令集，如下 build [book] [output] build a book --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) --format Format to build to (Default is website; Values are website, json, ebook) --[no-]timing Print timing debug information (Default is false) serve [book] [output] serve the book as a website for testing --port Port for server to listen on (Default is 4000) --lrport Port for livereload server to listen on (Default is 35729) --[no-]watch Enable file watcher and live reloading (Default is true) --[no-]live Enable live reloading (Default is true) --[no-]open Enable opening book in browser (Default is false) --browser Specify browser for opening book (Default is ) --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) --format Format to build to (Default is website; Values are website, json, ebook) install [book] install all plugins dependencies --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) parse [book] parse and print debug information about a book --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) init [book] setup and create files for chapters --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) pdf [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) epub [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) mobi [book] [output] build a book into an ebook file --log Minimum log level to display (Default is info; Values are debug, info, warn, error, disabled) Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/book_json.html":{"url":"gitbook/book_json.html","title":"配置","keywords":"","body":"配置 所有的配置都以 JSON 格式存储在名为 book.json 的文件中。 你可以粘贴你的 book.json 去 jsonlint.com 验证 JSON 语法。 该配置与 SUMMARY.md 同级： . ├── book.json ├── README.md └── SUMMARY.md 示例 title author description isbn theme-default language gitbook root links direction styles plugins pluginsConfig structure 示例 { \"title\": \"GitBook 使用教程\", \"description\": \"记录 GitBook 的配置和一些插件的使用\", \"author\": \"xxxx\", \"output.name\": \"site\", \"language\": \"zh-hans\", \"gitbook\": \"3.2.2\", \"root\": \".\", \"structure\": { \"readme\": \"introduction.md\" }, \"links\": { \"sidebar\": { \"Home\": \"http://www.xxxx.com\" } }, \"plugins\": [ \"-lunr\", \"-search\", \"-highlight\", \"-livereload\", \"search-plus@^0.0.11\", \"simple-page-toc@^0.1.1\", \"github@^2.0.0\", \"github-buttons@2.1.0\", \"edit-link@^2.0.2\", \"disqus@^0.1.0\", \"prism@^2.1.0\", \"prism-themes@^0.0.2\", \"advanced-emoji@^0.2.1\", \"anchors@^0.7.1\", \"include-codeblock@^3.0.2\", \"ace@^0.3.2\", \"emphasize@^1.1.0\", \"katex@^1.1.3\", \"splitter@^0.0.8\", \"tbfed-pagefooter@^0.0.1\", \"expandable-chapters-small@^0.1.7\", \"sectionx@^3.1.0\", \"donate@^1.0.2\", \"local-video@^1.0.1\", \"sitemap-general@^0.1.1\", \"anchor-navigation-ex@0.1.8\", \"favicon@^0.0.2\", \"todo@^0.1.3\", \"3-ba@^0.9.0\" ], \"pluginsConfig\": { \"theme-default\": { \"showLevel\": true }, \"disqus\": { \"shortName\": \"gitbookuse\" }, \"prism\": { \"css\": [ \"prism-themes/themes/prism-base16-ateliersulphurpool.light.css\" ] }, \"github\": { \"url\": \"https://xxxxxx\" }, \"github-buttons\": { \"repo\": \"xxxxx/gitbook-use\", \"types\": [ \"star\" ], \"size\": \"small\" }, \"include-codeblock\": { \"template\": \"ace\", \"unindent\": true, \"edit\": true }, \"sharing\": { \"weibo\": true, \"facebook\": true, \"twitter\": true, \"google\": false, \"instapaper\": false, \"vk\": false, \"all\": [ \"facebook\", \"google\", \"twitter\", \"weibo\", \"instapaper\" ] }, \"tbfed-pagefooter\": { \"copyright\": \"Copyright © xxxx.com 2017\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" }, \"3-ba\": { \"token\": \"fxxxxxxxx\" }, \"donate\": { \"wechat\": \"https://xxxxx/weixin.png\", \"alipay\": \"https://xxxxx/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" }, \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true }, \"edit-link\": { \"base\": \"https://xxxxxx\", \"label\": \"Edit This Page\" }, \"sitemap-general\": { \"prefix\": \"http://xxxxx.com\" }, \"anchor-navigation-ex\": { \"isRewritePageTitle\": false, \"tocLevel1Icon\": \"fa fa-hand-o-right\", \"tocLevel2Icon\": \"fa fa-hand-o-right\", \"tocLevel3Icon\": \"fa fa-hand-o-right\" }, \"sectionx\": { \"tag\": \"b\" }, \"favicon\": { \"shortcut\": \"favicon.ico\", \"bookmark\": \"favicon.ico\" } } } title 设置书本的标题 {\"title\" : \"Gitbook Use\"} author 作者的相关信息 {\"author\" : \"heyhey\"} description 本书的简单描述，默认是从 README（第一段）中提取的。在 gitbook.com 中，这个值是根据平台输入的描述定义的。 {\"description\" : \"记录Gitbook的配置和一些插件的使用\"} isbn 这个选项定义了你书本的ISBN。 { \"isbn\": \"9xx-3-xx6-1xx41x-0\" } theme-default 为目录添加序号 \"theme-default\": { \"showLevel\": true } language Gitbook 使用的语言, 可选的语言如下： en, ar, bn, cs, de, en, es, fa, fi, fr, he, it, ja, ko, no, pl, pt, ro, ru, sv, uk, vi, zh-hans, zh-tw 配置使用简体中文 {\"language\" : \"zh-hans\"} gitbook 指定使用的gitbook版本 {\"gitbook\" : \"3.2.2\"} root 指定存放 GitBook 文件（除了 book.json）的根目录 {\"root\": \".\"} links 在左侧导航栏（Home）添加链接信息 \"links\" : { \"sidebar\" : { \"Home\" : \"https://www.gitbook.com\" } } direction { \"direction\": \"rtl\" } 这个选项是用来重新设置语言的文字方向的。建议将 language 字段设置为带有正确的文字方向的语言 styles 自定义页面样式， 默认情况下各 generator 对应的 css 文件 { \"styles\": { \"website\": \"styles/website.css\", \"ebook\": \"styles/ebook.css\", \"pdf\": \"styles/pdf.css\", \"mobi\": \"styles/mobi.css\", \"equb\": \"styles/epub.css\" } } 例如使 标签有下边框， 可以在 website.css 中设置 h1 , h2{ border-bottom: 1px solid #EFEAEA; } plugins 配置使用的插件 { \"plugins\": [\"mathjax\"] } 书本使用的插件列表被定义在 book.json 的配置中。 添加新插件之后需要运行 gitbook install 来安装新的插件 pluginsConfig 配置插件的属性 { \"plugins\": [\"myplugin\"], \"pluginsConfig\": { \"myPlugin\": { \"message\": \"Hello World\" } } } structure 指定 Readme、Summary、Glossary 和 Languages 对应的文件名，下面是这几个文件对应变量以及默认值： 变量 含义和默认值 structure.readme Readme file name (defaults to README.md) structure.summary Summary file name (defaults to SUMMARY.md) structure.glossary Glossary file name (defaults to GLOSSARY.md) structure.languages Languages file name (defaults to LANGS.md) 例如你想要使用 INTRO.md 代替 README.md ： { \"structure\": { \"readme\": \"INTRO.md\" } } Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/plugs.html":{"url":"gitbook/plugs.html","title":"插件","keywords":"","body":"插件 插件是扩展 GitBook 功能（电子书和网站）最好的方式。 指定插件版本格式为 donate@^1.0.2,本章介绍的插件在 GitBook 的 3.2.3 版本中都可以正常工作，当然这里只是列举了一部分插件，如有其他需求，请自行搜索。 GitBook 支持的插件可以从 https://github.com/GitbookIO 取找 将其添加至 book.json 中： \"plugins\": [\"myPlugin\", \"anotherPlugin\"] 添加之后运行 gitbook install 来安装。 默认带7个插件 livereload,highlight,search,lunr,sharing,fontsettings,theme-default 如果要去除自带的插件， 可以在插件名称前面加- \"plugins\": [ \"-search\" ] 插件 Disqus Search Plus Prism advanced-emoji Github Github Buttons Emphasize Splitter Mermaid-gb3 Puml theme-comscore summary Graph Chart Sharing-plus Expandable-chapters-small Simple-page-toc Anchors Anchor-navigation-ex Edit Link Sitemap-general Favicon Todo Terminal mathjax 和 katex MathJax 和 KaTeX 的区别 添加数学公式 Tbfed-pagefooter Alerts Sectionx Include-csv Musicxml Klipse RSS GA 3-ba Donate local-video Disqus 添加 disqus 评论 \"plugins\": [ \"disqus\" ], \"pluginsConfig\": { \"disqus\": { \"shortName\": \"gitbookuse\" } } Search Plus 支持中文搜索, 需要将默认的 search 和 lunr 插件去掉。 { \"plugins\": [\"-lunr\", \"-search\", \"search-plus\"] } Prism 使用 Prism.js 为语法添加高亮显示，需要将 highlight 插件去掉。该插件自带的主题样式较少，可以再安装 prism-themes 插件，里面多提供了几种样式，具体的样式可以参考 这里，在设置样式时要注意设置 css 文件名，而不是样式名。 { \"plugins\": [ \"prism\", \"-highlight\" ], \"pluginsConfig\": { \"prism\": { \"css\": [ \"prism-themes/themes/prism-base16-ateliersulphurpool.light.css\" ] } } } 如果需要修改背景色、字体大小等，可以在 website.css 定义 pre[class*=\"language-\"] 类来修改，下面是一个示例： pre[class*=\"language-\"] { border: none; background-color: #f7f7f7; font-size: 1em; line-height: 1.2em; } advanced-emoji 支持 emoji 表情 emoij表情列表 { \"plugins\": [ \"advanced-emoji\" ] } 示例 Github 添加 Github 图标 位置在右上角 { \"plugins\": [ \"github\" ], \"pluginsConfig\": { \"github\": { \"url\": \"https://github.com/augustdoit\" } } } Github Buttons 添加项目在 github 上的 star，watch，fork情况 { \"plugins\": [ \"github-buttons\" ], \"pluginsConfig\": { \"github-buttons\": { \"repo\": \"augutdoit/book\", \"types\": [ \"star\", \"watch\", \"fork\" ], \"size\": \"small\" } } } Emphasize 为文字加上底色 \"plugins\": [ \"emphasize\" ] 使用方法 This text is {% em %}highlighted !{% endem %} This text is {% em %}highlighted with **markdown**!{% endem %} This text is {% em type=\"green\" %}highlighted in green!{% endem %} This text is {% em type=\"red\" %}highlighted in red!{% endem %} This text is {% em color=\"#ff0000\" %}highlighted with a custom color!{% endem %} 效果 This text is highlighted ! This text is highlighted with markdown! This text is highlighted in green! This text is highlighted in red! This text is highlighted with a custom color! Splitter 使侧边栏的宽度可以自由调节 \"plugins\": [ \"splitter\" ] Mermaid-gb3 支持渲染Mermaid图表 \"plugins\": [ \"mermaid-gb3\" ] 使用方法： {% mermaid %} .... {% endmermaid %} 或 ```mermaid ​ graph TD; ​ A-->B; ​ A-->C; ​ B-->D; ​ C-->D; ``` 效果 graph TD; A-->B; A-->C; B-->D; C-->D; 或示例: {% mermaid %} sequenceDiagram Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! {% endmermaid %} 效果： sequenceDiagram Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! Puml 使用 PlantUML 展示 uml 图。 { \"plugins\": [\"puml\"] } 使用示例： {% plantuml %} Class Stage Class Timeout { +constructor:function(cfg) +timeout:function(ctx) +overdue:function(ctx) +stage: Stage } Stage 效果 theme-comscore 主题插件, 修改标题和表格颜色。默认标题都是黑色的。 { \"plugins\": [ \"theme-comscore\" ] } summary 根据文件自动生成目录。 { \"plugins\": [ \"summary\" ] } 规则： 每个新增的目录中加入README.md，否则菜单为不可折叠 同个目录下的文件采用自然排序来决定菜单生成的前后顺序， 故在文件或目录前加入 \"数字-\" 如 \"0-\" 或 \"1-\" 来排序菜单的前后顺序。 菜单由目录自动生成，菜单名称依赖md文件中的标题， 故每个md文件中必须添加标题, 否则无法生成目录。 示例： 我们假设您的源代码树是这样完成的： tree . . ├── ORDER │ ├── 0-README.md │ └── 1-orderInfo.md ├── README.md ├── SUMMARY.md └── USER ├── 0-README.md └── 1-userInfo.md 生成的SUMMARY.md文件将如下所示： - ORDER * [0 README](ORDER/0-README.md) * [1 Order Info](ORDER/1-orderInfo.md) - USER * [0 README](USER/0-README.md) * [1 User Info](USER/1-userInfo.md) Graph 使用 function-plot 绘制数学函数图。 { \"plugins\": [ \"graph\" ], } 下面是一个示例，需要注意的是{% graph %} 块中的内容必须是合法的 JSON 格式。 {% graph %} { \"title\": \"1/x * cos(1/x)\", \"grid\": true, \"xAxis\": { \"domain\": [0.01, 1] }, \"yAxis\": { \"domain\": [-100, 100] }, \"data\": [{ \"fn\": \"1/x * cos(1/x)\", \"closed\": true }] } {% endgraph %} 效果如下： functionPlot({\"title\":\"1/x * cos(1/x)\",\"grid\":true,\"xAxis\":{\"domain\":[0.01,1]},\"yAxis\":{\"domain\":[-100,100]},\"data\":[{\"fn\":\"1/x * cos(1/x)\",\"closed\":true}],\"target\":\"#plugin-graph-0\"}); Chart 使用 C3.js 或者 Highcharts 绘制图形。 { \"plugins\": [ \"chart\" ], \"pluginsConfig\": { \"chart\": { \"type\": \"c3\" } } } type 可以是 c3 或者 highcharts, 默认是 c3. 示例： {% chart %} { \"data\": { \"type\": \"bar\", \"columns\": [ [\"data1\", 30, 200, 100, 400, 150, 250], [\"data2\", 50, 20, 10, 40, 15, 25] ], \"axes\": { \"data2\": \"y2\" } }, \"axis\": { \"y2\": { \"show\": true } } } {% endchart %} 效果 c3.generate({\"bindto\":\"#plugin-chart-1\", \"data\": { \"type\": \"bar\", \"columns\": [ [\"data1\", 30, 200, 100, 400, 150, 250], [\"data2\", 50, 20, 10, 40, 15, 25] ], \"axes\": { \"data2\": \"y2\" } }, \"axis\": { \"y2\": { \"show\": true } } }); Sharing-plus 分享当前页面，比默认的 sharing 插件多了一些分享方式。 plugins: [\"-sharing\", \"sharing-plus\"] 可用的包括 douban、facebook、google、hatenaBookmark、instapaper、line、linkedin、messenger、pocket、qq、qzone、stumbleupon、twitter、viber、vk、weibo、whatsapp 个人用的配置: \"pluginsConfig\": { \"sharing\": { \"twitter\": false, \"facebook\": true, \"weibo\": true, \"all\": [] } Expandable-chapters-small 使左侧的章节目录可以折叠 plugins: [\"expandable-chapters-small\"] Simple-page-toc 自动生成本页的目录结构。另外 GitBook 在处理重复的标题时有些问题，所以尽量不适用重复的标题。 { \"plugins\" : [ \"simple-page-toc\" ], \"pluginsConfig\": { \"simple-page-toc\": { \"maxDepth\": 3, \"skipFirstH1\": true } } } 使用方法: 在需要生成目录的地方加上 Anchors 添加 Github 风格的锚点样式。若装了Anchor-navigation-ex 就不用再单装了 \"plugins\" : [ \"anchors\" ] Anchor-navigation-ex 插件地址 在页面中增加标签，会在此处生成TOC目录 在页面中增加标签，不会在该页面生成悬浮导航 添加Toc到侧边悬浮导航以及回到顶部按钮。需要注意以下两点： 本插件只会提取 h[1-3] 标签作为悬浮导航 只有按照以下顺序嵌套才会被提取 # h1 ## h2 ### h3 必须要以 h1 开始，直接写 h2 不会被提取 ## h2 必须要以 h1 开始，直接写 h2 不会被提取 { \"plugins\": [ \"anchor-navigation-ex\" ], \"pluginsConfig\": { \"anchor-navigation-ex\": { \"isRewritePageTitle\": true, \"isShowTocTitleIcon\": true, \"tocLevel1Icon\": \"fa fa-hand-o-right\", \"tocLevel2Icon\": \"fa fa-hand-o-right\", \"tocLevel3Icon\": \"fa fa-hand-o-right\" } } } Edit Link 如果将 GitBook 的源文件保存到 github 或者其他的仓库上，使用该插件可以链接到当前页的源文件上。 插件地址 \"plugins\": [\"edit-link\"], \"pluginsConfig\": { \"edit-link\": { \"base\": \"https://github.com/USER/REPO/edit/BRANCH\", \"label\": \"Edit This Page\" } } Sitemap-general 生成sitemap { \"plugins\": [\"sitemap-general\"], \"pluginsConfig\": { \"sitemap-general\": { \"prefix\": \"你的网址\" } } } Favicon 更改网站的 favicon.ico { \"plugins\": [ \"favicon\" ], \"pluginsConfig\": { \"favicon\": { \"shortcut\": \"assets/images/favicon.ico\", \"bookmark\": \"assets/images/favicon.ico\", \"appleTouch\": \"assets/images/apple-touch-icon.png\", \"appleTouchMore\": { \"120x120\": \"assets/images/apple-touch-icon-120x120.png\", \"180x180\": \"assets/images/apple-touch-icon-180x180.png\" } } } } Todo 添加 Todo 功能。默认的 checkbox 会向右偏移 2em，如果不希望偏移，可以在 website.css 里加上下面的代码: input[type=checkbox]{ margin-left: -2em; } \"plugins\": [\"todo\"] 使用示例： - [ ] write some articles - [x] drink a cup of tea 效果： [ ] write some articles [x] drink a cup of tea Terminal 模拟终端显示，主要用于显示命令以及多行输出，不过写起来有些麻烦。 { \"plugins\": [ \"terminal\" ], \"pluginsConfig\": { \"terminal\": { \"copyButtons\": true, \"fade\": false, \"style\": \"flat\" } } } 现在支持 6 种标签： command: Command \"executed\" in the terminal. delimiter: Sequence of characters between the prompt and the command. error: Error message. path: Directory path shown in the prompt. prompt: Prompt of the user. warning: Warning message 标签的使用格式如下所示： **[ 内容] 为了使标签正常工作，需要在代码块的第一行加入 **[termial]标记，下面是一个完整的示例： ``` **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command ./myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] ``` 效果 **[terminal] **[prompt foo@joe]**[path ~]**[delimiter $ ]**[command ./myscript] Normal output line. Nothing special here... But... You can add some colors. What about a warning message? **[warning [WARNING] The color depends on the theme. Could look normal too] What about an error message? **[error [ERROR] This is not the error you are looking for] terminal 支持下面 5 种样式，如果需要更换样式，在 pluginsConfig 里配置即可。 black: Just that good old black terminal everybody loves. classic: Looking for green color font over a black background? This is for you. flat: Oh, flat colors. I love flat colors. Everything looks modern with them. ubuntu: Admit it or not, but Ubuntu have a good looking terminal. white: Make your terminal to blend in with your GitBook. Copy-code-button 为代码块添加复制的按钮。 { \"plugins\": [\"copy-code-button\"] } mathjax 和 katex GitBook 可以使用插件支持数学公式和 Tex。当前有两个官方的插件用来显示数学公式：mathjax 和 katex。 { \"plugins\": [\"mathjax\"] } MathJax 和 KaTeX 的区别 mathjax 和 katex 插件是 Tex 公式绘制的不同实现，它们基于各自的开源库：KaTeX 和 MathJax 。 MathJax 支持整个 Tex 语法，但是在制作电子书版本时不是很完美。 KaTex 在所有格式（网页和电子书）的绘制上都很完美，但是还不支持 所有的语法。 添加数学公式 用 {% math %} 添加 Tex 公式 When {% math %}a \\ne 0{% endmath %}, there are two solutions to {% math %}(ax^2 + bx + c = 0){% endmath %} and they are {% math %}x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}.{% endmath %} 效果： When a \\ne 0, there are two solutions to (ax^2 + bx + c = 0) and they are x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. 报错解决 PluginError: Error with plugin \"mathjax\": Cannot find module 'mathjax/unpacked/MathJax' 一般出现在新安装或更新mathjax后，解决办法为,为mathjax降级，安装 2.7.6版本 sudo npm install mathjax@2.7.6 gitbook install Tbfed-pagefooter 为页面添加页脚 { \"plugins\": [ \"tbfed-pagefooter\" ], \"pluginsConfig\": { \"tbfed-pagefooter\": { \"copyright\":\"Copyright &copy augustdoit 2020\", \"modify_label\": \"该文件修订时间：\", \"modify_format\": \"YYYY-MM-DD HH:mm:ss\" } } } Alerts 添加不同 alerts 样式的 blockquotes，目前包含 info, warning, danger 和 success 四种样式。 { \"plugins\": [\"alerts\"] } 下面是使用示例： Info styling > **[info] For info** > > Use this for infomation messages. Warning styling > **[warning] For warning** > > Use this for warning messages. Danger styling > **[danger] For danger** > > Use this for danger messages. Success styling > **[success] For info** > > Use this for success messages. 效果如下所示： Info styling [info] For info Use this for infomation messages. Warning styling [warning] For warning Use this for warning messages. Danger styling [danger] For danger Use this for danger messages. Success styling [success] For info Use this for success messages. Sectionx 将页面分块显示，标签的 tag 最好是使用 b 标签，如果使用 h1-h6 可能会和其他插件冲突。 { \"plugins\": [ \"sectionx\" ], \"pluginsConfig\": { \"sectionx\": { \"tag\": \"b\" } } } 使用示例 插入内容... 插入内容... Include-csv 展示 csv 文件。 { \"plugins\": [\"include-csv\"] } 使用示例： {% includeCsv src=\"/csv/test.csv\", useHeader=\"true\" %} {% endincludeCsv %} 效果 csv/test.csv 产业数值比重第一产业11110.00%第二产业22220.00%第三产业33330.00%第四产业44440.00% Musicxml 支持 musicxml 格式的乐谱渲染 { \"plugins\": [\"musicxml\"] } 示例，需要注意的是 block 中的内容必须是一个合法的 musicxml 文件路径，并且不能有换行和空格。 {% musicxml %}musicxml/mandoline - debussy.xml{% endmusicxml %} 效果 Klipse 集成 Klipse (online code evaluator) { \"plugins\": [\"klipse\"] } klipse 目前支持下面的语言： javascript: evaluation is done with the javascript function eval and pretty printing of the result is done with pretty-format clojure[script]: evaluation is done with Self-Hosted Clojurescript ruby: evaluation is done with Opal C++: evaluation is done with JSCPP python: evaluation is done with Skulpt scheme: evaluation is done with BiwasScheme PHP: evaluation is done with Uniter BrainFuck JSX EcmaScript2017 Google Charts: See Interactive Business Report with Google Charts. 示例： ```eval-python print [x + 1 for x in range(10)] ``` 效果 print [x + 1 for x in range(10)] RSS 添加 rss 订阅功能。 { \"plugins\": [ \"rss\" ], \"pluginsConfig\": { \"rss\": { \"title\": \"网站名\", \"description\": \"描述\", \"author\": \"作者\", \"feed_url\": \"http://xxx.com/rss\", \"site_url\": \"http://xxx.com/\", \"managingEditor\": \"xx@xxxx.com\", \"webMaster\": \"xx@xxxx.com\", \"categories\": [ \"gitbook\" ] } } } GA Google 统计 \"plugins\": [ \"ga\" ], \"pluginsConfig\": { \"ga\": { \"token\": \"UA-XXXX-Y\" } } 3-ba 百度统计 { \"plugins\": [\"3-ba\"], \"pluginsConfig\": { \"3-ba\": { \"token\": \"xxxxxxxx\" } } } Donate 打赏插件 \"plugins\": [ \"donate\" ], \"pluginsConfig\": { \"donate\": { \"wechat\": \"https://xxx.com/resource/weixin.png\", \"alipay\": \"https://xxx.com/resource/alipay.png\", \"title\": \"\", \"button\": \"赏\", \"alipayText\": \"支付宝打赏\", \"wechatText\": \"微信打赏\" } } local-video 使用 Video.js 播放视频 \"plugins\": [ \"local-video\" ] 使用示例：为了使视频可以自适应，我们指定视频的 width 为100%，并设置宽高比为16:9，如下面所示: {% raw %} To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video {% endraw %} To view this video please enable JavaScript, and consider upgrading to a web browser that supports HTML5 video 另外我们还要再配置下css，即在website.css中加入 .video-js { width:100%; height: 100%; } Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/preview.html":{"url":"gitbook/preview.html","title":"预览书籍","keywords":"","body":"预览书籍 编译预览 # 目录内 gitbook serve # 目录外 gitbook serve 书名/或完整目录 gitbook serve 命令实际上会首先调用 gitbook build编译书籍，在书籍目录下生成_book目录，存放html文件。生成后会打开一个 web 服务器，监听本地 4000 端口，在浏览器中输入http://localhost:4000，即可打开电子书。 若只生成静态页面，托管发布在别的地方，执行如下命令即可 gitbook build 改变默认服务端口 如果我们要同时启动多个 gitbook 服务的话就需要改变 gitbook 默认web端口，同时也要改变 gitbook 默认进程端口 默认web端口: 4000 默认进程端口: 35729 在当前书籍目录下执行 gitbook server 等同于 gitbook serve 书名/完整目录 --lrport 5729--port 4000 启动第二个gitbook # 在第二书记目录下执行 gitbook --port 4001 --lrport 35288 serve 等同于 gitbook serve --lrport 35288 --port 4001 书名/完整目录 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/deploy.html":{"url":"gitbook/deploy.html","title":"托管","keywords":"","body":"托管 编译完成后生成的静态页面，可托管的地方很多，这里只说与 Github 相关的。 前期准备 Git 会单开一章总结。 配置SSH key 官方文档 本地生成 cd ssh-keygen -t rsa -b 4096 -C \"augustdoit@gmail.com\" # 输出 Generating public/private rsa key pair. Enter a file in which to save the key (用户目录/.ssh/id_rsa): //默认目录，回车就好 Enter passphrase (empty for no passphrase): //设置密码，直接回车意味着不设密码 Enter same passphrase again: //再次输入密码 添加到 Github 复制公钥内容 cat ~/.ssh/id_rsa.pub 将输出内容复制 登录到Github网站，右上角Seetings-SSH and GPG keys-New SSH key Tittle //随便起个名字 Key //粘贴复制的内容 Add SSH key 测试 ssh -T git@github.com 设置用户信息 git config --global user.name \"augustdoit\" //用户名 git config --global user.email \"augustdoit@gmail.com\" //邮箱 托管到 Gitbook.com 待编辑 托管到 Github 本节及下节托管到 Github Pages 的需求情景实际上是git的应用，即将书籍的源码存放到仓库的 master 分支，而将书籍的 html 版本存放到仓库的 pages 分支。 这节指的是书籍源码，不含gitbook build生成内容。 创建仓库 在 GitBook 项目目录，如 book 中，执行如下命令，创建本地 git 仓库 git init 添加忽略文件 vi .gitignore # 添加如下内容 *~ _book .DS_Store 通过.gitignore文件，本地仓库将忽略临时文件和_book文件夹，达到只保存书籍源码的目的。 添加文件 将本地源码添加到本地仓库 git add . 添加更新说明 git commit -m '更新说明文字' 建立本地仓库与远端仓库的对应关系 git remote add origin https://远程仓库地址.git 推送 将本地仓库内容同步到远端仓库： git push -u origin master 至此，就完成了将gitbook源码推送到远程仓库的任务，之后书籍内容修改后，执行如下操作即可： git add . git commit -m '更新说明文字' git push -u origin master 托管到 Github Pages pages 是 github 类网站提供的免费的静态网页托管服务，既然 GitBook 能生成基于 HTTML 的静态电子书籍，那自然而然，我们就会有将 GitBook 静态页面发布到 pages 服务的需求。 新建分支 git checkout --orphan pages 删除不需要的文件 切换到 pages 分支后，我们需要将 _books 目录之外的文件都清理掉： git rm --cached -r . git clean -df rm -rf *~ 添加忽略文件 *~ _book .DS_Store 通过.gitignore文件，本地仓库将忽略临时文件和 _book 文件夹. 复制_book文件夹到分支根目录 cp -r _book/* . 添加文件 git add . 添加更新说明 git commit -m '更新说明' 推送 git push -u origin pages 开启pages服务 登陆github网站，仓库设置开启 pages 服务，也可以添加域名. 开启 Pages 添加域名 自动化脚本 命令行的精髓在于可以自动执行，如下面的脚本，可以完成同时更新 master 分支和 pages 分支的目的。 git checkout master git add . git commit -m $1 git push -u origin master git checkout pages cp -r _book/* . git add . git commit -m $1 git push -u origin pages git checkout master 在需要更新的时候，执行如下命令： sh gitbook.sh '更新说明' 个人方案-只托管网页 本人没有将源码托管在 Github 上，只将静态网页托管,仓库名 notes ,分支 master 。 github上创建仓库 本地推送 本地生成CNAME文件，防止远程每次推送被删除，注意在_book同级目录 vi CNAME # 填写你的域名 notes.augustdoit.men 本地推送 cd _book git init vi .gitignore # 添加如下 *~ .DS_Store # 保存后退出 git add . git commit -m \"first commit\" git branch -M master git remote add origin git@github.com:augustdoit/notes.git git push -u origin master 回到 github 网页 开启pages服务 上面讲过了 自动化脚本 cd _book git checkout master git add . git commit -am $1 git push git@github.com:augustdoit/notes.git master --force Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/markdown.html":{"url":"gitbook/markdown.html","title":"markdown","keywords":"","body":"markdown 简介 基础 Typora 待完善 Typora 是一款功能全面、简洁高效，而且又非常优雅的 Markdown 编辑器。它把源码编辑和效果预览合二为一，在输入标记之后随即生成预览效果，提供了“所见即所得 ”的 Markdown 写作体验。 简介 Typora是目前最受欢迎的Markdown编辑器之一。它的主要特性如下。 实时预览：传统的Markdown编辑器都有两个窗口，左边是源码，右边是渲染后的效果。Typora独辟蹊径，把源码编辑和效果预览合二为一，实现了真正的所见即所得。 扩展语法：Typora不光支持GFM，还扩展了数学公式、流程图等功能。 快捷操作：Typora对几乎所有的Markdown标记都提供了快捷操作方式，使用起来非常高效。 界面漂亮：默认支持6种主题，可自定义，好看又好用。 文件转换：支持多种文件格式通过导入/导出功能跟.md格式相互转换。 支持中文：支持中文，可以帮助大家更好地理解各项功能。 视图模式：支持大纲和文档列表视图，方便在不同段落和不同文件之间进行切换。 跨平台：支持macOS、Windows和Linux系统。 目前免费：这么好用的编辑器竟然是免费的。 快速开始 下载安装 下载地址：https://typora.io/#download。 设置语言 在默认情况下，Typora会使用操作系统的语言，如果想要自定义语言，可以在Typora编辑器上执行如下操作：【偏好设置】→【通用】→【语言】，选择语言后，重启Typora即可生效。 实时预览 Typora 编辑器最具特色的功能是实时预览，当输入 Markdown 标记后，按回车键或把光标定位到别的段落就能够看到预览效果。 安装Pandoc Pandoc 是一个标记语言转换工具，可实现不同标记语言间的格式转换。 Typora 的文件导入/导出功能是使用 Pandoc 把 Markdown 文件转换成不同格式的文件，所以如果想使用文件导入/导出功能，必须要先安装 Pandoc。 如果不安装 Pandoc，Typora 只支持导出 HTML 和 PDF 格式的文件。 如果安装了 Pandoc，Typora 支持的文件格式如下。 · 导入文件格式。 如.docx、.latex、.tex、.ltx，.rst、.rest、.org、.wiki、.dokuwiki、.textile、.opml、.epub等。 · 导出文件格式。 如HTML、PDF、Word、OpenOffice、RTF、ePub、LA TEX、MediaWiki、PNG等。 Pandoc的安装步骤如下。 打开 https://github.com/jgm/pandoc/releases/latest，下载最新的安装包（注意要对应本机的操作系统），双击后按照提示一步一步安装即可。 macOS 用户还可以使用 home-brew 进行安装。 sudo brew install pandoc 高效地使用Markdown Typora 支持 GFM，还扩展了很多其他的功能（如支持数学公式、上标、下标、高亮、各种图表等），它几乎为每一种标记都提供了快捷的操作方式，并且通过最佳实践规避了一些令人困惑的操作，这使我们的写作变得更加轻松。 基础语法和GFM语法 编辑样式 在 Typora 中通过执行：菜单栏→【格式】→【加粗/斜体/代码（行内代码）/图像/超链接】可以添加或移除关于文字样式 的标记符号。如果没有选中文字，则只会添加标记符号；如果选中了文字，则会为选中的文字添加或移除标记符号。 相关样式的快捷键如下。 VS Code Visual Studio Code（简称 VS Code）是微软推出的一款开源的代码编辑器。它跨平台，同时支持Windows、macOS 和 Linux操作系统；它功能丰富，内置了 Git 版本控制系统，支持智能感知、自定义代码片段、格式化、命令面板等功能；最重要的是它有一个非常活跃的插件市场，上面有很多强大的插件供我们扩展 VS Code 的各项功能。 官网下载地址 https://code.visualstudio.com/ 按照提示进行安装即可 基础设置 中文插件 安装 Ctrl+Shift+X 快捷键 或者File-Preferences-Extensions 进入插件市场 输入 chinese 点击Install 安装 重启软体生效 切换语言 通过 View-Command Palette...或者快捷键Ctrl+Shift+P进入命令操作界面 在命令面板中输入 Configure Display Language 在列出的语言列表进行切换，重启生效 快捷键插件 之前用熟练别的编辑器可能对其快捷键很熟悉了，通过安装相关插件可以继续使用这些快捷键。 常用的快键键插件如下。 IntelliJ IDEA Key Bindings for Visual Studio Code Sublime Text Keymap and Settings Importer Visual Studio Keymap Atom Keymap Vi m Notepad++keymap Eclipse Keymap 插件推荐 Setting Sync: 使用 Github Gist 服务同步你的扩展配置的工具，更换设备再也不用一个一个的安装扩展了； Dracula Official： 吸血鬼主题，之前一直喜欢 One Dark 风格的主题，最近开始觉得本主题才更舒服； Vim: 如果你和我一样是 Vim 用户的话，这款扩展一定同样必不可少； GitLens: Git 用户必备，我一直认为这款插件带来的体验超越了 JetBrains 系列产品，这也是我逐步将 VS Code 作为主力 IDE 的原因之一，作为补充，可以再安装一个 Git History，颜值控必备； indent-rainbow：用颜色填充缩进，非常直观，如果有缩进错误还会变成红色，在 WebStorm 上暂时没有此扩展的替代品； Bracket Pair Colorizer： 为括号对进行着色，既美观也实用； Highlight Matching Tag： 点击某 Tag 时对应的 Tag 下会有下划线标示，比较实用； ESLint： 如果不是上古时代过来的高手，lint 系列工具是必备的，必装； Prettier - Code formatter： 配合 ESLint 使用，统一美化项目代码，必装； EditorConfig for VS Code： 让 VS Code 也能认识 .editorconfig 文件，必装； Vetur： Vue 开发者必装，不装还能开发的话算你厉害； Debugger for Chrome： 调试工具，必装； Markdown All in One All you need to write Markdown Markdown Preview Enhanced 超级Markdown插件MPE Markdown Preview Mermaid Support: Mermaid 图表预览 markdownlint 语法检查 禁用/启用插件 进入插件管理界面会看到：搜索框、【已启用】、【推荐】、【已禁用】。 默认已安装的插件处于启用状态。如果想卸载或禁用某个插件，可以在【已启用】列表中查找，然后在详情页中选择禁用或卸载插件。禁用的插件会在重启后停用，可在【已禁用】列表中查看和重新启用这些插件。 使用小技巧 增强预览 默认的预览功能比较简单，很多语法都不支持，有些语法渲染的效果也不是很好，这时我们需要安装一个增强预览插件——Markdown Preview Enhanced插件来增强预览功能。 安装完成后，在源码编辑界面，单击鼠标右键，在弹出的操作选项中单击【Markdown Preview Enhanced:Open Preview】，打开增强预览界面。 小提示： 如果想显示文件的目录，可以在预览界面按Esc键。 超级Markdown插件MPE Markdown Preview Enhanced（以下简称MPE）是一款超级强大的Markdown插件，官方文档这样形容它——让你拥有飘逸的Markdown写作体验。 这么厉害的插件到底有什么功能呢? 可以这样说，Typora支持的所有Markdown语法，包括GFM、数学公式、图表、目录等，MPE基本都支持。如果你已经很熟悉Typora的使用，那么使用MPE也会很轻松。除此之外，MPE还支持引用文件和制作幻灯片，这两个功能绝对会让你眼前一亮。 接下来我们将对几个关键功能进行详细介绍。 1.插入目录 插入目录有两种方法。 方法1：直接在文件中输入[TOC]然后按回车键，这种方式比较通用，在Typora中也可以正常渲染。 方法2：调出命令行面板，输入[TOC]，在联想出来的命令列表中单击[Markdown Preview Enhanced:Create TOC]，保存后可正常渲染目录。 小提示： 在目录生成后，如果文中内容有更改，保存后，目录也会自动更新。 2.引用文件 MPE可以非常方便地引用外部文件，它支持引用.md、.csv、.jpg、.png、.gif、.html、.pdf 等格式的文件。其引用格式如下。 @import \"文件名\" 或者 2.1 引用 Markdown文件 @ import \"README.md\" 也可以引用一个在线文件 @import \"网址\" 2.2 引用 图片 MPE可引用的图片格式包括：.jpg、.gif、.png、.apng、.svg、.bmp。 可以直接引用图片 @ import \"图片.jpg\" 引用的同时可以设置大小 @ import \"图片.jpg\" {width=\"200px\" height=\"150px\" title =\"图片\" alt=\"一张图片\"} 2.3 引用 csv文件 被引用的csv文件会直接解析成表格。 3.幻灯片 3.1创建幻灯片 MPE使用reveal.js来渲染幻灯片，这比直接使用reveal.js来创建幻灯片更加简单便捷。 幻灯片通过 来分页，例如 #第一页 这是第一张幻灯片 #第一页 这是第二张幻灯片 幻灯片会随着光标进行切换，如果你感觉在编辑器中查看不方便，也可以通过浏览器查看。具体方法是在预览界面单击鼠标右键，选择【Open in Browser】，就可以了。 小提示： 不管是在编辑器中，还是在浏览器中，如果想要切换到幻灯片的预览界面，直接按Esc键就可以了。 3.2幻灯片主题 幻灯片默认使用白色主题，如果想切换主题可以这样设置，将如下代码放到Markdown文件的头部即可 --- presentation: theme: solarized.css --- beige.css black.css blood.css league.css moon.css night.css serif.css simple.css sky.css solarized.css white.css none.css white.css（默认） 小提示： reveal.js提供的配置选项都可以在MPE中非常方便地进行配置，想了解更多配置选项可参考官方文档。 4.导出文件 4.1导出HTML文件 在MPE中，把Markdown格式的文件导出为HTML文件非常简单，只需在预览界面上，单击鼠标右键，选择【HTML】→【HTML(offline)】即可，HTML文件会被导出到与当前Markdown文件同级的目录中。 可是在默认情况下，当Markdown文件有改动时，HTML文件并不会同步更新，如果想做到这一点，需要在Markdown文件头部加上如下代码。 --- export_on_save: html : true --- 此后，如果这个Markdown文件有改动，只要进行保存，就会自动导出最新的HTML文件。 4.2导出PDF文件（Puppeteer） 通过工具（Puppeteer）导出PDF文件，需要先安装Puppeteer，在命令行执行如下命令。 npm install -g puppeteer 安装完成后，只需在预览界面上单击鼠标右键，选择【Chrome (Puppeteer)】→【PDF】即可，PDF文件会被导出到当前目录中，而且会被自动打开。 小提示： 导出PNG和JPEG格式的图片也是使用Puppeteer，步骤同上 4.3导出PDF文件（Prince） 使用Prince导出的PDF文件会自动生成目录，也支持自动导出功能。 安装方法请参考https://www.princexml.com/doc-install/ 安装完成后，只需在预览界面上，单击鼠标右键，选择【PDF(prince)】即可，PDF文件会被导出到当前目录中，而且会被自动打开。 如果我们想在修改Markdown文件之后，自动导出最新的PDF文件，只需在Markdown文件头部加上如下代码。 --- export_on_save: prince : true --- 此后，在每次修改完Markdown文件之后，只要进行保存，就会自动导出最新的PDF文件。 高效编辑 命令面板 命令面板提供了几乎所有功能的快速访问路径，在命令面板中我们可以进行快速打开文件、运行命令、管理和安装扩展、运行任务、打开视图、行跳转、符号跳转等操作。 使用快捷键 Ctrl+P 注意： 现在输入框中是没有任何符号的，因此默认会列出最近打开过的文件，我们可以在这里快速打开之前打开过的文件。 在命令面板的输入框中输入 [?]可以查看命令面板的操作帮助，输入不同的符号，能够切换到不同的操作面板，达到快速操作的目的。 1.运行命令 在输入框中输入[>]，会切换到运行命令界面，输入命令关键字会列出所有可运行的命令，单击即可运行。 运行命令应该是我们最常用的操作了，因此VS Code提供了快捷键以快速进入命令操作界面，Ctrl+Shift+P 2.行跳转 命令面板的输入框中输入[:+行号]，并按回车键会行跳转到指定的行，被指定的行会高亮显示。 折叠内容 通常，编辑器都有一个非常好用的功能，那就是可以折叠内容结构，这使内容结构更清晰，也更容易阅读。令人惊喜的是，VS Code竟然支持Markdown源码的折叠，当遇到代码块、嵌套列表（有序列表/无序列表/任务列表）时，在编辑器中就会显示折叠图标，单击该图标即可把内容折叠。最棒的是VS Code还支持标题的折叠。具体如下图所示。 自动保存 很多人都有过忘记保存文件，导致辛苦了半天的工作付诸东流的惨痛经历。VS Code提供了自动保存的功能，它有3种保存策略可供选择。 1）afterDelay：当文件修改超过一定的时间（默认是1000ms）时自动保存。 2）onFocusChange：当编辑器失去焦点时自动保存更新后的文件。 3）onWindowChange：当窗口失去焦点时自动保存更新后的文件。 VS Code默认使用的是第1种策略，执行：菜单栏→【文件】→【自动保存】，开启自动保存，此后，当文件修改超过1000ms时就会自动保存。 如果想修改延迟时间，可以单击活动栏下面的【管理】图标→【设置】→在搜索设置输入框中输入[自动保存] 在【Files:Auto Save】中可以修改自动保存策略，在【Files：Auto Save Delay】中可以修改延迟保存时间。 智能感知 我们在前面提到过VS Code的智能感知功能，这绝对又是一个神技。通过智能感知可以进行自动补全，可以快速插入Markdown语法和自定义的代码片段。触发智能感知的快捷键是 Ctrl + 空格 注意： 在Windows系统下快捷键“Ctrl+空格键”可能会跟输入法的快捷键相冲突，可通过修改快捷键解决。 操作步骤：【管理】→【键盘快捷方式】→在搜索框输入[Trigger Suggest]（触发建议）→修改快捷键。 注意： 关于快速插入代码片段的示例，我们后面再讲。如果想使用更多快捷键和自动补全的功能，需要安装一个扩展插件——Markdown All in One。 Markdown All in One Markdown All in One（以下简称MAO）提供了常用的Markdown快捷键和自动补全功能。其快捷键如下所示 操作 Key Command 加粗 Ctrl/Cmd + B Toggle bold 斜体 Ctrl/Cmd + I Toggle italic 提升标题级别 Ctrl/Cmd + Shift + ] Toggle heading (uplevel) 降低标题级别 Ctrl/Cmd + Shift + [ Toggle heading (downlevel) 插入数学公式 Ctrl/Cmd + M Toggle math environment 选中/取消选中任务列表项 Alt + C Check/Uncheck task list item 切换预览 Ctrl/Cmd + Shift + V Toggle preview 将预览切换到一边 Ctrl/Cmd + K V Toggle preview to side 自动不全请去扩展插件官网观看或者自己体验 https://marketplace.visualstudio.com/items?itemName=yzhang.markdown-all-in-one 自定义代码片段 在VS Code中，可以自定义常用的代码片段，通过触发智能感知，实现一键插入。方法是打开自定义Markdown代码片段的文件，执行：【管理（左下小齿轮）】→【用户代码片段】→在弹出的面板中选择新建代码片段。 语法检查 markdownlint是用来检查Markdown写作规范的。 安装markdownlint以后，它会自动对Markdown文件进行检查，并在VS Code底部面板中列出检查出来的问题。问题标签上会显示检查出来的问题数量，列表中的问题会根据编辑器中已打开的文件名进行分类，单击具体问题会跳转到编辑器中对应的位置，在位置的上面会显示一个小灯泡图标，单击小灯泡会显示解决问题的提示，如下图所示。 拼写检查 Code Spell Checker插件能够帮助我们检查常见的拼写错误，也是必备的插件之一 版本管理 VS Code内置了Git版本管理系统，但功能比较简单，在此推荐3个功能增强插件。 1）GitLens：增强了VS Code内置的Git功能。 2）Git History：增强了Git提交历史的功能。 3）gitignore：可以帮助我们使用.gitignore文件。 由于Git相关的知识点较多，且比较专业，如果想深入了解，还是建议读者系统学习一下，了解Git相关的知识以后，关于这几个插件的使用也就不成问题了。 Remote Development 远程开发 Visual Studio Code Remote 允许开发者将容器，远程计算机，或 Windows Subsystem for Linux (WSL) 作为完整的开发环境。你可以： 在部署相同的操作系统上进行开发，或者使用更大或更专业的硬件。 把开发环境作为沙箱，以避免影响本地计算机配置。 让新手轻松上手，让每个人都保持一致的开发环境。 使用原本在本地环境不可用的工具或运行时，或者管理它们的多个版本。 在 WSL 里开发 Linux 应用。 从多台不同的计算机访问现有的开发环境。 调试在其他位置（比如客户网站或云端）运行的应用程序。 所有以上的功能，并不需要在你的本地开发环境有源代码。通过 VS Code Remote，轻松连接上远程环境，在本地进行开发。 从原理上讲，VSCode 远程开发扩展相当于把开发者自己机器上的 VSCode 原样拷贝到作为目标机器（Remote Host）上，以服务的形式运行，而本地的 VSCode 作为客户端，两者之间通过远程通讯协议彼此协调合作，实际上的开发工作主要是在服务端完成的。这个架构特别之处在于，我们日常所使用的扩展也被分成两个阵营：和界面定制相关的部分，主要包括样式、主题、图标等等在客户端运行；而与开发相关的大部分扩展则在服务端运行。后面在实际操作的部分，我们会看到界面上相应的变化。 Remote Development extension pack 扩展包 Remote Development extension pack 扩展包含三个扩展，官方说明 https://code.visualstudio.com/docs/remote/remote-overview Remote - SSH - 通过使用 SSH 打开远程计算机或者VM上的文件夹，来连接到任何位置。 Remote - Containers – 把 Docker 作为你的开发容器。 Remote - WSL - 在 Windows Subsystem for Linux 中，获得 Linux 般的开发体验。 安装 Ctrl+Shift+X 进入扩展商店 搜索 Remote Development 安装扩展包，三个扩展会一并安装 Remote - SSH 在比本地机器更大、更快或更专业的硬件上进行开发。 在不同的远程开发环境之间快速切换，安全地进行更新，而不必担心影响本地计算机。 调试在其他位置运行的应用程序，例如客户网站或云端。 配置 SSH 通过 SSH 连接到服务器是运维的常规操作，不再赘述。官方文档也有详细的步骤指导。 本地 [SSH Client] (https://code.visualstudio.com/docs/remote/troubleshooting#_installing-a-supported-ssh-client) 一般不用配置. 远程 SSH server linux 一般自带 openssh-server . 使用 SSH Key 的方式尽管初始配置要麻烦一些，但是一劳永逸. 注意： 对于Windows用户，生成的key通常位于%USERPROFILE%.ssh 目录下 连接到服务器 # 登陆的时候自动打开命令行窗口 通过命令面板（快捷键 Ctrl+Shift+P） 打开设置 Remote-SSH-Settings，设置Remote.SSH:Show Login Terminal为true # SSH 连接 配置 插件后左下角会出现一个绿色的图标，点击选择会在命令窗口弹出几个选项 选择Remote-SSH：Connect to Host 可以手工输入例如 ssh hello@microsoft.com 一般不用，太麻烦。 选择Remote-SSH：Connect to Host->Open Configuration File->选择一个config 之后会出来配置config的信息，Host是自己给这份配置文件起的名字，HostName是远程主机的IP地址，User是登录名，Port是SSH端口默认是22， IdentityFile是SSH Keys 下面给出Linux 和 Windows的示例，图片是Linux环境下的 Host aws-5-sg HostName 54.179.121.163 User admin Port 2134 IdentityFile \"/home/august/.ssh/id_rsa\" Windows 示例 Host aws-5-sg HostName 54.179.121.163 User admin Port 2134 IdentityFile \"C:\\Users\\august\\.ssh\\id_rsa\" 注意： 对于Windows用户，生成的key通常位于%USERPROFILE%.ssh 目录下 远程资源管理器 连接 输入完毕后保存，左侧 远程资源管理器 会出现配置好的信息，右键登陆即可。 第一次连接到远程服务器时的初始化工作需要消耗一段时间，以后再次打开就会快很多。请耐心等待服务器初始化完成，如果一切正常，你就会看到 VSCode 转变为远程开发模式。 # 管理扩展 再次打开扩展商店会发现变成了本地和远程两个部分。一些扩展只在本地，一些扩展会提示可以在远程安装，需要手动安装一下。安装完毕后本地会被禁用。 最终效果 Remote - Containers -待补充 您可以在部署的同一操作系统上，使用一致的工具链进行开发。 容器是隔离的，这意味着你可以在不影响本地计算机的情况下在不同的开发环境之间快速切换。 其他人可以轻松地为您的项目做出贡献，因为他们可以在一致的开发环境中轻松开发、构建和测试。 一个 devcontainer.json 文件可以被用来告诉 VS Code 如何配置开发容器，包括使用的 Dockerfile、端口映射以及在容器中安装哪些插件等等。 Remote - WSL 待补充 使用 Windows 在基于 Linux 的环境中进行开发，使用平台特定的工具链和程序。 编辑位于 WSL 中的文件或挂载的 Windows 文件系统（例如 /mnt/c）。 在 Windows 上运行和调试基于 Linux 的应用程序。 插件直接在 Linux 发行版中运行，因此你不需要担心路径问题、软件兼容性或其他跨平台的问题。你可以像在 Windows 中一样，在 WSL 中无缝地使用 VS Code。 参考 https://zhuanlan.zhihu.com/p/64505333 https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh https://www.jianshu.com/p/0f2fb935a9a1 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"gitbook/references.html":{"url":"gitbook/references.html","title":"参考文献","keywords":"","body":"参考文献 http://gitbook.zhangjikai.com/ https://mingrn.gitbooks.io/knowledge-star/content/ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"docsify/":{"url":"docsify/","title":"Docsify","keywords":"","body":"docsify A magical documentation site generator. https://docsify.js.org/#/ 部署 官方文档 很清楚，不再梳理，只记录个人方案 侧边栏折叠 官方一直没解决 方案一 插件 docsify-sidebar-collapse 别忘了添加css样式 方案二 JS+CSS 目前采用 issues里的解决方案 JS css .sidebar-nav-parent-li { position: relative; } .sidebar-nav { padding-right: 10px; } .sidebar-nav .ul-after { content: ''; width: 10px; height: 30px; /* background: red; */ position: absolute; right: 10px; top: 0px; display: flex; align-items: center; } .ul-after-sanjiao { width: 0; height: 0; border-left: 8px solid #cecece; border-top: 8px solid transparent; border-bottom: 8px solid transparent; transition: transform 0.3s; position: relative; } .ul-after-sanjiao::after { content: ''; width: 0; height: 0; position: absolute; top: -8px; left: -11px; border-left: 8px solid #fff; border-top: 8px solid transparent; border-bottom: 8px solid transparent; } .ul-after-sanjiao:hover { border-left: 8px solid #42b983; } .sidebar-nav-parent-li-shouqi .ul-after-sanjiao { transform: rotate(90deg); transition: transform 0.3s; } docsify html 配置 plugins: [ function (hook) { hook.doneEach(function () { let max_cengji = 3; //默认展开层级深度 //添加箭头 $('.sidebar-nav').find('li').each(function (i, e) { var el = e; if (el.nextSibling && el.nextSibling.tagName == 'UL') { $(el).addClass('sidebar-nav-parent-li').append( \"\"); } }) //初始时候展开层级 function find_children_li(dom, current_cengji) { if (dom) { current_cengji++; $($(dom).find('li').each(function (i, e) { var el = e; if (el.nextSibling && el.nextSibling.tagName == 'UL') { if (current_cengji >= max_cengji) { $(el.nextSibling).hide(); $(el).addClass('sidebar-nav-parent-li-shouqi'); } find_children_li(el.nextSibling, current_cengji); } })) } else { return } } find_children_li($('.sidebar-nav')[0], 0); //绑定事件 $('.ul-after-sanjiao').on('click', function (e) { e.stopPropagation(); e.preventDefault(); var el = e.target.parentNode.parentNode.nextSibling; if (el) { $(el).toggle(); if ($(e.target.parentNode.parentNode).hasClass('sidebar-nav-parent-li-shouqi')) { $(e.target.parentNode.parentNode).removeClass('sidebar-nav-parent-li-shouqi'); } else { $(e.target.parentNode.parentNode).addClass('sidebar-nav-parent-li-shouqi'); } } }) }) } ] 实现效果 pkb 托管到 Gitlab 托管 Gitlab 私人仓库，仅Pages公开，源码仅Project Members 注册 Gitlab 帐号 与 Github 类似 ,见 https://notes.augustdoit.men/gitbook/deploy.html 配置好 SSH key 创建私人仓库 pkb vi /root/.ssh/config # github Host github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/github/id_rsa # gitlab Host gitlab.com HostName gitlab.com IdentityFile ~/.ssh/github/id_rsa 因为我的 Gitlab 与 Github user.name 及 user.email一样 git config --global user.name \"augustdoit\" git config --global user.email \"augustdoit@gmail.com\" 进到 docsify 目录 cd docs git init git remote add origin git@gitlab.com:augustdoit/pkb.git git add . git commit -m \"Initial commit\" git push -u origin master 开启 Gitlab Pages 添加域名，DNS验证 若使用 Cloudflare SSL 需要单独添加 Cloudflare Origin CA 根证书 下面公开的Cloudflare Origin CA 根证书为 -----BEGIN CERTIFICATE----- MIIEADCCAuigAwIBAgIID+rOSdTGfGcwDQYJKoZIhvcNAQELBQAwgYsxCzAJBgNV BAYTAlVTMRkwFwYDVQQKExBDbG91ZEZsYXJlLCBJbmMuMTQwMgYDVQQLEytDbG91 ZEZsYXJlIE9yaWdpbiBTU0wgQ2VydGlmaWNhdGUgQXV0aG9yaXR5MRYwFAYDVQQH Ew1TYW4gRnJhbmNpc2NvMRMwEQYDVQQIEwpDYWxpZm9ybmlhMB4XDTE5MDgyMzIx MDgwMFoXDTI5MDgxNTE3MDAwMFowgYsxCzAJBgNVBAYTAlVTMRkwFwYDVQQKExBD bG91ZEZsYXJlLCBJbmMuMTQwMgYDVQQLEytDbG91ZEZsYXJlIE9yaWdpbiBTU0wg Q2VydGlmaWNhdGUgQXV0aG9yaXR5MRYwFAYDVQQHEw1TYW4gRnJhbmNpc2NvMRMw EQYDVQQIEwpDYWxpZm9ybmlhMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC AQEAwEiVZ/UoQpHmFsHvk5isBxRehukP8DG9JhFev3WZtG76WoTthvLJFRKFCHXm V6Z5/66Z4S09mgsUuFwvJzMnE6Ej6yIsYNCb9r9QORa8BdhrkNn6kdTly3mdnykb OomnwbUfLlExVgNdlP0XoRoeMwbQ4598foiHblO2B/LKuNfJzAMfS7oZe34b+vLB yrP/1bgCSLdc1AxQc1AC0EsQQhgcyTJNgnG4va1c7ogPlwKyhbDyZ4e59N5lbYPJ SmXI/cAe3jXj1FBLJZkwnoDKe0v13xeF+nF32smSH0qB7aJX2tBMW4TWtFPmzs5I lwrFSySWAdwYdgxw180yKU0dvwIDAQABo2YwZDAOBgNVHQ8BAf8EBAMCAQYwEgYD VR0TAQH/BAgwBgEB/wIBAjAdBgNVHQ4EFgQUJOhTV118NECHqeuU27rhFnj8KaQw HwYDVR0jBBgwFoAUJOhTV118NECHqeuU27rhFnj8KaQwDQYJKoZIhvcNAQELBQAD ggEBAHwOf9Ur1l0Ar5vFE6PNrZWrDfQIMyEfdgSKofCdTckbqXNTiXdgbHs+TWoQ wAB0pfJDAHJDXOTCWRyTeXOseeOi5Btj5CnEuw3P0oXqdqevM1/+uWp0CM35zgZ8 VD4aITxity0djzE6Qnx3Syzz+ZkoBgTnNum7d9A66/V636x4vTeqbZFBr9erJzgz hhurjcoacvRNhnjtDRM0dPeiCJ50CP3wEYuvUzDHUaowOsnLCjQIkWbR7Ni6KEIk MOz2U0OBSif3FTkhCgZWQKOOLo1P42jHC3ssUZAtVNXrCk3fw9/E15k8NPkBazZ6 0iykLhH1trywrKRMVw67F44IE8Y= -----END CERTIFICATE----- Gitlab 自定义SSL Setting up GitLab Pages with Cloudflare Certificates 使用CI/CD template 创建 Pages 主分支在.gitlab-ci.yml中包含以下脚本： pages: stage: deploy script: - mkdir .public - cp -r * .public - mv .public public artifacts: paths: - public only: - master 权限 私人仓库，仅Pages公开，源码仅Project Members Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-18 13:30:24 "},"git/01/intro.html":{"url":"git/01/intro.html","title":"Git 学习资源","keywords":"","body":"Git 学习资源 开源书籍很多，下面索引几个，这里简单梳理 Git 和 GitHub 学习资源 Github整理的 Pro Git 中文版 官方 Git教程 廖雪峰 很好学 猴子都能懂的 Git 入门 在线模拟器 官方在线学 Learn Git branching 闯关学 很有意思 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:08 "},"py/01/intro.html":{"url":"py/01/intro.html","title":"Python 整理","keywords":"","body":"Python 教程 培训班学习笔记 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"py/01/basis.html":{"url":"py/01/basis.html","title":"Python 基础","keywords":"","body":"Python 基础 注释 单行注释（行注释） 多行注释（块注释） # 单行注释 print(\"hello python\") # 单行注释 \"\"\" 多行注释 \"\"\" 运算符 数学符号表链接：https://zh.wikipedia.org/wiki/数学符号表 算数运算符 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True > 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True >= 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True Python 2.x 中判断 不等于 还可以使用 <> 运算符 != 在 Python 2.x 中同样可以用来判断 不等于 逻辑运算符 运算符 逻辑表达式 描述 and x and y 只有 x 和 y 的值都为 True，才会返回 True否则只要 x 或者 y 有一个值为 False，就返回 False or x or y 只要 x 或者 y 有一个值为 True，就返回 True只有 x 和 y 的值都为 False，才会返回 False not not x 如果 x 为 True，返回 False如果 x 为 False，返回 True 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 not or and 逻辑运算符 变量及数据类型 程序就是用来处理数据的，而变量就是用来存储数据的。 变量在使用前都必须赋值 变量名 = 值 变量名必须是大小写英文、数字和_的组合，详见命名规则 变量的类型（初级） 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 详见 高级变量类型 字符串 (str) 列表 (list) 元组 (tuple) 字典 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 type(name) 空值 空值是 Python 里一个特殊的值，用 None 表示。None 不能理解为0，因为0是有意义的，而 None 是一个特殊的空值。 常量 数学常数 π 就是一个常量。在 Python 中，通常用全部大写的变量名表示常量 PI = 3.14159265359 不同类型变量间计算 数字型变量 之间直接计算 字符串变量 之间使用 + 拼接字符串 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串 变量的输入 input 函数 input 函数实现键盘输入 字符串变量 = input(\"提示信息：\") 类型转换函数 函数 说明 int(x) 将 x 转换为一个整数 float(x) 将 x 转换到一个浮点数 演练 price = float(input(\"请输入价格:\")) 变量的格式化输出 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符 % 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 语法格式如下： print(\"格式化字符串\" % 变量1) print(\"格式化字符串\" % (变量1, 变量2...)) 演练 \"\"\" 1. 定义字符串变量 name，输出 我的名字叫 小明，请多多关照！ 2. 定义整数变量 student_no，输出 我的学号是 000001 3. 定义小数 price、weight、money，输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 4. 定义一个小数 scale，输出 数据比例是 10.00% \"\"\" name = str(input(\"请输入姓名：\")) student_no = 1 price = 9 weight = 5 money = price * weight scale = 0.1 scale_1 = 0.1*100 print(\"我的名字是%s,请多多关照！\" % name) print(\"我的学号是%06d\" % student_no) print(\"苹果果单价 %.2f 元／斤，购买了 %.2f 斤，需要支付 %.2f 元\" % (price,weight,money)) print(\"数据比例是 %.2f%%\" % (scale*100)) print(\"数据比例是 %.2f%%\" % scale_1) 变量的命名 标识符和关键字 标示符就是程序员定义的 变量名、函数名 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 关键字 关键字 就是在 Python 内部已经使用的标识符 关键字 具有特殊的功能和含义 开发者 不允许定义和关键字相同的名字的标示符 通过以下命令可以查看 Python 中的关键字 import keyword print(keyword.kwlist) 提示：关键字的学习及使用，会在后面的课程中不断介绍 import 关键字 可以导入一个 “工具包” 在 Python 中不同的工具包，提供有不同的工具 变量的命名规则 命名规则 可以被视为一种 惯例，并无绝对与强制 目的是为了 增加代码的识别和可读性 变量名必须是大小写英文、数字和_的组合 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名 每个单词都使用小写字母，单词与单词之间使用 _下划线 连接 例如：first_name、last_name、qq_number、qq_password 驼峰命名法 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法 第一个单词以小写字母开始，后续单词的首字母大写 例如：firstName、lastName 大驼峰式命名法 每一个单词的首字母都采用大写字母 例如：FirstName、LastName、CamelCase 判断 if 语句 if else 语法格式 if 要判断的条件: 条件成立时，要做的事情 …… else: 条件不成立时，要做的事情 …… 注意： if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块 演练 \"\"\" 输入用户年龄，判断是否满 18 岁，满足，允许进网吧嗨皮，否则不允许 \"\"\" age = int(input(\"请输入年龄：\")) if age >= 18: print(\"进来Happy\") else: print(\"回家找你妈妈\") 逻辑运算 Python 中的 逻辑运算符 包括：与 and／或 or／非 not 三种 and 同时满足，返回 True or 只要有一个满足，返回 True not 非／不是 演练 # 定义一个布尔型变量 `is_employee`，判断是否是本公司员工 is_employee = True if not is_employee: print(\"非公勿内\") # 定义整数变量 python_score、c_score，代码判断成绩,有一门成绩 > 60 分就算合格 python_score = 50 c_score = 50 if python_score > 60 or c_score > 60: print(\"考试通过\") else: print(\"再接再厉！\") elif 语法格式如下： if 条件1: 条件1满足执行的代码 …… elif 条件2: 条件2满足时，执行的代码 …… elif 条件3: 条件3满足时，执行的代码 …… else: 以上条件都不满足时，执行的代码 …… if 的嵌套 语法格式如下： if 条件 1: 条件 1 满足执行的代码 …… if 条件 1 基础上的条件 2: 条件 2 满足时，执行的代码 …… # 条件 2 不满足的处理 else: 条件 2 不满足时，执行的代码 # 条件 1 不满足的处理 else: 条件1 不满足时，执行的代码 …… 演练-石头剪子布 # 电脑随机出拳 import random computer = random.randint(1,3) # 玩家出拳 player = int(input(\"请出拳 石头1 剪刀2 布3：\")) # 比较胜负 print(\"玩家出拳为%d，电脑出拳为%d\" % (player,computer)) if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player ==3 and computer == 1)): print(\"恭喜！玩家胜利\") elif player == computer: print(\"平局，再来一盘\") else: print(\"你输了！再战\") 随机数的处理 import random 导入随机数的模块 random.randint(a,b) 返回 [a, b] 之间的整数，包含 a 和 b 循环 程序开发的三大流程 在程序开发中，一共有三种流程方式： 顺序 —— 从上向下，顺序执行代码 分支 —— 根据条件判断，决定执行代码的 分支 循环 —— 让 特定代码 重复 执行 while 循环 基本语法 初始条件设置 —— 通常是重复执行的 计数器 while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件(计数器 + 1) 死循环： 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！ 计数方法： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从 0 开始计数 除非需求的特殊要求，否则 循环 的计数都从 0 开始 演练-循环计算 # 计算 0 ~ 100 之间所有数字的累计求和结果 result = 0 i = 0 while i break continue break 和 continue 是专门在循环中使用的关键字 break 某一条件满足时，退出循环，不再执行后续重复的代码 continue 某一条件满足时，不执行后续重复的代码 break 和 continue 只针对 当前所在循环 有效 break 在循环过程中，如果 某一个条件满足后，不 再希望 循环继续执行，可以使用 break 退出循环 i = 0 while i 上例输出 1 2 3 4 continue 在循环过程中，如果 某一个条件满足后，不 希望 执行循环代码，但是又不希望退出循环，可以使用 continue 也就是在整个循环中，只有某些条件，不需要执行循环代码，而其他条件都需要执行 注意：使用 continue 时，容易出现死循环。 i = 0 while i 上例输出结果不包括 3 while 循环嵌套 while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... while 条件 2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件 2 处理条件 1 print 不换行 # 向控制台输出内容结束之后，不会换行 print(\"*\", end=\"\") # 单纯的换行 print(\"\") 演练-打印星星 # 在控制台连续输出五行 *，每一行星号的数量依次递增 row = 1 while row 演练-九九乘法表 # 打印九九乘法口诀表 # 定义起始行 row = 1 #最大9行 while row 字符串中的转义字符 \\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐 \\n 在控制台输出一个 换行符 制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本 转义字符 描述 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\n 换行 \\t 横向制表符 \\r 回车 函数 所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的使用包含两个步骤： 定义函数 —— 封装 独立的功能 调用函数 —— 享受 封装 的成果 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用 语法格式及注释 def 函数名(参数1，参数2...): \"\"\"注释\"\"\" 函数封装的代码 函数名称 应该能够表达 函数封装代码 的功能，方便后续的调用 函数名称 的命名应该 符合 标识符的命名规则 可以由 字母、下划线 和 数字 组成 不能以数字开头 **不能与关键字重名 在 连续的三对引号 之间编写对函数的说明文字 在 函数调用 位置，使用快捷键 CTRL + Q 可以查看函数的说明信息 因为 函数体相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留 两个空行 函数的参数、返回值 形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用 实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的 返回值 是函数执行结束后，最后给调用者的一个结果，以便调用者针对具体的结果做后续的处理 函数中使用return关键字可以返回结果 调用函数一方，可以 使用变量来接收函数的返回结果 def sum_2_num(num1, num2): \"\"\"对两个数字的求和\"\"\" return num1 + num2 # 调用函数，并使用 result 变量接收计算结果 result = sum_2_num(10, 20) print(\"计算结果是 %d\" % result) 函数的嵌套调用 语法 def 函数1(): ... def 函数2(): ... 调用函数1 ... 调用函数2 演练 # 打印5行分割线，分割线符号个数自定义 def print_line(char, times): print(char * times) def print_lines(char, times): row = 0 while row 模块中的函数（初级） 模块是 Python 程序架构的一个核心概念 每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块 模块 就好比是工具包，要想使用这个工具包中的工具，就需要 import 导入这个模块 在模块中定义的 全局变量 、 函数 都是模块能够提供给外界直接使用的工具 导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，使用这个模块中定义的变量或者函数 模块名也是一个标识符 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 Pyc 文件 C 是 compiled 编译过 的意思 浏览程序目录会发现一个 pycache 的目录 目录下会有 xxxx.cpython-37.pyc 文件，cpython-37 表示 Python 解释器的版本 这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码 Python 这样保存 字节码 是作为一种启动 速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译 生成一个二进制 字节码 再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码 有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 高级变量类型 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 详见 高级变量类型 字符串 (str) 列表 (list) 元组 (tuple) 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 列表 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错IndexError,最后一个元素的索引是 -1 name_list = [\"zhangsan\", \"lisi\", \"wangwu\"] 常用操作 在 ipython3 中中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： In [1]: name_list. name_list.append name_list.count name_list.insert name_list.reverse name_list.clear name_list.extend name_list.pop name_list.sort name_list.copy name_list.index name_list.remove 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 del 关键字 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 del name_list[1] 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 In [1]: import keyword In [2]: print(keyword.kwlist) ['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] In [3]: print(len(keyword.kwlist)) 35 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 # for 循环内部使用的变量 in 列表 name_list = [\"张三\",\"李四\",\"王五\",\"王小二\"] for name in name_list: 循环内部针对列表元素进行操作 print(name) 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 元组 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 info_tuple = (\"zhangsan\", 18, 1.75) 空元组 info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号 info_tuple = (50, ) 常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下 info.count info.index 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 # for 循环内部使用的变量 in 元组 for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 ```python info = (\"zhangsan\", 18) print(\"%s 的年龄是 %d\" % info) #### 元组和列表之间的转换 使用 `list` 函数可以把元组转换成列表 ```python list(元组) 使用 tuple 函数可以把列表转换成元组 tuple(列表) 字典 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 xiaoming = {\"name\": \"小明\", \"age\": 18, \"gender\": True, \"height\": 1.75} 常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： In [1]: xiaoming. xiaoming.clear xiaoming.items xiaoming.setdefault xiaoming.copy xiaoming.keys xiaoming.update xiaoming.fromkeys xiaoming.pop xiaoming.values xiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 # for 循环内部使用的 `key 的变量` in 字典 for k in xiaoming: print(\"%s: %s\" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 card_list = [{\"name\": \"张三\", \"qq\": \"12345\", \"phone\": \"110\"}, {\"name\": \"李四\", \"qq\": \"54321\", \"phone\": \"10086\"} ] 字符串 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 \" 或者 一对单引号 ' 定义一个字符串 虽然可以使用 \\\" 或者 \\' 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 \"，可以使用 ' 定义字符串 如果字符串内部需要使用 '，可以使用 \" 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 \" 来定义字符串 string = \"Hello Python\" for c in string: print(c) 常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = \"\" 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： In [1]: hello_str. hello_str.capitalize hello_str.isidentifier hello_str.rindex hello_str.casefold hello_str.islower hello_str.rjust hello_str.center hello_str.isnumeric hello_str.rpartition hello_str.count hello_str.isprintable hello_str.rsplit hello_str.encode hello_str.isspace hello_str.rstrip hello_str.endswith hello_str.istitle hello_str.split hello_str.expandtabs hello_str.isupper hello_str.splitlines hello_str.find hello_str.join hello_str.startswith hello_str.format hello_str.ljust hello_str.strip hello_str.format_map hello_str.lower hello_str.swapcase hello_str.index hello_str.lstrip hello_str.title hello_str.isalnum hello_str.maketrans hello_str.translate hello_str.isalpha hello_str.partition hello_str.upper hello_str.isdecimal hello_str.replace hello_str.zfill hello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求! 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=\"\", num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\\r', '\\t', '\\n' 和空格 string.splitlines() 按照行('\\r', '\\n', '\\r\\n')分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) => 开始索引 >= 范围 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练 num_str = \"0123456789\" # 截取从 2 ~ 5 位置 的字符串 print(num_str[2:6]) # 截取从 2 ~ `末尾` 的字符串 print(num_str[2:]) # 截取从 `开始` ~ 5 位置 的字符串 print(num_str[:6]) # 截取完整的字符串 print(num_str[0:]) print(num_str[:]) # 从开始位置，每隔一个字符截取字符串 print(num_str[::2]) # 从索引 1 开始，每隔一个取一个 print(num_str[1::2]) # 截取从 2 ~ `末尾 - 1` 的字符串 print(num_str[2:]) # 截取字符串末尾两个字符 print(num_str[-2:]) # 字符串的逆序（面试题) print(num_str[-1::-1]) print(num_str[::-1]) 公共方法 Python 内置函数 Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： \"0\" 切片 描述 Python 表达式 结果 支持的数据类型 切片 \"0123456789\"[::-2] \"97531\" 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [\"Hi!\"] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 > >= == (1, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符 成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： for 变量 in 集合: 循环体代码 else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 students = [ {\"name\": \"阿土\", \"age\": 20, \"gender\": True, \"height\": 1.7, \"weight\": 75.0}, {\"name\": \"小美\", \"age\": 19, \"gender\": False, \"height\": 1.6, \"weight\": 45.0}, ] find_name = \"阿土\" for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict[\"name\"] == find_name: print(\"找到了\") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 break else: print(\"没有找到\") print(\"循环结束\") 综合应用 综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统 需求 程序启动，显示名片管理系统欢迎界面，并显示功能菜单 ************************************************** 欢迎使用【名片管理系统】V1.0 1. 新建名片 2. 显示全部 3. 查询名片 0. 退出系统 ************************************************** 用户用数字选择不同的功能 根据功能选择，执行不同的功能 用户名片需要记录用户的 姓名、电话、QQ、邮件 如果查询到指定的名片，用户可以选择 修改 或者 删除 名片 步骤 框架搭建 新增名片 显示所有名片 查询名片 查询成功后修改、删除名片 让 Python 程序能够直接运行 框架搭建 搭建名片管理系统 框架结构 准备文件，确定文件名，保证能够 在需要的位置 编写代码 编写 主运行循环，实现基本的 用户输入和判断 文件准备 新建 cards_main.py 保存 主程序功能代码 程序的入口 每一次启动名片管理系统都通过 main 这个文件启动 新建 cards_tools.py 保存 所有名片功能函数 将对名片的 新增、查询、修改、删除 等功能封装在不同的函数中 编写主运行循环 在 cards_main 中添加一个 无限循环 while True: # TODO(小明) 显示系统菜单 action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: pass elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 字符串判断 if action in [\"1\", \"2\", \"3\"]: if action == \"1\" or action == \"2\" or action == \"3\": 使用 in 针对 列表 判断，避免使用 or 拼接复杂的逻辑条件 没有使用 int 转换用户输入，可以避免 一旦用户输入的不是数字，导致程序运行出错 pass pass 就是一个空语句，不做任何事情，一般用做占位语句 是为了保持程序结构的完整性 无限循环 在开发软件时，如果 不希望程序执行后 立即退出 可以在程序中增加一个 无限循环 由用户来决定 退出程序的时机 TODO 注释 在 # 后跟上 TODO，用于标记需要去做的工作 # TODO(作者/邮件) 显示系统菜单 在 cards_tools 中增加四个新函数 def show_menu(): \"\"\"显示菜单 \"\"\" pass def new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\") def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") 导入模块 在 cards_main.py 中使用 import 导入 cards_tools 模块 import cards_tools 修改 while 循环的代码如下： import cards_tools while True: cards_tools.show_menu() action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: if action == \"1\": cards_tools.new_card() elif action == \"2\": cards_tools.show_all() elif action == \"3\": cards_tools.search_card() elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入：\") 至此：cards_main 中的所有代码全部开发完毕！ 完成 show_menu 函数 def show_menu(): \"\"\"显示菜单 \"\"\" print(\"*\" * 50) print(\"欢迎使用【菜单管理系统】V1.0\") print(\"\") print(\"1. 新建名片\") print(\"2. 显示全部\") print(\"3. 查询名片\") print(\"\") print(\"0. 退出系统\") print(\"*\" * 50) 保存名片数据的结构 程序就是用来处理数据的，而变量就是用来存储数据的 使用 字典 记录 每一张名片 的详细信息 使用 列表 统一记录所有的 名片字典 定义名片列表变量 在 cards_tools 文件的顶部增加一个 列表变量 # 所有名片记录的列表 card_list = [] 注意 所有名片相关操作，都需要使用这个列表，所以应该 定义在程序的顶部 程序刚运行时，没有数据，所以是 空列表 新增名片 功能分析 提示用户依次输入名片信息 将名片信息保存到一个字典 将字典添加到名片列表 提示名片添加完成 实现 new_card 方法 根据步骤实现代码 def new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\") # 1. 提示用户输入名片信息 name = input(\"请输入姓名：\") phone = input(\"请输入电话：\") qq = input(\"请输入 QQ 号码：\") email = input(\"请输入邮箱：\") # 2. 将用户信息保存到一个字典 card_dict = {\"name\": name, \"phone\": phone, \"qq\": qq, \"email\": email} # 3. 将用户字典添加到名片列表 card_list.append(card_dict) print(card_list) # 4. 提示添加成功信息 print(\"成功添加 %s 的名片\" % card_dict[\"name\"]) 技巧：在 PyCharm 中，可以使用 SHIFT + F6 统一修改变量名 显示所有名片 功能分析 循环遍历名片列表，顺序显示每一个字典的信息 基础代码实现 def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") for card_dict in card_list: print(card_dict) 显示效果不好！ 增加标题和使用 \\t 显示 def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 打印表头 for name in [\"姓名\", \"电话\", \"QQ\", \"邮箱\"]: print(name, end=\"\\t\\t\") print(\"\") # 打印分隔线 print(\"=\" * 50) for card_dict in card_list: print(\"%s\\t\\t%s\\t\\t%s\\t\\t%s\" % (card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) 增加没有名片记录判断 def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 1. 判断是否有名片记录 if len(card_list) == 0: print(\"提示：没有任何名片记录\") return 注意 在函数中使用 return 表示返回 如果在 return 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码 查询名片 功能分析 提示用户要搜索的姓名 根据用户输入的姓名遍历列表 搜索到指定的名片后，再执行后续的操作 代码实现 查询功能实现 def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") # 1. 提示要搜索的姓名 find_name = input(\"请输入要搜索的姓名：\") # 2. 遍历字典 for card_dict in card_list: if card_dict[\"name\"] == find_name: print(\"姓名\\t\\t\\t电话\\t\\t\\tQQ\\t\\t\\t邮箱\") print(\"-\" * 40) print(\"%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s\" % ( card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) print(\"-\" * 40) # TODO(小明) 针对找到的字典进行后续操作：修改/删除 break else: print(\"没有找到 %s\" % find_name) 增加名片操作函数：修改/删除/返回主菜单 def deal_card(find_dict): \"\"\"操作搜索到的名片字典 :param find_dict:找到的名片字典 \"\"\" print(find_dict) action_str = input(\"请选择要执行的操作 \" \"[1] 修改 [2] 删除 [0] 返回上级菜单\") if action == \"1\": print(\"修改\") elif action == \"2\": print(\"删除\") 修改和删除 查询成功后删除名片 由于找到的字典记录已经在列表中保存 要删除名片记录，只需要把列表中对应的字典删除即可 elif action == \"2\": card_list.remove(find_dict) print(\"删除成功\") 修改名片 由于找到的字典记录已经在列表中保存 要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可 if action == \"1\": find_dict[\"name\"] = input(\"请输入姓名：\") find_dict[\"phone\"] = input(\"请输入电话：\") find_dict[\"qq\"] = input(\"请输入QQ：\") find_dict[\"email\"] = input(\"请输入邮件：\") print(\"%s 的名片修改成功\" % find_dict[\"name\"]) 修改名片细化 如果用户在使用时，某些名片内容并不想修改，应该如何做呢？—— 既然系统提供的 input 函数不能满足需求，那么就新定义一个函数 input_card_info 对系统的 input 函数进行扩展 def input_card_info(dict_value, tip_message): \"\"\"输入名片信息 :param dict_value: 字典原有值 :param tip_message: 输入提示信息 :return: 如果输入，返回输入内容，否则返回字典原有值 \"\"\" # 1. 提示用户输入内容 result_str = input(tip_message) # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果 if len(result_str) > 0: return result_str # 3. 如果用户没有输入内容，返回 `字典中原有的值` else: return dict_value LINUX 上的 Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 which python3 修改要运行的 主 python 文件，在第一行增加以下内容 #! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 chmod +x cards_main.py 在需要时执行程序即可 ./cards_main.py 最终代码 cards_main.py cards_tools.py 变量的进阶 目标 变量的引用 可变和不可变类型 局部变量和全局变量 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 引用的概念 在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 变量引用 的示例 在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 函数的参数和返回值的传递 在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 def test(num): print(\"-\" * 50) print(\"%d 在函数内的内存地址是 %x\" % (num, id(num))) result = 100 print(\"返回值 %d 在内存中的地址是 %x\" % (result, id(result))) print(\"-\" * 50) return result a = 10 print(\"调用函数前 内存地址是 %x\" % id(a)) r = test(a) print(\"调用函数后 实参内存地址是 %x\" % id(a)) print(\"调用函数后 返回值内存地址是 %x\" % id(r)) 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict a = 1 a = \"hello\" a = [1, 2, 3] a = [3, 2, 1] demo_list = [1, 2, 3] print(\"定义列表后的内存地址 %d\" % id(demo_list)) demo_list.append(999) demo_list.pop(0) demo_list.remove(2) demo_list[0] = 10 print(\"修改数据后的内存地址 %d\" % id(demo_list)) demo_dict = {\"name\": \"小明\"} print(\"定义字典后的内存地址 %d\" % id(demo_dict)) demo_dict[\"age\"] = 18 demo_dict.pop(\"name\") demo_dict[\"name\"] = \"老王\" print(\"修改数据后的内存地址 %d\" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据(列表及字典不行) 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 def demo1(): num = 10 print(num) num = 20 print(\"修改后 %d\" % num) def demo2(): num = 100 print(num) demo1() demo2() print(\"over\") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 # 定义一个全局变量 num = 10 def demo1(): print(num) def demo2(): print(num) demo1() demo2() print(\"over\") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 num = 10 def demo1(): print(\"demo1\" + \"-\" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num) def demo2(): print(\"demo2\" + \"-\" * 50) print(num) demo1() demo2() print(\"over\") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 num = 10 def demo1(): print(\"demo1\" + \"-\" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num) def demo2(): print(\"demo2\" + \"-\" * 50) print(num) demo1() demo2() print(\"over\") 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 a = 10 def demo(): print(\"%d\" % a) print(\"%d\" % b) print(\"%d\" % c) b = 20 demo() c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异 函数进阶 目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 函数参数和返回值的作用 函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 无参数，无返回值 此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 无参数，有返回值 此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 有参数，无返回值 此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 有参数，有返回值 此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 print(\"测量结束...\") return temp result = measure() print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 wetness = 10 print(\"测量结束...\") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 result = temp, wetness = measure() 面试题 —— 交换两个数字 题目要求 有两个整数变量 a = 6, b = 100 不使用其他变量，交换两个变量的值 解法 1 —— 使用其他变量 # 解法 1 - 使用临时变量 c = b b = a a = c 解法 2 —— 不使用临时变量 # 解法 2 - 不使用临时变量 a = a + b b = a - b a = a - b 解法 3 —— Python 专有，利用元组 a, b = b, a 函数的参数 进阶 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 def demo(num, num_list): print(\"函数内部\") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print(\"函数代码完成\") gl_num = 99 gl_list = [4, 5, 6] demo(gl_num, gl_list) print(gl_num) print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list) gl_list = [6, 7, 8] mutable(gl_list) print(gl_list) 面试题 —— += 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 def demo(num, num_list): print(\"函数内部代码\") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print(\"函数代码完成\") gl_num = 9 gl_list = [1, 2, 3] demo(gl_num, gl_list) print(gl_num) print(gl_list) 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 gl_num_list = [6, 3, 9] # 默认就是升序排序，因为这种应用需求更多 gl_num_list.sort() print(gl_num_list) # 只有当需要降序排序时，才需要传递 `reverse` 参数 gl_num_list.sort(reverse=True) print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 def print_info(name, gender=True): gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s 是 %s\" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ def print_info(name, gender=True, title): 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ def print_info(name, title=\"\", gender=True): \"\"\" :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 \"\"\" gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s%s 是 %s\" % (title, name, gender_text)) # 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！ print_info(\"小明\") print_info(\"老王\", title=\"班长\") print_info(\"小美\", gender=False) 多值参数（知道） 定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 def demo(num, *args, **kwargs): print(num) print(args) print(kwargs) demo(1, 2, 3, 4, 5, name=\"小明\", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和 需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return num print(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * def demo(*args, **kwargs): print(args) print(kwargs) # 需要将一个元组变量/字典变量传递给函数对应的参数 gl_nums = (1, 2, 3) gl_xiaoming = {\"name\": \"小明\", \"age\": 18} # 会把 num_tuple 和 xiaoming 作为元组传递个 args # demo(gl_nums, gl_xiaoming) demo(*gl_nums, **gl_xiaoming) 函数的递归 函数调用自身的 编程技巧 称为递归 递归函数的特点 特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 递归案例 —— 计算数字累加 需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + ... num 的结果 def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + temp print(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"py/01/oop.html":{"url":"py/01/oop.html","title":"Python 面对对象","keywords":"","body":"Python 面对对象 面向对象(OOP)基本概念 面向对象编程 —— Object Oriented Programming 简写 OOP 目标 了解 面向对象 基本概念 面向对象基本概念 我们之前学习的编程方式就是 面向过程 的 面相过程 和 面相对象，是两种不同的 编程方式 对比 面向过程 的特点，可以更好地了解什么是 面向对象 过程和函数（科普） 过程 是早期的一个编程概念 过程 类似于函数，只能执行，但是没有返回值 函数 不仅能执行，还可以返回结果 面相过程 和 面相对象 基本概念 面相过程 —— 怎么做? 把完成某一个需求的 所有步骤 从头到尾 逐步实现 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 最后完成的代码，就是顺序地调用 不同的函数 特点 注重 步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ ￼ 面向对象 —— 谁来做？ 相比较函数，面向对象 是 更大 的 封装，根据 职责 在 一个对象中 封装 多个方法 在完成某一个需求前，首先确定 职责 —— 要做的事情（方法） 根据 职责 确定不同的 对象，在 对象 内部封装不同的 方法（多个） 最后完成的代码，就是顺序地让 不同的对象 调用 不同的方法 特点 注重 对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路 需要在面向过程基础上，再学习一些面向对象的语法 ￼ ￼ 类和对象 目标 类和对象的概念 类和对象的关系 类的设计 类和对象的概念 类 和 对象 是 面向对象编程的 两个 核心概念 类 类 是对一群具有相同 特征或者行为的事物的一个统称，是抽象的，不能直接使用 特征 被称为 属性 行为 被称为 方法 类 就相当于制造飞机时的图纸，是一个 模板，是 负责创建对象的 ￼ 对象 对象 是 由类创建出来的一个具体存在，可以直接使用 由哪一个类创建出来的对象，就拥有在哪一个类中定义的： 属性 方法 对象 就相当于用 图纸 制造 的飞机 在程序开发中，应该 先有类，再有对象 ￼ 类和对象的关系 类是模板，对象 是根据 类 这个模板创建出来的，应该 先有类，再有对象 类 只有一个，而对象可以有很多个 不同的对象 之间 属性 可能会各不相同 类 中定义了什么 属性和方法，对象 中就有什么属性和方法，不可能多，也不可能少 类的设计 在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！ ￼ 在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名 这类事物的名字，满足大驼峰命名法 属性 这类事物具有什么样的特征 方法 这类事物具有什么样的行为 大驼峰命名法 CapWords 每一个单词的首字母大写 单词与单词之间没有下划线 类名的确定 名词提炼法 分析 整个业务流程，出现的 名词，通常就是找到的类 属性和方法的确定 对 对象的特征描述，通常可以定义成 属性 对象具有的行为（动词），通常可以定义成 方法 提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑 练习 1 需求 小明 今年 18 岁，身高 1.75，每天早上 跑 完步，会去 吃 东西 小美 今年 17 岁，身高 1.65，小美不跑步，小美喜欢 吃 东西 ￼ 练习 2 需求 一只 黄颜色 的 狗狗 叫 大黄 看见生人 汪汪叫 看见家人 摇尾巴 ￼ 面相对象基础语法 目标 dir 内置函数 定义简单的类（只包含方法） 方法中的 self 参数 初始化方法 内置方法和属性 dir 内置函数（知道） 在 Python 中 对象几乎是无所不在的，我们之前学习的 变量、数据、函数 都是对象 在 Python 中可以使用以下两个方法验证： 在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表 使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法 提示 __方法名__ 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性 序号 方法名 类型 作用 01 __new__ 方法 创建对象时，会被 自动 调用 02 __init__ 方法 对象被初始化时，会被 自动 调用 03 __del__ 方法 对象被从内存中销毁前，会被 自动 调用 04 __str__ 方法 返回对象的描述信息，print 函数输出使用 提示 利用好 dir() 函数，在学习时很多内容就不需要死记硬背了 定义简单的类（只包含方法） 面向对象 是 更大 的 封装，在 一个类中 封装 多个方法，这样 通过这个类创建出来的对象，就可以直接调用这些方法了！ 定义只包含方法的类 在 Python 中要定义一个只包含方法的类，语法格式如下： class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass 方法 的定义格式和之前学习过的函数 几乎一样 区别在于第一个参数必须是 self，大家暂时先记住，稍后介绍 self 注意：类名 的 命名规则 要符合 大驼峰命名法 创建对象 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 对象变量 = 类名() 第一个面向对象程序 需求 小猫 爱 吃 鱼，小猫 要 喝 水 分析 定义一个猫类 Cat 定义两个方法 eat 和 drink 按照需求 —— 不需要定义属性 ￼ class Cat: \"\"\"这是一个猫类\"\"\" def eat(self): print(\"小猫爱吃鱼\") def drink(self): print(\"小猫在喝水\") # 创建对象 tom = Cat() tom.drink() tom.eat() 引用概念的强调 在面向对象开发中，引用的概念是同样适用的！ 在 Python 中使用类 创建对象之后，tom 变量中 仍然记录的是 对象在内存中的地址 也就是 tom 变量 引用 了 新建的猫对象 使用 print 输出 对象变量，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示） 提示：在计算机中，通常使用 十六进制 表示 内存地址 十进制 和 十六进制 都是用来表达数字的，只是表示的方式不一样 十进制 和 十六进制 的数字之间可以来回转换 %d 可以以 10 进制 输出数字 %x 可以以 16 进制 输出数字 案例进阶 —— 使用 Cat 类再创建一个对象 lazy_cat = Cat() lazy_cat.eat() lazy_cat.drink() 提问：tom 和 lazy_cat 是同一个对象吗？ 不是，类可以创建不同对象 方法中的 self 参数 案例改造 —— 给对象增加属性 在Python中，要 给对象设置属性，非常的容易，但是不推荐使用 因为：对象属性的封装应该封装在类的内部 只需要在 类的外部的代码 中直接通过 . 设置一个属性即可 注意：这种方式虽然简单，但是不推荐使用！ tom.name = \"Tom\" ... lazy_cat.name = \"大懒猫\" 使用 self 在方法内部输出每一只猫的名字 由 哪一个对象 调用的方法，方法内的 self 就是 哪一个对象的引用 在类封装的方法内部，self 就表示 当前调用方法的对象自己 调用方法时，程序员不需要传递 self 参数 在方法内部 可以通过 self. 访问对象的属性 也可以通过 self. 调用其他的对象方法 改造代码如下： class Cat: def eat(self): print(\"%s 爱吃鱼\" % self.name) tom = Cat() tom.name = \"Tom\" tom.eat() lazy_cat = Cat() lazy_cat.name = \"大懒猫\" lazy_cat.eat() ￼ 在 类的外部，通过 变量名. 访问对象的 属性和方法 在 类封装的方法中，通过 self. 访问对象的 属性和方法 初始化方法 之前代码存在的问题 —— 在类的外部给对象增加属性 将案例代码进行调整，先调用方法 再设置属性，观察一下执行效果 tom = Cat() tom.drink() tom.eat() tom.name = \"Tom\" print(tom) 程序执行报错如下： AttributeError: 'Cat' object has no attribute 'name' 属性错误：'Cat' 对象没有 'name' 属性 提示 在日常开发中，不推荐在 类的外部 给对象增加属性 如果在运行时，没有找到属性，程序会报错 对象应该包含有哪些属性，应该 封装在类的内部 初始化方法 当使用 类名() 创建对象时，会 自动 执行以下操作： 为对象在内存中 分配空间 —— 创建对象 为对象的属性 设置初始值 —— 初始化方法(init) 这个 初始化方法 就是 __init__ 方法，__init__ 是对象的内置方法 __init__ 方法是 专门 用来定义一个类 具有哪些属性的方法！ 在 Cat 中增加 __init__ 方法，验证该方法在创建对象时会被自动调用 class Cat: \"\"\"这是一个猫类\"\"\" def __init__(self): print(\"初始化方法\") 在初始化方法内部定义属性 在 __init__ 方法内部使用 self.属性名 = 属性的初始值 就可以 定义属性 定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性 class Cat: def __init__(self): print(\"这是一个初始化方法\") # 定义用 Cat 类创建的猫对象都有一个 name 的属性 self.name = \"Tom\" def eat(self): print(\"%s 爱吃鱼\" % self.name) # 使用类名()创建对象的时候，会自动调用初始化方法 __init__ tom = Cat() tom.eat() 改造初始化方法 —— 初始化的同时设置初始值 在开发中，如果希望在 创建对象的同时，就设置对象的属性，可以对 init 方法进行 改造 把希望设置的属性值，定义成 __init__ 方法的参数 在方法内部使用 self.属性 = 形参 接收外部传递的参数 在创建对象时，使用 类名(属性1, 属性2...) 调用 class Cat: def __init__(self, name): print(\"初始化方法 %s\" % name) self.name = name ... tom = Cat(\"Tom\") ... lazy_cat = Cat(\"大懒猫\") ... 内置方法和属性 序号 方法名 类型 作用 01 __del__ 方法 对象被从内存中销毁前，会被 自动 调用 02 __str__ 方法 返回对象的描述信息，print 函数输出使用 __del__ 方法（知道） 在 Python 中 当使用 类名() 创建对象时，为对象 分配完空间后，自动 调用 __init__ 方法 当一个 对象被从内存中销毁 前，会 自动 调用 __del__ 方法 应用场景 __init__ 改造初始化方法，可以让创建对象更加灵活 __del__ 如果希望在对象被销毁前，再做一些事情，可以考虑一下 __del__ 方法 生命周期 一个对象从调用 类名() 创建，生命周期开始 一个对象的 __del__ 方法一旦被调用，生命周期结束 在对象的生命周期内，可以访问对象属性，或者让对象调用方法 class Cat: def __init__(self, new_name): self.name = new_name print(\"%s 来了\" % self.name) def __del__(self): print(\"%s 去了\" % self.name) # tom 是一个全局变量 tom = Cat(\"Tom\") print(tom.name) # del 关键字可以删除一个对象 del tom print(\"-\" * 50) __str__ 方法 在 Python 中，使用 print 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示） 如果在开发中，希望使用 print 输出 对象变量 时，能够打印 自定义的内容，就可以利用 __str__ 这个内置方法了 注意：__str__ 方法必须返回一个字符串 class Cat: def __init__(self, new_name): self.name = new_name print(\"%s 来了\" % self.name) def __del__(self): print(\"%s 去了\" % self.name) def __str__(self): return \"我是小猫：%s\" % self.name tom = Cat(\"Tom\") print(tom) Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"ipo/IPO.html":{"url":"ipo/IPO.html","title":"港股打新","keywords":"","body":"前言 富途收集的打新知识，数据没问题，文字略有夸张，待整理。 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo1.html":{"url":"ipo/ipo1.html","title":"1.为何港股打新","keywords":"","body":"打新秘籍|无脑赚钱利器，港股打新带你穿越牛熊 吹个牛-2万年化70% 从过去三年数据来看，假设开设一个港股账户，投入2万港币本金，平均每年可以通过港股打新获利1.5万港币，平均年化收益达70% 为什么港股能赚钱 「港股打新」是通过参与香港证券交易所新股申购，并利用港交所上市新股申购一手的高中签率政策，从而获得高投资回报的理财策略。港股打新不是稳定盈利，更不是暴利，只是从概率上来讲是能赚钱的。 这个世界上并不存在稳定暴利的投资品种，如果有，参与人数多了就会不断摊薄收益。 但是港股打新一定是能赚钱的，为啥呢？ 因为从逻辑上来讲，公司 IPO 发行新股，一般是要给一二级市场预留一些价差，也就是所谓的「新股红利」，不然吸引不到投资者。而且上市就破发，上市公司脸面上也不太好看。牛牛与牛友们打新赚的，就是这个一二级市场价差的钱。 过去几年以来，无脑一手的玩法很吃香，港股打新也被称为无脑赚钱利器，综合下来年化收益至少是个百分之六七十。 而且，这个策略在2019年，也表现得相当亮眼。 港股打新战绩回顾（补充了热门中概股首日及暗盘涨幅） 截至2020年7月底，年初至今在香港挂牌的上市公司一共有86家，首日上涨比例约为58.14%，首日平均涨幅15.87%，累计一手收益超过9万港元，其中欧康维视、思摩尔国际等明星新股首日涨幅超过150%，沛嘉医疗、康方生物等大肉签一手收益也都在8000港元以上。 2020年上半年，虽然疫情导致资本市场出现空前的巨幅波动，但香港 IPO 发行依旧强劲。 网易（首日5.69%，暗盘7.07%）、京东（首日3.54%，暗盘7.34%）赴港二次上市开启了中概股回归潮。医疗医药、生物科技、TMT 新股不断引发新的打新热潮。 纵观2020年下半年，农夫山泉、百胜集团（首日-5.29%，暗盘-2.91%）、蚂蚁集团来势汹汹，加上预期更多中概股将回港上市，相信下半年港股IPO市场会更加火热，收益率依然稳健。 假如你有两万元 打新 一个账户一般存放的资金在2万元左右即可满足打新的需求，扣除交易费用以及风险损失，真实收益率应该在60%左右，还是非常的诱人了，近几年来港股打新的人也越来越多。 相比于A股来说，港股打新股，门槛极低，不需要市值，有现金就能打。并且，港股则更顾及散户利益，优先保证一户一签，所以按照最低股数只打一手，中签率最高，平均中签率有60%〜70%，平均首曰最高涨幅达到28%。 如果假设每只新股都申购后并且中签，单账户平均一手收益可以为6.8万元；以2万本金乘以一手中签概率大致计算出19年单个账户盈利的平均盈利金额为1.2万元。 2020年第一季度，港股IPO顶着巨大压力，仍保持着平均3.17%的首日涨幅，可以说是穿越牛熊，依然可以盈利 港股恒指 2019年港股恒指整体涨9.07%。不过结构分化严重，消费、医药、科技等行业龙头股表现突出，对牛友们选股以及把握机遇的要求较高。2020年受疫情及美股巨大波动的影响，第一季度，港股恒生指数累计下跌超16%。 基金 数据显示，2019年，股票型、混合型、债券型、货币型四大品种基金平均收益率分别达到 38.47%、32.01%、5.86%、2.54%。在2020年，基金同样也是风险与、收益并存，随着美股一月内多次熔断，全球恐慌情绪蔓延，今年以来基金收益也大幅回落，偏股型权益基金仍需关注风险事件。值得注意的是，主动股票型基金平均收益率-0.50%，并未能够取得正收益。 结语 综合以上几种投资方式的收益和复杂程度来说，打新真的是以最简单的操作博取最高的收益率的投资选择；如果各位牛友可以对新股加以基本的预测和筛选，收益率或许会更上一层。 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo2.html":{"url":"ipo/ipo2.html","title":"2.港股A股对比-中签率收益率","keywords":"","body":"打新秘籍 | 中签率高出两千倍？港股A股打新大不同！ 继年初几大「超购王」席卷港股 IPO 市场之后，近期生物科技股又再次占据了新股市场的头条。随着越来越多国内外优秀的企业，特别是一些独角兽企业和新兴企业在香港上市，股民对于港股打新的热情也有增无减。 不过，你真的了解港股与 A 股的打新规则与技巧吗？快让我们一起来看看吧。 01 港股A股打新大不同 目前，要想在港股市场认购新股，首先必须要有港股的证券账户，但并不要求有持仓，而A股打新则需要现持有一定市值的股票才可操作，沪港通也还没有开通打新的业务。 其次，港股与 A 股的上市制度也有所不同，港股采用了市场化程度较高的成熟证券市场所普遍采用的一种发行监管方式一一注册制，相比 A 股的审批制相对较为宽松，也没有市盈率的要求，因此企业赴港上市的节奏比起也会稍快。 一旦有公司申请在港交所上市，就会把其招股书挂在港交所的披露易页面下，并在招股书中会披露公司主营、财务、募资用途及未来发展、主要股东情况、风险等主要因素 总结起来如上表所示，下面我们重点从牛友们最关心的收益率和中签率两方面，来比较港股A股打新两者究竟有何不同： 02 收益率：港股 众所周知， A 股打新就是另一种形式的「买彩票」，中签后基本会有十个左右的涨停板，与此不同，在港股上市的新股并不能保证上市后一定是上涨的走势，甚至还有破发的风险。 回看 2019 年，香港交易所公开发行的新股共 164 只（包含一只基金），虽然少于 2018 年，但整体数量相比于历史情况还是较多的。 在上市的164只新股中，首日涨幅>= 0 的比例大约是62.80%，过去五年均保持在 60 ％一 80 ％的区间内： 那有些同学就要问了，收益率跟 A 股差那么多，为什么要在港股打新呢？别着急，下面就来说说港股打新的绝对优势一一中签率。 03 收益率：港股>A股 港股市场由于发行制度及发行方式与 A 股有较大的区别，所以在中签率上有较大的差别。 新股发行之前，如果认购的人比较多，将通过抽签决定股票的分配。其中一个重要的概念是一手中签率，即只申购一手的情况下，中签一手的概率。 A 股普遍中签率在 0 . 03 ％左右，但港股实施的是优先保证一户一签的分配政策，尽量每个申购者和散户都能抽到一手，剩余股票再根据递减原则进行分配的公平分配机制，这样的政策也使得港股打新平均中签率在 60 ％以上，是 A股的 2000 倍之多！ 这种机制下在保证了分配相对公平的同时，给了散户投资者更大的参与感，反观 A 股，尽管基本上是中签就有钱赚，但中签的概率实在太低，抽中赚钱的可能性微乎其微。 事实上，从历史的首日涨幅来看，港股打新的收益还是非常可观的，牛牛简单统计了一下，如果 2019 年每只新股都打一手的话，全年收益可以达到接近 70000 港币！ 总的来说 总的来说，港股 IPO 打新相对 A 股会存在更多的机会，港股打新的保证一手中签率原则使得打新更适合小规模资金，因此为了分担风险增加中签率，牛友们采用小资金，每支新股申购一手是个不错的策略哦~ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo3.html":{"url":"ipo/ipo3.html","title":"3.打新流程","keywords":"","body":"打新秘籍 | 从申请认购到打新成功，你需要了解的有这些（流程） 01.开户入金 首先就是选择一家正规持牌香港证券公司了， 由于目前国内并不能通过沪港通参与港股申购，要想参与港股打新必须选择一家在香港拥有证券牌照的证券公司，因为在打新的过程中还存在申购的费率，同时券商不一样，收费标准、孖展不同、暗盘情况以及客户体验也不一 样，下面将结合实际一一讲解各类券商的情况 港股老牌券商，如耀才等，香港本地券商发展业务的模式主要也是依赖经纪人，分散销售。各本地券商的佣金收费此前长期维持高位(一般略低于银行)。此外，老牌港股券商 开户手续还比较繁琐，一般还需进行现场见证，同时其手机客户端使用体验还有待进一步优化。 外资券商，外资券商在香港散户市场所占的份额并不算多，其中最大的辉立成立于新加坡，优势则是可以提供便利广泛的亚洲市场产品(比如其所在的新加坡股票)。但其官方网页和软件界面都是以英文为主，不符合内地投资者的阅读喜欢，操作上也不是很方便。 中资券商，国内主要的中资券商目前已经纷纷入驻香港开拓港股市场，如招商证券、 国泰君安等，截至目前至少已有30家以上中资券商在香港拥有子公司。中资券商开户流程相对复杂，而且费用相对稍高。 互联网券商，近年新兴的互联网券商是由内地民营资本组建，如富途证券。相比于传统券商，互联网券商的经营思维更接近于以用户为中心的模式，坚持去中介，自主交易。互联网券商开户流程比较简单，而且客户端体验比较好。 以去年 IPO 数量为例，平均每周发行新股4支，下半年估计每周新股发行接近5支，假设每只新股平均冻结资金为一周，考虑每只新股只申购1手，全部新股都申购的话需要 36445 = 18220港币。所以牛牛推荐投入本金大概1.5万到2万港币左右（*不靠谱，每只股票最低认购股数及金额不同，加上开户抽奖的奖励，入金至少20000港币，没有香港账户的话美元3000美金）。 02.认购 一般公司正式公布招股书那天，投资者可以认购新股。通常，新股的认购期有三天至一周， 在此期间都可以填写认购申请。我们尽量选择在最后一个认购日再操作，因为这个时候认购的一些数据已经出来了，更容易判断这只票的认购热度（靠谱，虽然有时会提前结束，但是融资认购倍数（仔展倍数）是一个很有用的指标）。 在公司的招股书里，可以大概推算出这只新股大概的市值，根据历史数据，基本上市值小于5亿元的新股破发概率大；大于20亿港币的新股破发概率低。 小于5亿元，这类股票为小盘股，这种股票因为价格低、市值小容易被掌握资金者(如庄家) 操控上市的价格涨幅，若求稳健打新，就应该避免申购这类新股。 大于20亿港币，这类股票为大盘股，通常营业额高、体量越大的公司在上市时市值越高，这类公司通常已有稳健的营收以及成长率，市场基金乐于抬升。 除了现金打新外，还有一种方式叫做孖展打新。 孖展是margin的谐音，就是融资的意思。港股认购，如果现金不足以，可以借钱认购。经常涉及的概念是孖展超购倍数。这里的超购是指融资额超过公开发售集资额的倍数。 开始认购之后，我们就可以在富途牛牛等券商 APP上看到实时孖展情况，如果孖展倍数＜1, 代表目前孖展资金尚未达到上市预计发行的金额，如果最终认购不足，这只新股将会有很大的下跌风险。 如果孖展倍数越高，最后该新股的认购倍数一般也就越高，代表市场资金对该新股的兴趣越高，首日上涨的概率也高。 藉由孖展倍数，可判断新股是否受到市场资金的青睐。而从过去两年的数据分析来看，孖展超购倍数也的确与首日表现有一定的相关性 在孖展打新时，最后一个交易日认购还能少占用券商的资金，支付更少的融资费用，加上上述推荐的大部分券商平台均可接受融资打新服务，同时港股实施的是优先保证一户一签的分配政策，所以每只新股申购一手是性价比比较高的做法。 03.查看中签 港股打新后，一般会在一周内公布是否中签， 中签情况可直接登陆富途牛牛等券商客户端进行查看，如果认购的人比较多，将通过抽签决 定股票的分配，其中一个重要的概念是一手中签率，即只申购一手的情况下，中签一手的概率。 港股为了照顾中小投资者，尽量保证一手中签率，让每个申购的人都尽量有一手。2018年港股 IPO 一手中签率高达61.3%。一般来说，新股质量越高，认购的人越多，中签率就会月低（大家都用另一个指标多少手稳中一手），首日表现越好，抽中赚钱的几率也就越高，但100%中签率的新股首日大涨的几率也相应存在 04.暗盘交易 暗盘交易，就是不通过交易所系统，而是通过某些大型券商自行设立的内部系统进行报价撮合。港股新股暗盘交易时间一般为新股正式上市日前一个交易日下午4时15分至6时30分。 暗盘交易的好处在于，可以进行提前交易买卖。无论是用来提前锁定收益还是止损，亦或新股未中签想再次入场都可以用暗盘来达到投资目的。所以，最好选择有支持暗盘交易的券商。（看数据，对比下暗盘跟首日，得出个结论来） 一般来讲，暗盘的表现对新股上市首日的表现具有一定的指示作用。同向的概率很大。作为 投资者，一定要关注暗盘表现。 05.上市及卖出策略 港股新股，从申购到公布中签到上市，一般经历2周时间（美股短很多），一般上市首日涨幅最大，建议新股上市首日择机卖出，90%的港股新股在第一 天的价钱往往是最高的，赚钱的概率及安全性也是最高，所以与其承受风险，不如第一天就寻求合适的时机卖出，切忌恋战当成炒股。另外可参考暗盘涨幅的1.5~2倍卖出(此策略需同时参看新股的基本面)。 卖出价位我们可以设置相应的止盈区间，若是风险厌恶者可以选择在暗盘时就卖出，赚的概率大而且金额大，亏的概率小而且金额小。对于小白来说，总想追求卖在最高点，并不是一件好事且难以把握。 相对股市而言，港股打新的收益率还是比较乐观的。港股打新也是海外投资的第一步， 有了港股账户不但可以打新，还可以购买腾讯等优秀港股市场股票，迈向资产全球化配 置，早日实现财务自由。 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo4.html":{"url":"ipo/ipo4.html","title":"4.招股书-几个指标","keywords":"","body":"打新秘籍 | 读不懂招股书？看这几个指标就够了 正式的招股书目录，通常多达四五百页，为了「申购or不申购」去通读显然不太现实，尤其是对于毫无财务基础的小白而言，更是难以下手，这么多信息，怎么看呢？ 今天牛牛就教大家快速读懂招股书，从三个方面共10点来了解公司业务现状和未来发展前景，并抓住打新重点指标保荐人、绿鞋、基石、投资等。 01 招 股 书 是 什 么 招股书，又称招股说明书或公开说明书，是股份有限公司在发行股票时，就发行中的有关事项向公众作出披露，并向非特定投资人提出购买或销售其股票的要约邀请性文件。 首先，每家券商在新股简介以及招股书的概要部分里都会整理出新股最基本的信息，像招股日期、截止日、中签日（暗盘）、发行价格区间、发售数量、市值等等。 我们从这个简况中就能获取很多信息，以美团为例。 此外，市值可以表明公司的体量。一般市值小于6亿的新股，首日表现优于市值大的股票（这里与上篇冲突）入场费低，相对容易炒作。 绿鞋，也称绿鞋机制或绿鞋期权，是首次公开募股（IPO）招股说明书中的一项特殊条款，指允许承销商向投资者出售比发行人原计划更多的股票，在法律上被称为「超额配售权」。 在招股说明书中，绿鞋机制允许承销商以发行价在注册制证券发行中卖空股票。绿鞋机制的操作范围不尽相同，但通常不会超过原始发行量的15％，这保障了公开发行的稳定性和流动性。 下面我们将从基本面和 IPO 流程信息两个方面来判断一家公司上市的风险和前景。 02 基本面 历史、重组及企业架构 该部分会写公司历史上的重要里程碑事件，公司在一级市场的融资情况，很多公司在上市之前给媒体吹风说融了多少多少钱，有没有水分这这个区域都会露出马脚，可以此检验公司的诚信度。该部分包括公司重组后的股权架构。 业务及财务资料 该部分有部分内容与概要部分重合，业务部分详细介绍了公司的主营业务状况，投资者利用业务数据，可以判断公司主营业务前景。 财务数据，包括利润表、资产负债表和现金流量表，先看看3年内的营收和利润增速，如果增速高且属于稳定增长，会让市场安心不少，如果属于一年不如一年，或者3年内没什么增长，这类公司估值就很低。 业务数据与财务数据不同，财务数据是业务运行的结果，根据业务数据是要判断公司的增长前景。另外，对于朱盈利的公司，在港股也处于被质疑状态，从2017年开始，大量未有盈利的独角兽公司在港股挂牌，上市后多数表现不佳。 风险因素 风险因素，说的是公司会面临哪些风险。有业务上的风险，也有监管方面的风险，还有来自公司本身的一个风险，比如说人员不稳定或者资金来源等。 「风险因素」部分给投资者展示的是上市公司可能面临的风险，可以理解为上市公司可能存在的瑕疵，对于投资者而言，在为上市公司靓丽业绩激动万分之时，适时阅读一下风险因素降降温，百利而无一害，有利于投资者全面了解上市公司。 行业概览 要全面了解一家上市公司，可以从阅读概要开始。概要是缩减版的公司业务情况、风险因素、财务数据、控股股东、募集资金用途等介绍，如果没有时间去细看招股书的话，把概要看完就差不多了。 对于打新投资者而言，更应关注公司的主营业务。 我们首先需要了解的是公司是干什么的？提供什么样的产品和服务。从产品或服务，可以大概构造出一个产品干什么用，大概会有多大空间。以美团为例，针对消费者，美团提供吃、住、行、游、购物及娱乐等多种服务，针对商家，美团点评提供多种解决方案使其运营数字化，属于快速发展的产业，有着不错的前景。 03 IPO流程信息 保荐人 保荐人，类似上市推荐人，从公司计划上市一直陪伴至公司上市，帮助拟上市公司撰写招股书，向港交所提交申请版本招股书，答复港交所的问询，是决定公司能否顺利上市的关键。牛友可以在阿思达克官网找到保荐人比较，查看他们的新股保荐战绩。 董事及参与全球发售的各方关系 该部分是拟上市公司的董事会成员名单和简介，一般来说，豪华的董事会会加强投资者的信心，尤其是董事会成员有香港本地的知名人士或太平绅士。该目录下还包括公司聘请的会计师事务所和律师事务所，聘请全球四大会计师事务所（普华永道、德勤、安永和毕马威）更容易加强投资者信心。 上市公司与控股股东的关系部分会阐述双方如何处理关联交易，关联交易的定价是否公平，对于关联交易比较多的上市公司，投资者应该提高警惕。 股本 可以查阅公司发行后总股本，根据总股本情况，结合公司的最近一年的净利润，可以计算公司的每股收益，并根据发行价计算公司的发行市盈率和发行市净率，根据这些基本估值数据，可以与同行业公司进行比较，以对公司的发行定价是否昂贵做出基本判断。 基石投资者 该部分并非所有的拟上市公司均有，只有上市前引入基石投资者的公司才会公布，一般大型的 IPO 都会引入基石投资者，基石投资者有所定期，一般为6个月，明星级别的基石投资者可以吸引散户认购。 出现基石投资一般有2种可能。 第一种：新股实在糟糕，需要基石投资保驾护航，吸引其他投资者前来认购，才能顺利完成 IPO 发行。 第二种：新股确实有前景，基石投资者为了争取到一定新股配售股份，争先恐后抢当基石投资。 所以不要认为有基石的新股就一定是好股，还是要综合考虑哦~ 全球发售的架构 该部分主要讲述公司本次发行上市的相关安排，包括发行价区间，还包括新股申购的回拨机制。香港新股一般会分为国际配售和公开发售两部分，90％的股票国际配售配发，另外的10％就是公开发售，给所有投资者去认购，主要是散户投资者。 按照港交所的发行规则，当散户超额认购达到一定倍数，国际发售部分要向公开发售部分回拨。 结语 讲了这么多，不知道各位牛友们是不是已经被绕晕了呢~ 关于招股书的重点就讲完啦，读招股书不但利于打新选股，还能迅速丰富你的商业知识库，积累硬核知识点，让大家在投资路上越走越顺。 不过理论要结合实践，打新也是实践出真知，多翻看一些招股书，多一些自己的理解，这样投资之路才能越走越好！ 最后，祝大家好运，理性选股，打中牛股！ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo5.html":{"url":"ipo/ipo5.html","title":"5.分析认购结果，洞悉上市走势","keywords":"","body":"打新秘籍 | 看懂认购结果，提前洞悉上市走势 01 公布配售结果及中签率 申购结束后，大约有7个工作日的冻资时间。 申购完之后，牛友们比较期待的首先就是中签结果了。在A股，中签靠人品，中签率平均在0.05％左右；然而在港股，中签率是偏向散户的，申购资金越大，中签率越低。 认购结果一般会于公布售股结果日期当天21:00之后公布，如中签，您可以登录港交所网站或券商 APP，在自己的持仓内查看所获得分配新股的股数，同时您亦可通过系统消息、短信、邮件的方式收到中签通知，当日日结单中也会显示中签新股及股数。 进入2020年，港股|PO市场的大热门当属生物科技股，以表现最好的康方生物为例，下 图为配售结果简表： 02 配售结果（重新研究） 配售结果，包括中签率、最终定价和超额认购倍数，中签率代表中签的可能性，超额认购倍数反映新股的受欢迎程度，一般这个数字越大，市场关注度越高，可能会暴涨。 配售包括国际配售和公开发售，其中，国际配售面向来自全球实力雄厚的投资者，通常是机构投资者及专业投资者，认购资金非常的庞大，可以大批进货。这需要资产值3000万港币以上，或者有800万投资组合的客户，主要是机构投资者。公开发售才是针对普通散户的发售，根据客户资产数额大小，参与公开发售的投资者还被分为甲组（认购额小于500万）和乙组（认购额大于500万）。 牛友们可以先看公开配售（散户认购）结果，包括认购人数，不同认购股数，对应的中签率。一般大家比较关心的是一手中签率。通常来说，中签率越低，上市后该股票上涨的可能性越大。 一手中签率准确的说就是指，在所有申购一手的客户里面，被抽中获配1手的概率 例子，一共有132798个有效账户参与申购了诺诚健华，其中54920个有效账户只申购了1手（其他的都申购了两手或更多）。这54920个有效账户（通常被称为一手党，因为只申购了一手）中，共有13730个幸运账户中签，所以一手中签率就是13730除以54920也就是25% 一手中签率很好理解，我们以近期大热的康方生物为例：85593份申请中有10271份可获发1000股股份（也就是1手），中签的概率约等于12％。所以一手中签率就是12％。 稳中一手（下图没理解，也不知道从哪能看到）所需的手数又该如何理解呢？让我们把目光聚焦到下面这张图~ 2401份申请（每份都申购了100手）每份可获发100，000股股份。再往下看，凡是申购超过了100手的，在稳获1手的基础上，均有一定概率还能获发额外的股份。直白地说，稳中一手所需的手数就是为了获发至少1手股份需要申购手数的最小值。这个数字也间接反映了新股的申购热度和中签难度。 此外，关注国际配售（机构大户认购）结果，包括大户认购数目和对应认购股份比例、认购倍数等。大户认购是否火热，可以作为预判新股涨跌的一个因素。 在港市，一般国际配售占比都在90％，公开发售占比是10％。公开发售的认购程度反映了散户在总体发行量中的占比，进而预估新股上市后的流动性和受欢迎程度。 国际配售的基准目的是巩固股东基础，使公司及股东整体获益，国际配售能拿多少股份拼的是背景、规模、投资态度及策略等。不仅是公开配售，国际配售的结果也会一定程度上影响新股的上市表现，比如有消息称，阿里巴巴国际配售超购逾3倍，就说明阿里这次上市获得了较多机构的认可，对于上市表现来说是利好的。 相反，即便公开发售足额但国际配售不足额，上市也有概率会破发。比如啤酒巨头百威亚太的IPO过程中，公开发售也获得非常大的超购幅度，但最后由于国际配售不足额，硬生生地推迟上市日期，可见国际配售中机构投资者的眼光是非常具有借鉴意义的。 了解国际配售和公开发售的区别，才能明白配售结果所传达的信息，从而形成更加客观的预期，最终尝到打新的甜头。 超额认购倍数就是指证券市场发行股票或债券时投资者实际参与购买该公司的股票或债券金额与预先确定发行金额的比率，一般来说，超购倍数越高，所反应的投资者越看好该只股票，后期看涨的概率越高。 由于超额认购倍数的存在，公开发售和国际配售之间存在回拨机制，比如公开发售的购额不足，可能将剩余的股份拨给国际配售部分。相反，如果国际配售认购金额不足，则更可能要延迟上市。一般新股上市网上公开发售占总发行股份的10％，当新股超额申购倍数达到一定的倍数，就会相应地从国际配售中回拨回来，具体比例为： 如超额申购倍数小于巧，则公开发售不变，为10％； 如超额申购倍数为50倍，回拨调整后公开发售调整为30％； 如超额申购倍数为50一100倍，回拨调整后公开发售调整为40％ 如超额申购倍数大于100倍，回拨调整后公开发售调整为50％ 例如，康方生物作为热门新股，香港公开发售部分录得超额认购约639倍，由于香港开发售的超额认购多于100倍，故启动回拨机制，将公开发售比例增至约50％。 虽然超额申购倍数大了，意味着申购的人多了，竟争大了，但是相应的可申购的总额也多了。超额认购倍数越大，新股上市表现越好。这个很好理解，超额申购倍数越大的，自然说明市场热度大，供不应求，上市首日表现自然就更好。但是对于非热门股，超额认购却意味着供大于求，有破发的风险。 03申购门槛 入场费+手续费+孖展利息（如有） 入场费：申购一手新股所需费用，入场费=(1+1.0077％)*一手股数*申购价上限； 注：入场费中包含的「1.0077％*一手股数*申购价上限」的费用，在没有中签的情况下，该笔费用将退还。（1.0077％为：1％的经纪佣金+0·0027％证监会征费+0·005％联交所交易费） 手续费：申购过程中券商收取的费用;(富途 港股普通认购手续费50，银行融资认购手续费100) 孖展：即杠杆，如果打新资金不够可以向券商借钱，例如，你有1万的资金，打算放9倍的孑子展，那你的总金额变成10万，券商借给你了9万。 总结 总而言之，在获得申购结果后，合理分析中签率，超额认购倍数等因素，可以帮助我们一定程度上预知暗盘以及开市后的股价走势，从而更好地收割打新效益~ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo6.html":{"url":"ipo/ipo6.html","title":"6.暗盘交易","keywords":"","body":"打新秘籍 | 抢先一步锁定收益，别错过暗盘交易这个投资利器！ 暗盘交易，并非像听上去是\"地下交易\"那样的黑话，而是港股市场特有的一种交易方 式，又称场外交易，是指没有通过港交所交易系统的撮合直接在某些大型券商内部系 统实现报价撮合的交易。 暗盘交易一旦有买家在场外报出愿意买的价格和数量，不管是否有卖家卖出，都成为暗 盘价格。一般新股上市前，可以通过暗盘价格知道新股火爆程度。由于沪港通禁止暗盘 交易，A股没有新股暗盘交易制度，市面上提供暗盘功能的券商屈指可数，通常暗盘交 易发生在新股上市前一日收盘后16:15-18:30。 01 暗盘交易的门槛 暗盘交易属于场外交易，是券商通过各自的交易系统，为意向买卖的投资者提供了一个 交易的平台，此时券商扮演了「中介机构」角色，所有的报价仅适用于该券商内部交易 系统，和其它同样提供暗盘交易的券商的成交价存在差异。 哪些新股有暗盘？ 不是所有港股上市的新股都有暗盘，通常只有在香港主板上市的新股才有，创业板上市的股票由于风险较高，很少有券商愿意接入暗盘交易，此外，配售上市和介绍上市的股票是没有暗盘交易的。 主板上市的新股，认购倍数越高，暗盘成交可能性越大。有意向参与暗盘交易的投资者，可以在新股上市前一日，登入提供暗盘交易功能的券商交易系统，在新股认购界面查看相关新股是否有暗盘。 参加暗盘交易需满足什么条件？ 暗盘交易虽然没有持仓或者入金门槛，但投资者如果想要参与暗盘交易，需找到一家提供暗盘交易功能的券商，开通港股账户，如果相关新股有暗盘，那么投资者便可以通过APP或电话参与暗盘交易。无法提供暗盘交易的券商港股账户，只能参与已上市新股买卖，是无法参与暗盘交易的。 暗盘交易的费用？ 暗盘交易费用和港股正股交易费用类似，通常包括交易佣金、平台使用费、交易印花税、交易费、交易征费、交收费。其中差别最大的是交易佣金，传统券商的交易佣金通常在千分之几，每笔交易费用最高可收150港元。 现今快速成长的互联网券商，通过技术创新极大降低了运营成本，暗盘交易佣金和港股正股交易佣金一致，每笔最低收费仅3港元左右。 02 暗盘交易的优势？ 快人一步，买入新股：参与港股打新朱中签的用户，可通过暗盘交易于上市前买入该股票。 锁定收益，及时止损：若新股暗盘表现较好，可提前卖出获利，若新股暗盘表现较差，则可降低持股，提前卖出，及时止损。 为新股走势，提供参考：暗盘的涨跌表现，从一定程度来说，体现了新股的受追捧度，不过暗盘未能表现整个市场的需要，因为暗盘表现只反映新股于该证券商的买卖表现。 例如，2019年港股 IPO 暗盘收盘涨幅平均值为12.93％，而首日收盘涨幅平均值为8.42％。可以看出，新股暗盘的表现情况可为新股上市后的走势提供参考，甚至暗盘出手似乎是更好的选择。 03 暗盘交易注意事项 暗盘交易使用暗盘限价单，该类型的订单仅在暗盘交易时间段展示，其他时间段隐 藏； 暗盘交易不可改单，如需变动订单，可先撤单再下单； 暗盘价对新股上市首日的价格走势有一定程度的影响，但因其买卖只限于券商内部，且未能全面反映市场需求，因此不宜以暗盘价视作该新股走势的重要指标。 暗盘交易作为股票上市前的风向标，对于指导牛友们出手投资可以说是意义非凡。把握好暗盘，可以探知开市行情，控制风险，进一步扩大打新收益，还不快快行动起来！ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo7.html":{"url":"ipo/ipo7.html","title":"7.简单选股策略","keywords":"","body":"打新秘籍 | 每年百余IPO，一眼锁定翻倍的那只！ 2019年港股 IPO 的市场概况 我们基本上可以确定，不管选股标准为何，就算你每一个新股都打，港股打新的长期收 益率也是正的。 那么，还有什么方式可以进一步优化港股打新的收益率？ 答案是： 在选股时期，利用香港上市公司的公开招股书以及保荐人、绿鞋机制等更进一步去挑选出那些上涨概率大的股票，同时剔除那些资质不好，想圈钱就走的烂股。在认购截至后，通过超额认购倍数来判断是否进行暗盘入场。 在市场分化的情况下，闭眼每只新股都打一手的策略已经不太灵了。所以我们需要更聪明的选股策略。 也就是，一眼锁定为数不多的潜力股，出手快准狠。 当然如何选新股是个动态博弈的过程，有很多不确定因素，是个概率问题。牛友们能做的，就是通过研究和观察，努力提高赚钱的概率。 影响一个新股开盘走势的有很多因素，牛牛通过一张图来总结了几个对新股来说影响最 大的因素： 01 公司质地 市值 基本上市值小于5亿元的新股破发概率大；大于20亿港币的新股破发概率低。 小于5亿元，这类股票为小盘股，这种股票因为价格低、市值小容易被掌握资金者（如庄家）操控上市的价格涨幅，若求稳健打新，就应该避免申购这类新股。 大于20亿港币，这类股票为大盘股，通常营业额高、体量越大的公司在上市时市值越高，这类公司通常已有稳健的营收以及成长率，市场基金乐于抬升。 行业前景 行业前景我们可以通过公司招股书来判断发展情况、未来前景等，另一个是看公司是什 么行业。 例如，港股打新目前最受欢迎的行业是医药和物业股，例如今年以来，科技医疗领域的康方生物和沛嘉医疗都在 IPO 频传佳讯，暗盘成交额更是以1.61亿和1.14亿港元分列历史第一和第四。今日，物业股建业新生活也以首日高开22.92％成为热门新股。 通过对行业前景的预测和同类型新股的过往表现，牛友们也可以判断即将上市的公司的市场预期，提高大众牛股的概率。 02 保荐人与基石投资者 保荐人 保荐人是指企业上市的推荐人，主要做保荐工作和上市辅导工作，向证监会申报等，赚取发行人的发行费用。 港股的新股发行跟A股是完全不同的体系，更加成熟和市场化，非常考验保荐人的功力。 同时由于充分市场化竞争产生的差异化，导致了每个券商都有自己独特的深耕领域。 小市值新股，丰盛融资和汇富融资相对不错。中大型新股，建银国际和摩根士丹利不错。中金和中信里昂，则是出了名的护盘不积极思想有问题。 基石投资者 基石投资者主要指一流的机构投资者、大型企业集团、以及知名富豪或其所属企业，可以给标的上市起背书的作用。 基石投资者在国际配售中一般会认购较大份额的新股，并且需要承诺上市后锁定6到12个月，同时在招股书中公开披露。能当基石投资者基本都是声名远播的大机构，所以如果基石投资者一看就阵容豪华，那是可以给股票加分的「意见领袖」 03 超额认购倍数 超额认购倍数很好理解，指的是新股发行时，买新股的金额和要发行金额的比值。简单理解就是，有10个牛友都来拜师牛牛，但牛牛最后只能忍痛收一名徒弟，这样牛友对牛牛的超额认购倍数就是十倍~ 超额认购倍数一般可以反映市场对公司的认可程度及资金追逐程度。怎么看这个数据？以刚结束认购的沛嘉医疗一B为例，在富途 app 上点开可以看到： 这个公司只需要募集2.34亿的资金，结果全市场融资认购额是995.63亿，超额倍数是425倍，我们可以感受一下大家对于好公司的追捧有多狂热，预示着有很大的可能在暗盘以及正式上市后上涨。 如果判断新股能不能打，只看一个指标，那么看这个就够了。因为这个指标是市场上的投资者综合了所有信息，最后得出来的一个结果 牛牛通过统计2019年港股 IPO 的认购倍数与它们的首日表现，也得出了这样的结论： 如果认购倍数越高，代表市场资金对该新股的兴趣越高，首日上涨的概率也高。 认购倍数与首日表现 最后，对于港股选股还是要纵隔多方面的因素去综合判断，除了上面牛牛提到的方面，牛友们还可以关注同类行业新股的过往表现，中签率，上市前的新闻消息以及大盘行情等等、经过牛友们聪明地判断，大家一定都可以选到心仪的牛股！ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo8.html":{"url":"ipo/ipo8.html","title":"8.孖展（融资认购）顶头槌","keywords":"","body":"打新秘籍 | 热门新股100%中签？孖展顶头槌了解一下 在香港媒体的新闻中，我们经常会听到大款「顶头槌」「孖展」认购新股的报道，究竟什么是顶头槌？怎样运用孖展？为什么有人要这样投单？个中精妙就涉及到打新的机制和大单认购新股赚钱概率。 香港是用「认购愈多，分配愈多」的机制，若要提高中签率，最简单粗暴的办法就是增加资金。巧妙掌握孖展和顶头槌，牛牛助你打新100％、 01 活用孖展抽新股 「孖展」一词来自香港，英文为Margin，即保证金的意思。在香港市场上，银行和证券公司一般向投资者提供融资服务。 开设了「孖展账户」的投资者，在进行股票买卖时，可利用他们提供的融资额进行杠杆投资，放大收益，一般情况下，证券行或银行向投资者提供这种服务会收取一定的利息。 若新股「僧多粥少」，每名散户能供抽中的机会便会降低，故不少散户都会向银行或券商借孖展入飞，以增加抽中新股的机会。 针对拟上市的新股，各券商会依据自身对新股的风险评估，决定能借给客户用于购买股票的额度，一般最大杠杆倍数不超过9倍。即，牛牛账户内若有10000港币，最多可融资认购100000港币的新股，其中90000港元为融资金额（孖展），融资额度翻倍，自然打到新股的概率也大大提升。 孖展杠杆效应可使回报率大增 （为方便计算，上述例子未计算股息回报、抒息利息、交易手续费等。） 假设投资者拥有10万元现金，买入100股市值100元的股票，若股价其后升至150元，即股票市值升至15万元，投资者获利50％。 在股票升值时，借孖展能产生杠杆效应，使投资者享受本小利大的成果。用相同例子，这位手持10万元现金的投资者的孑子展比率是50％，他最多可买入20万元股票[10万元/ （100％一孖展比率50％）]。 股票升值50％后，市值达30万元，在偿还贷款后，投资者获利达100％。当然，投资者还要支付孖展利息，原则上只要股价升幅高于于借贷及交易成本，就能赚钱。 相反，在股票价格下跌时，借孖展的股民损失也会更加惨重。假设投资者用10万元现金买股票，股票市值跌至5万元时，他将损失50％，但若然是透过孖展贷款，把投资额倍增至20万元，股票贬值50％后，他将损失100％本金。 不管是在新股认购开始后第几天申购，融资利息都从认购截止日开始计算，至公布结果日停止计算。假设，利率为2％，认购截止日为11月4日，11月12日上市，11月11日公布结果，则利息从11月4日开始算，融资金共占用8天，应付利息=90000*2%*8/365。 不少股市小白对于「孖展」这个字眼可能有点恐惧，总觉得属于「高杠杆、高风险」的操作手法，不敢轻易采用。其实，这是混淆了「借孖展抽新股」和「借孖展炒股」两个概念。前者虽然有一定的风险，但对于有经验的投资者而言，却是经常用到的投资技巧，只要用得其所，就能大大增加成功认购新股的机会。 02 顶头槌 是否 Too Good To Be True? 港股的「顶头槌」当然和足球没有关系。其意思是抽新股时，决定下重注以「新股发行股数上限」认购。上限的计算公式是公开发售数目（未计算回拨）的一半。 举个例子，A企业总发行1亿股，90％拨到国际配售，10％作为公开发售，投资者最多可以认购公开发售1000万股中的一半，500万股。另一方面，认购新股时公开发售的股份一般会分甲、乙两组，乙组主要是机构和高净值客户，而「顶头槌」会被归纳到乙组认购最多股份人士。 认购顶头槌所需资金规模有大有小（认购金额：申购价上限*认购股数）。少的只要五百多万，多的需要十数亿的资金，比如小米，申购顶头槌需要12亿，马爸爸可能一时都拿不出来这么多现金来。 对一般投资者来说，只需要留意：顶头槌的申购数量通常反映了新股的热度。 以上月大热的康方生物为例，康方乙组大军7624人，顶头槌250张；顶头槌一张申购金额1.3亿元，以10倍杠杆、2.88％的利率收费计，融资成本5.54万。由于顶头槌中签25手，中签资金40.45万，融资成本占比13.69％，康方至少涨幅在13.69％以上可以保本，而最终康方生物首日高开45％，也是令投资者收获颇丰。 诚然，「顶头槌」的年化回报相当丰厚，但这仅是理论收益。毕竟投资者不可能每一新股都恰好有那么多的闲置资金，中签后这么巧在最高价出掉（当然也有可能持有时间更长收益更高）。 考虑交易佣金和印花税等费用，实际的回报也会打上折扣。更重要的是，资金运用上如何调动，都需要投资者根据实际情况具体分析。 结语 所有资金都只用来打新虽然并非不可，但略微会显得「剑走偏锋」。投资而言，认真研究基本面，挖掘企业的合理价值才是正道。如果投资者认可某一家公司，那么「顶头槌」和「孖展」或许能为大家提供多一条投资的渠道和方法，结合其他投资策略融会贯通，方能进退有余，博取最大收益。 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"ipo/ipo9.html":{"url":"ipo/ipo9.html","title":"9.卖出时机，破发抄底","keywords":"","body":"打新秘籍 | 暗盘卖还是首日卖？破发抄底可取吗？ 当我们申购新股中签时，该在何时卖出呢？俗话说「会买的是徒弟，会卖的才是师傅」。今天牛牛带大家了解港股打新的卖出时机，以及破发股的利与弊，帮助大家锁定收益！ 01 暗盘卖还是首日卖？卖出时机因“股\"而异 暗盘是港股独有的交易机制，在新股上市前一天交易，不通过交易系统，而是通过券商内部系统进行报价撮合的交易。 我们可以在暗盘像正常交易股票一样，进行买入或者卖出。 首先是做好交易前心理准备，一般中签公布后，可以根据总体中签情况、定价范围等预测暗盘和首日的涨跌幅。 比如认购一般，散户中签居多，且上限定价，这样首日预期抛压较大，可能会比较为危险。 如果你是一个什么都不懂的小白，不妨选择在暗盘开始的前三分钟卖出吧，这样可以锁定大部分收益！ 从2020年第一季度的打新回顾来看，平均暗盘最高价要高于首日上市的最高价，在开盘45.95％的上涨率来看，暗盘卖出或许是更加稳健的选择。 如果你已经对港股打新比较熟悉了，还可以选择一些高阶的玩法。我把大盘股和小盘股的卖出策略单独分开。 对于小盘股，在暗盘卖出有更大的机率锁定收益。对于庄家看好的股票，很可能会在暗盘拉高出货，这时候跟随主力的步伐，卖出止盈是个不错的选择。 对于暗盘大幅低开或小幅低开并加速下探，建议盘中反弹卖出，低开证明市场不看好这只股票，下跌只会带来更多的人抛售股票。暗盘低开的股票首日往往也会低开，幅度还会比暗盘大。 所以暗盘低开千万别舍不得割肉，上市首日的跌幅往往更严重。 对于大盘股，大家都对它有种莫名的好感。大盘股除了有业绩、基本面的支撑，往往还会找一些知名的保荐人来保驾护航，大盘股可以讲故事、谈情怀、聊理想，市场就喜欢有故事的公司。 所以对于经营稳定的大盘股，基本上不会有大幅的下跌。尤其是对于有绿鞋的大盘股，暗盘破发，首日60％的概率还是会破发，但是有很大概率可以在发行价卖出。 所以大盘股暗盘下跌，不妨等一等，等股价反弹到发行价附近卖出，如果没有反弹到发行价，则在首日收盘价止损卖出。如果暗盘上涨，你又十分看好这家公司，也可以等到上市首日选择一个高位卖出。 另外，打新不是炒新，牛牛不建议新手持有新股太长时间，一定在上市首日收盘前卖出。对于90％的公司，上市首日的价格就是他历史的最高位。 在牛牛看来，港股新股最佳卖出时机是：暗盘卖出>首日开盘卖出>首日收盘卖出。对于小盘股在暗盘卖出是一个不错的选择，大盘股可以根据具体情况选择在暗盘或者在上市首日卖出。 设置好止盈止损策略，如果你的目标就是盈利+50％，那涨到+50％卖出即可，不要幻想可以卖在最高点，只赚最有把握的钱；也不要因为下跌就舍不得卖，最终变成了股东。盈利亏损都是正常的事，走的时候一定要坚决，宁可错过大涨，也千万别被套牢。 02 破发抄底需谨慎 破发股就是股价跌破发行价的股票。一级市场，通常也叫做发行市场。二级市场通常也叫做交易市场。股票的发行价即是一级市场的认购价。当二级市场低迷时，股价有可能会跌到发行价以下，即破发。 破发抄底可行么 从目前的股市行情来看，股票如果破发很大的程度上是因为投资者受市场的下挫影响，加剧了投资者的恐慌性抛盘，对于遇到这样的个股，投资者们应该看整个基本面是不是发生一个逆向转变，不要过于盲目的抛售或者说进行所谓的抄底。 都说风险是涨出来的，机会是跌出来的，考虑到港股目前整体估值正处于历史较低位，吸引了机构资金的大量涌入。 市场不少投资者看好破发被低估的港股，但要在上百只鱼龙混杂的各色港股中选出合适和靠谱的品种，并不是一件容易的事。对急于上车抄底港股的广大投资者来说，应该如何投资，该选大盘？选龙头？选中小？还是选被打压较惨的香港本地股？ 破发抄底需谨慎，香港上市的内资股，基本不受香港政治风波冲击，而且普遍比内地上市公司估值低，相对内地市场，有更大的上升空间。 随着中资在港股定价权的增强，未来港股的投资收益更加可期。可以重点关注互联网新经济，伴随着90后的消费能力和话语权的增长，包括阿里、美团、小米等一大批优秀的内地互联网公司增长潜力巨大，并且近来京东、网易等中概股回流也掀起了一波热潮。 不过归根结底，我们买股票还是要对这家公司不仅从指标上多做分析，也要结合公司的整体基本情况。在进行股票交易时候要择时交易，顺势而为。 能否买入低价股做长线持有 现在很多投资者都在问牛牛，2元左右的低价股能不能买。实际上，破发抄底也是有学问的，需要从这里面进行筛选，这也是需要一定的时间的。 上市公司基本面良好，历史盈利记录稳定，保持正常经营，没有退市风险的2元左右低价股，继续下跌的空间有限，对于喜欢长线持股，拥有穿越牛熊能力和偏爱低价股的股民来说，确实是以低价买入分批建仓，开始中长线布局的好时机。 从历次牛熊的角度看，不管是股指出不出现「牛市」，只要是阶段性股指出现上涨，那么价值股类型的上市公司均会出现上涨。牛牛总结了价值股的优势： 上市公司具有稳定的业绩增长； 股票价格有着明显的稳定向上性； 就算股票价格出现了阶段下跌，未来只要主营业务不出现大问题，朱来股票价格 能大概率补涨回来； 有较高的股息分红。 如果破发股满足上面的特质，那么跌下来的是价值，越跌越买也要注重策略。 价值投资中选择的价值股，并不是一直的上涨，它也会出现下跌。那么，就越跌越买吗？牛牛认为，普通投资者的投资情绪存在波动，如果全仓去投资价值股，可能实现的盈利性会大一些。但是，也存在阶段性的下跌，而短线具有不可预测性。所以，这种情况也是需要规避的。 那么，在面对下跌，以定投的方式执行更为合适。很多投资者看到的是定投的盈利性不能最大化，却没有看到定投的优势：一则是股票价格出现了下跌有着持续的资金定投，还能在下跌的过程中摊低成本；二则是股票价格出现了上涨也能不踏空。可以说是一举两得的方式方法。 投资是一件需要长期坚持的事情，财富也是需要慢慢积累的，放平心态，不浮躁，前面的路还很长。 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 15:03:53 "},"python/01/intro.html":{"url":"python/01/intro.html","title":"linux基础","keywords":"","body":"linux基础 自学使用-黑马培训班上海37期 Python 侵删 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/vi编辑器.html":{"url":"python/01/vi编辑器.html","title":"vi编辑器","keywords":"","body":"vi 编辑器 目标 vi 简介 打开和新建文件 三种工作模式 常用命令 分屏命令 常用命令速查图 01. vi 简介 1.1 学习 vi 的目的 在工作中，要对 服务器 上的文件进行 简单 的修改，可以使用 ssh 远程登录到服务器上，并且使用 vi 进行快速的编辑即可 常见需要修改的文件包括： 源程序 配置文件，例如 ssh 的配置文件 ~/.ssh/config 在没有图形界面的环境下，要编辑文件，vi 是最佳选择！ 每一个要使用 Linux 的程序员，都应该或多或少的学习一些 vi 的常用命令 1.2 vi 和 vim 在很多 Linux 发行版中，直接把 vi 做成 vim 的软连接 vi vi 是 Visual interface 的简称，是 Linux 中 最经典 的文本编辑器 vi 的核心设计思想 —— 让程序员的手指始终保持在键盘的核心区域，就能完成所有的编辑操作 vi 的特点： 没有图形界面 的 功能强大 的编辑器 只能是编辑 文本内容，不能对字体、段落进行排版 不支持鼠标操作 没有菜单 只有命令 vi 编辑器在 系统管理、服务器管理 编辑文件时，其功能永远不是图形界面的编辑器能比拟的 vim vim = vi improved vim 是从 vi 发展出来的一个文本编辑器，支持 代码补全、编译 及 错误跳转 等方便编程的功能特别丰富，在程序员中被广泛使用，被称为 编辑器之神 查询软连接命令（知道） 在很多 Linux 发行版中直接把 vi 做成 vim 的软连接 # 查找 vi 的运行文件 $ which vi $ ls -l /usr/bin/vi $ ls -l /etc/alternatives/vi $ ls -l /usr/bin/vim.basic # 查找 vim 的运行文件 $ which vim $ ls -l /usr/bin/vim $ ls -l /etc/alternatives/vim $ ls -l /usr/bin/vim.basic 02. 打开和新建文件 在终端中输入 vi 在后面跟上文件名 即可 $ vi 文件名 如果文件已经存在，会直接打开该文件 如果文件不存在，会新建一个文件 2.1 打开文件并且定位行 在日常工作中，有可能会遇到 打开一个文件，并定位到指定行 的情况 例如：在开发时，知道某一行代码有错误，可以 快速定位 到出错代码的位置 这个时候，可以使用以下命令打开文件 $ vi 文件名 +行数 提示：如果只带上 + 而不指定行号，会直接定位到文件末尾 2.2 异常处理 如果 vi 异常退出，在磁盘上可能会保存有 交换文件 下次再使用 vi 编辑该文件时，会看到以下屏幕信息，按下字母 d 可以 删除交换文件 即可 提示：按下键盘时，注意关闭输入法 03. 三种工作模式 vi 有三种基本工作模式： 命令模式 打开文件首先进入命令模式，是使用 vi 的 入口 通过 命令 对文件进行常规的编辑操作，例如：定位、翻页、复制、粘贴、删除…… 在其他图形编辑器下，通过 快捷键 或者 鼠标 实现的操作，都在 命令模式 下实现 末行模式 —— 执行 保存、退出 等操作 要退出 vi 返回到控制台，需要在末行模式下输入命令 末行模式 是 vi 的 出口 编辑模式 —— 正常的编辑文字 提示：在 Touch Bar 的 Mac 电脑上 ，按 ESC 不方便，可以使用 CTRL + [ 替代 末行模式命令 命令 英文 功能 w write 保存 q quit 退出，如果没有保存，不允许退出 q! quit 强行退出，不保存退出 wq write & quit 保存并退出 x 保存并退出 04. 常用命令 命令线路图 重复次数 在命令模式下，先输入一个数字，再跟上一个命令，可以让该命令 重复执行指定次数 移动和选择（多练） vi 之所以快，关键在于 能够快速定位到要编辑的代码行 移动命令 能够 和 编辑操作 命令 组合使用 编辑操作 删除、复制、粘贴、替换、缩排 撤销和重复 查找替换 编辑 学习提示 vi 的命令较多，不要期望一下子全部记住，个别命令忘记了，只是会影响编辑速度而已 在使用 vi 命令时，注意 关闭中文输入法 4.1 移动（基本） 要熟练使用 vi，首先应该学会怎么在 命令模式 下样快速移动光标 编辑操作命令，能够和 移动命令 结合在一起使用 1) 上、下、左、右 命令 功能 手指 h 向左 食指 j 向下 食指 k 向上 中指 l 向右 无名指 2) 行内移动 命令 英文 功能 w word 向后移动一个单词 b back 向前移动一个单词 0 行首 ^ 行首，第一个不是空白字符的位置 $ 行尾 3) 行数移动 命令 英文 功能 gg go 文件顶部 G go 文件末尾 数字gg go 移动到 数字 对应行数 数字G go 移动到 数字 对应行数 :数字 移动到 数字 对应行数 4) 屏幕移动 命令 英文 功能 Ctrl + b back 向上翻页 Ctrl + f forward 向下翻页 H Head 屏幕顶部 M Middle 屏幕中间 L Low 屏幕底部 4.2 移动（程序） 1) 段落移动 vi 中使用 空行 来区分段落 在程序开发时，通常 一段功能相关的代码会写在一起 —— 之间没有空行 命令 功能 { 上一段 } 下一段 2) 括号切换 在程序世界中，()、[]、{} 使用频率很高，而且 都是成对出现的 命令 功能 % 括号匹配及切换 3) 标记 在开发时，某一块代码可能需要稍后处理，例如：编辑、查看 此时先使用 m 增加一个标记，这样可以 在需要时快速地跳转回来 或者 执行其他编辑操作 标记名称 可以是 a~z 或者 A~Z 之间的任意 一个 字母 添加了标记的 行如果被删除，标记同时被删除 如果 在其他行添加了相同名称的标记，之前添加的标记也会被替换掉 命令 英文 功能 mx mark 添加标记 x，x 是 a~z 或者 A~Z 之间的任意一个字母 'x 直接定位到标记 x 所在位置 4.3 选中文本（可视模式） 学习 复制 命令前，应该先学会 怎么样选中 要复制的代码 在 vi 中要选择文本，需要先使用 Visual 命令切换到 可视模式 vi 中提供了 三种 可视模式，可以方便程序员选择 选中文本的方式 按 ESC 可以放弃选中，返回到 命令模式 命令 模式 功能 v 可视模式 从光标位置开始按照正常模式选择文本 V 可视行模式 选中光标经过的完整行 Ctrl + v 可视块模式 垂直方向选中文本 可视模式下，可以和 移动命令 连用，例如：ggVG 能够选中所有内容 4.4 撤销和恢复撤销 在学习编辑命令之前，先要知道怎样撤销之前一次 错误的 编辑动作！ 命令 英文 功能 u undo 撤销上次命令 CTRL + r redo 恢复撤销的命令 4.5 删除文本 命令 英文 功能 x cut 删除光标所在字符，或者选中文字 d(移动命令) delete 删除移动命令对应的内容 dd delete 删除光标所在行，可以 ndd 复制多行 D delete 删除至行尾 提示：如果使用 可视模式 已经选中了一段文本，那么无论使用 d 还是 x，都可以删除选中文本 删除命令可以和 移动命令 连用，以下是常见的组合命令： * dw # 从光标位置删除到单词末尾 * d0 # 从光标位置删除到一行的起始位置 * d} # 从光标位置删除到段落结尾 * ndd # 从光标位置向下连续删除 n 行 * d代码行G # 从光标所在行 删除到 指定代码行 之间的所有代码 * d'a # 从光标所在行 删除到 标记a 之间的所有代码 4.6 复制、粘贴 vi 中提供有一个 被复制文本的缓冲区 复制 命令会将选中的文字保存在缓冲区 删除 命令删除的文字会被保存在缓冲区 在需要的位置，使用 粘贴 命令可以将缓冲区的文字插入到光标所在位置 命令 英文 功能 y(移动命令) copy 复制 yy copy 复制一行，可以 nyy 复制多行 p paste 粘贴 提示 命令 d、x 类似于图形界面的 剪切操作 —— CTRL + X 命令 y 类似于图形界面的 复制操作 —— CTRL + C 命令 p 类似于图形界面的 粘贴操作 —— CTRL + V vi 中的 文本缓冲区同样只有一个，如果后续做过 复制、剪切 操作，之前缓冲区中的内容会被替换 注意 vi 中的 文本缓冲区 和系统的 剪贴板 不是同一个 所以在其他软件中使用 CTRL + C 复制的内容，不能在 vi 中通过 P 命令粘贴 可以在 编辑模式 下使用 鼠标右键粘贴 4.7 替换 命令 英文 功能 工作模式 r replace 替换当前字符 命令模式 R replace 替换当前行光标后的字符 替换模式 R 命令可以进入 替换模式，替换完成后，按下 ESC 可以回到 命令模式 替换命令 的作用就是不用进入 编辑模式，对文件进行 轻量级的修改 4.8 缩排和重复执行 命令 功能 >> 向右增加缩进 向左减少缩进 . 重复上次命令 缩排命令 在开发程序时，统一增加代码的缩进 比较有用！ 一次性 在选中代码前增加 4 个空格，就叫做 增加缩进 一次性 在选中代码前删除 4 个空格，就叫做 减少缩进 在 可视模式 下，缩排命令只需要使用 一个 > 或者 在程序中，缩进 通常用来表示代码的归属关系 前面空格越少，代码的级别越高 前面空格越多，代码的级别越低 4.9 查找 常规查找 命令 功能 /str 查找 str 查找到指定内容之后，使用 Next 查找下一个出现的位置： n: 查找下一个 N: 查找上一个 如果不想看到高亮显示，可以随便查找一个文件中不存在的内容即可 单词快速匹配 命令 功能 * 向后查找当前光标所在单词 # 向前查找当前光标所在单词 在开发中，通过单词快速匹配，可以快速看到这个单词在其他什么位置使用过 4.10 查找并替换 在 vi 中查找和替换命令需要在 末行模式 下执行 记忆命令格式： :%s///g 1) 全局替换 一次性替换文件中的 所有出现的旧文本 命令格式如下： :%s/旧文本/新文本/g 2) 可视区域替换 先选中 要替换文字的 范围 命令格式如下： :s/旧文本/新文本/g 3) 确认替换 如果把末尾的 g 改成 gc 在替换的时候，会有提示！推荐使用！ :%s/旧文本/新文本/gc y - yes 替换 n - no 不替换 a - all 替换所有 q - quit 退出替换 l - last 最后一个，并把光标移动到行首 ^E 向下滚屏 ^Y 向上滚屏 4.11 插入命令 在 vi 中除了常用的 i 进入 编辑模式 外，还提供了以下命令同样可以进入编辑模式： 命令 英文 功能 常用 i insert 在当前字符前插入文本 常用 I insert 在行首插入文本 较常用 a append 在当前字符后添加文本 A append 在行末添加文本 较常用 o 在当前行后面插入一空行 常用 O 在当前行前面插入一空行 常用 演练 1 —— 编辑命令和数字连用 在开发中，可能会遇到连续输入 N 个同样的字符 在 Python 中有简单的方法，但是其他语言中通常需要自己输入 例如：********** 连续 10 个星号 要实现这个效果可以在 命令模式 下 输入 10，表示要重复 10 次 输入 i 进入 编辑模式 输入 * 也就是重复的文字 按下 ESC 返回到 命令模式，返回之后 vi 就会把第 2、3 两步的操作重复 10 次 提示：正常开发时，在 进入编辑模式之前，不要按数字 演练 2 —— 利用 可视块 给多行代码增加注释 在开发中，可能会遇到一次性给多行代码 增加注释 的情况 在 Python 中，要给代码增加注释，可以在代码前增加一个 # 要实现这个效果可以在 命令模式 下 移动到要添加注释的 第 1 行代码，按 ^ 来到行首 按 CTRL + v 进入 可视块 模式 使用 j 向下连续选中要添加的代码行 输入 I 进入 编辑模式，并在 行首插入，注意：一定要使用 I 输入 # 也就是注释符号 按下 ESC 返回到 命令模式，返回之后 vi 会在之前选中的每一行代码 前 插入 # 05. 分屏命令 属于 vi 的高级命令 —— 可以 同时编辑和查看多个文件 5.1 末行命令扩展 末行命令 主要是针对文件进行操作的：保存、退出、保存&退出、搜索&替换、另存、新建、浏览文件 命令 英文 功能 :e . edit 会打开内置的文件浏览器，浏览要当前目录下的文件 :n 文件名 new 新建文件 :w 文件名 write 另存为，但是仍然编辑当前文件，并不会切换文件 提示：切换文件之前，必须保证当前这个文件已经被保存！ 已经学习过的 末行命令： 命令 英文 功能 :w write 保存 :q quit 退出，如果没有保存，不允许退出 :q! quit 强行退出，不保存退出 :wq write & quit 保存并退出 :x 保存并退出 :%s///gc 确认搜索并替换 在实际开发中，可以使用 w 命令 阶段性的备份代码 5.2 分屏命令 使用 分屏命令，可以 同时编辑和查看多个文件 命令 英文 功能 :sp [文件名] split 横向增加分屏 :vsp [文件名] vertical split 纵向增加分屏 1) 切换分屏窗口 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 w window 切换到下一个窗口 r reverse 互换窗口 c close 关闭当前窗口，但是不能关闭最后一个窗口 q quit 退出当前窗口，如果是最后一个窗口，则关闭 vi o other 关闭其他窗口 2) 调整窗口大小 分屏窗口都是基于 CTRL + W 这个快捷键的，w 对应的英文单词是 window 命令 英文 功能 + 增加窗口高度 - 减少窗口高度 > 增加窗口宽度 减少窗口宽度 = 等分窗口大小 调整窗口宽高的命令可以和数字连用，例如：5 CTRL + W + 连续 5 次增加高度 06. 常用命令速查图 vimrc vimrc 是 vim 的配置文件，可以设置 vim 的配置，包括：热键、配色、语法高亮、插件 等 Linux 中 vimrc 有两个位置，家目录下的配置文件优先级更高 /etc/vim/vimrc ~/.vimrc 常用的插件有： 代码补全 代码折叠 搜索 Git 集成 …… 网上有很多高手已经配置好的针对 python 开发的 vimrc 文件，可以下载过来直接使用，或者等大家多 Linux 比较熟悉后，再行学习！ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/Python_基础课程安排.html":{"url":"python/01/Python_基础课程安排.html","title":"Python 基础课程安排","keywords":"","body":"01_Python 基础课程安排 目标 明确基础班课程内容 课程清单 序号 内容 目标 01 Linux 基础 让大家对 Ubuntu 的使用从很 陌生 达到 灵活操作 02 Python 基础 涵盖 Python 基础知识，让大家掌握基础的编程能力 03 Python 面向对象 介绍 Python 的面相对象开发，为开发大型项目做好铺垫和准备 04 项目实战 应用基础班学习过的知识，编程实战，完成第一个 Python 项目 分享 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/操作系统（科普章节）.html":{"url":"python/01/操作系统（科普章节）.html","title":"操作系统（科普章节）","keywords":"","body":"02_操作系统（科普章节） 目标 了解操作系统及作用 1. 操作系统（Operation System，OS） 操作系统作为接口的示意图 ￼ 没有安装操作系统的计算机，通常被称为 裸机 如果想在 裸机 上运行自己所编写的程序，就必须用机器语言书写程序 如果计算机上安装了操作系统，就可以在操作系统上安装支持的高级语言环境，用高级语言开发程序 1.1 操作系统的作用 是现代计算机系统中 最基本和最重要 的系统软件 是 配置在计算机硬件上的第一层软件，是对硬件系统的首次扩展 主要作用是管理好硬件设备，并为用户和应用程序提供一个简单的接口，以便于使用 而其他的诸如编译程序、数据库管理系统，以及大量的应用软件，都直接依赖于操作系统的支持 1.2 不同应用领域的主流操作系统 桌面操作系统 服务器操作系统 嵌入式操作系统 移动设备操作系统 1> 桌面操作系统 Windows 系列 用户群体大 macOS 适合于开发人员 Linux 应用软件少 2> 服务器操作系统 Linux 安全、稳定、免费 占有率高 Windows Server 付费 占有率低 ￼ 3> 嵌入式操作系统 Linux 4> 移动设备操作系统 iOS Android（基于 Linux） 1.3 虚拟机 虚拟机（Virtual Machine）指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统 虚拟系统通过生成现有操作系统的全新虚拟镜像，具有真实操作系统完全一样的功能 进入虚拟系统后，所有操作都是在这个全新的独立的虚拟系统里面进行，可以独立安装运行软件，保存数据，拥有自己的独立桌面，不会对真正的系统产生任何影响 而且能够在现有系统与虚拟镜像之间灵活切换的一类操作系统 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/操作系统的发展史（科普章节）.html":{"url":"python/01/操作系统的发展史（科普章节）.html","title":"操作系统的发展史（科普章节）","keywords":"","body":"03_操作系统的发展史（科普章节） 目标 了解操作系统的发展历史 知道 Linux 内核及发行版的区别 知道 Linux 的应用领域 01. 操作系统的发展历史 1.1 Unix 1965 年之前的时候，电脑并不像现在一样普遍，它可不是一般人能碰的起的，除非是军事或者学院的研究机构，而且当时大型主机至多能提供30台终端（30个键盘、显示器)，连接一台电脑 ￼ 为了解决数量不够用的问题 1965 年左后由 贝尔实验室 加入了 麻省理工学院 以及 通用电气 合作的计划 —— 该计划要建立一套 多使用者(multi－user)、多任务(multi－processor)、多层次(multi－level) 的 MULTICS 操作系统，想让大型主机支持 300 台终端 1969 年前后这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969 年从这个项目中退出的 Ken Thompson 当时在实验室无聊时，为了让一台空闲的电脑上能够运行 \"星际旅行（Space Travel）\" 游行，在 8 月份左右趁着其妻子探亲的时间，用了 1 个月的时间，使用汇编写出了 Unix 操作系统的原型 1970 年，美国贝尔实验室的 Ken Thompson，以 BCPL 语言为基础，设计出很简单且很接近硬件的 B 语言（取BCPL的首字母），并且他用 B 语言 写了第一个 UNIX 操作系统 1971 年，同样酷爱 \"星际旅行（Space Travel）\" 的 Dennis M.Ritchie 为了能早点儿玩上游戏，加入了 Thompson 的开发项目，合作开发 UNIX，他的主要工作是改造 B 语言，因为B 语言 的跨平台性较差 1972 年，Dennis M.Ritchie 在 B 语言 的基础上最终设计出了一种新的语言，他取了 BCPL 的第二个字母作为这种语言的名字，这就是 C 语言 1973 年初，C 语言的主体完成，Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix 操作系统 ￼ 肯·汤普逊（左）和丹尼斯·里奇（右） C 语言 在把 UNIX 移植到其他类型的计算机上使用时， C 语言 强大的移植性（Portability）在此显现 机器语言和汇编语言都不具有移植性，为 x86 开发的程序，不可能在 Alpha，SPARC 和 ARM 等机器上运行 而 C 语言程序则可以使用在任意架构的处理器上，只要那种架构的处理器具有对应的 C 语言编译器和库，然后将 C 源代码编译、连接成目标二进制文件之后即可运行 Unix 家谱 ￼ 1.2 Minix 因为 AT&T（通用电气） 的政策改变，在 Version 7 Unix 推出之后，发布新的使用条款，将 UNIX 源代码私有化，在大学中不再能使用 UNIX 源代码 Andrew S. Tanenbaum（塔能鲍姆） 教授为了能 在课堂上教授学生操作系统运作的细节，决定在不使用任何 AT&T 的源代码前提下，自行开发与 UNIX 兼容的操作系统，以避免版权上的争议 以 小型 UNIX（mini-UNIX）之意，将它称为 MINIX 1.3 Linux 1991 年 林纳斯（Linus） 就读于赫尔辛基大学期间，对 Unix 产生浓厚兴趣，尝试着在Minix 上做一些开发工作 因为 Minix 只是教学使用，因此功能并不强，林纳斯 经常要用他的终端 仿真器（Terminal Emulator） 去访问大学主机上的新闻组和邮件，为了方便读写和下载文件，他自己编写了磁盘驱动程序和文件系统，这些在后来成为了 Linux 第一个内核的雏形，当时，他年仅 21 岁！ 林纳斯 利用 GNU 的 bash 当做开发环境，gcc 当做编译工具，编写了 Linux 内核，一开始 Linux 并不能兼容 Unix 即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致 一开始 Linux 只适用于 386，后来经过全世界的网友的帮助，最终能够兼容多种硬件 ￼ 02. Linux 内核及发行版 2.1 Linux 内核版本 内核（kernel）是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层 Linux 内核版本又分为 稳定版 和 开发版 ，两种版本是相互关联，相互循环 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些 bug 或加入一些新的驱动程序 开发版：由于要试验各种解决方案，所以变化很快 内核源码网址：http://www.kernel.org 所有来自全世界的对 Linux 源码的修改最终都会汇总到这个网站，由 Linus 领导的开源社区对其进行甄别和修改最终决定是否进入到 Linux 主线内核源码中 2.2 Linux 发行版本 Linux 发行版（也被叫做 GNU/Linux 发行版）通常包含了包括桌面环境、办公套件、媒体播放器、数据库等应用软件 常见的发行版本如下： Ubuntu Redhat Fedora openSUSE Linux Mint Debian Manjaro Mageia CentOS Arch 十大 Linux 服务器发行版排行榜：http://os.51cto.com/art/201612/526126.htm 在几乎每一份与 Linux 有关的榜单上，基于 Debian 的 Ubuntu 都占有一席之位。Canonical 的Ubuntu 胜过其他所有的 Linux 服务器发行版 ―― 从简单安装、出色的硬件发现，到世界级的商业支持，Ubuntu确立了难以企及的严格标准 03. Linux 的应用领域 3.1 服务器领域 Linux 在服务器领域的应用是其重要分支 Linux 免费、稳定、高效等特点在这里得到了很好的体现 早期因为维护、运行等原因同样受到了很大的限制 近些年来 Linux 服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛 3.2 嵌入式领域 近些年来 Linux 在嵌入式领域的应用得到了飞速的提高 Linux 运行稳定、对网络的良好支持性、低成本，且可以根据需要进行软件裁剪，内核最小可以达到几百 KB 等特点，使其近些年来在嵌入式领域的应用得到非常大的提高 主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA、等都是其应用领域，得到了 Google、三星、摩托罗拉、NEC 等公司的大力推广 3.3 个人桌面领域 此领域是传统 Linux 应用最薄弱的环节 传统 Linux 由于界面简单、操作复杂、应用软件少的缺点，一直被 Windows 所压制 近些年来随着 Ubuntu、Fedora 等优秀桌面环境的兴起，同时各大硬件厂商对其支持的加大，Linux 在个人桌面领域的占有率在逐渐的提高 在 Ubuntu 中玩 QQ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/文件和目录（理解）.html":{"url":"python/01/文件和目录（理解）.html","title":"文件和目录（理解）","keywords":"","body":"04_文件和目录（理解） 目标 理解 Linux 文件目录的结构 01. 单用户操作系统和多用户操作系统（科普） 单用户操作系统：指一台计算机在同一时间 只能由一个用户 使用，一个用户独自享用系统的全部硬件和软件资源 Windows XP 之前的版本都是单用户操作系统 多用户操作系统：指一台计算机在同一时间可以由 多个用户 使用，多个用户共同享用系统的全部硬件和软件资源 Unix 和 Linux 的设计初衷就是多用户操作系统 02. Windows 和 Linux 文件系统区别 2.1 Windows 下的文件系统 在 Windows 下，打开 “计算机”，我们看到的是一个个的驱动器盘符： ￼ 每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示： ￼ 2.2 Linux 下的文件系统 在 Linux 下，我们是看不到这些驱动器盘符，我们看到的是文件夹（目录）： ￼ Ubuntu 没有盘符这个概念，只有一个根目录 /，所有文件都在它下面 ￼ 2.3 用户目录 位于 /home/user，称之为用户工作目录或家目录，表示方式： /home/user ~ 2.4 Linux 主要目录速查表 /：根目录， 一般根目录下只存放目录 ，在 linux 下有且只有一个根目录，所有的东西都是从这里开始 当在终端里输入 /home，其实是在告诉电脑，先从 /（根目录）开始，再进入到 home 目录 /bin、/usr/bin：可执行二进制文件的目录，如常用的命令 ls、tar、mv、cat 等 /boot：放置 linux 系统启动时用到的一些文件，如 linux 的内核文件：/boot/vmlinuz，系统引导管理器：/boot/grub /dev：存放linux系统下的设备文件，访问该目录下某个文件，相当于访问某个设备，常用的是挂载光驱mount /dev/cdrom /mnt /etc：系统配置文件存放的目录，不建议在此目录下存放可执行文件，重要的配置文件有 /etc/inittab /etc/fstab /etc/init.d /etc/X11 /etc/sysconfig /etc/xinetd.d /home：系统默认的用户家目录，新增用户账号时，用户的家目录都存放在此目录下 ~ 表示当前用户的家目录 ~edu 表示用户 edu 的家目录 /lib、/usr/lib、/usr/local/lib：系统使用的函数库的目录，程序在执行过程中，需要调用一些额外的参数时需要函数库的协助 /lost+fount：系统异常产生错误时，会将一些遗失的片段放置于此目录下 /mnt: /media：光盘默认挂载点，通常光盘挂载于 /mnt/cdrom 下，也不一定，可以选择任意位置进行挂载 /opt：给主机额外安装软件所摆放的目录 /proc：此目录的数据都在内存中，如系统核心，外部设备，网络状态，由于数据都存放于内存中，所以不占用磁盘空间，比较重要的文件有：/proc/cpuinfo、/proc/interrupts、/proc/dma、/proc/ioports、/proc/net/* 等 /root：系统管理员root的家目录 /sbin、/usr/sbin、/usr/local/sbin：放置系统管理员使用的可执行命令，如 fdisk、shutdown、mount 等。与 /bin 不同的是，这几个目录是给系统管理员 root 使用的命令，一般用户只能\"查看\"而不能设置和使用 /tmp：一般用户或正在执行的程序临时存放文件的目录，任何人都可以访问，重要数据不可放置在此目录下 /srv：服务启动之后需要访问的数据目录，如 www 服务需要访问的网页数据存放在 /srv/www 内 /usr：应用程序存放目录 /usr/bin：存放应用程序 /usr/share：存放共享数据 /usr/lib：存放不能直接运行的，却是许多程序运行所必需的一些函数库文件 /usr/local：存放软件升级包 /usr/share/doc：系统说明文件存放目录 /usr/share/man：程序说明文件存放目录 /var：放置系统执行过程中经常变化的文件 /var/log：随时更改的日志文件 /var/spool/mail：邮件存放的目录 /var/run：程序或服务启动后，其 PID 存放在该目录下 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/Ubuntu-图形界面入门.html":{"url":"python/01/Ubuntu-图形界面入门.html","title":"Ubuntu 图形界面入门","keywords":"","body":"05_Ubuntu 图形界面入门 目标 熟悉 Ubuntu 图形界面的基本使用 01. Ubuntu 的任务栏 ￼ 02. 窗口操作按钮 ￼ 03. 窗口菜单条 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/常用-Linux-命令的基本使用.html":{"url":"python/01/常用-Linux-命令的基本使用.html","title":"Ubuntu 图形界面入门","keywords":"","body":"06_Ubuntu 图形界面入门 目标 理解学习 Linux 终端命令的原因 常用 Linux 命令体验 01. 学习 Linux 终端命令的原因 Linux 刚面世时并没有图形界面，所有的操作全靠命令完成，如 磁盘操作、文件存取、目录操作、进程管理、文件权限 设定等 在职场中，大量的 服务器维护工作 都是在 远程 通过 SSH 客户端 来完成的，并没有图形界面，所有的维护工作都需要通过命令来完成 在职场中，作为后端程序员，必须要或多或少的掌握一些 Linux 常用的终端命令 Linux 发行版本的命令大概有 200 多个，但是常用的命令只有 10 多个而已 学习终端命令的技巧： 不需要死记硬背，对于常用命令，用的多了，自然就记住了 不要尝试一次学会所有的命令，有些命令是非常不常用的，临时遇到，临时百度就可以 02. 常用 Linux 命令的基本使用 序号 命令 对应英文 作用 01 ls list 查看当前文件夹下的内容 02 pwd print wrok directory 查看当前所在文件夹 03 cd [目录名] change directory 切换文件夹 04 touch [文件名] touch 如果文件不存在，新建文件 05 mkdir [目录名] make directory 创建目录 06 rm [文件名] remove 删除指定的文件名 07 clear clear 清屏 小技巧 ctrl + shift + = 放大终端窗口的字体显示 ctrl + - 缩小终端窗口的字体显示 03. 自动补全 在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 小技巧 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/Linux-终端命令格式.html":{"url":"python/01/Linux-终端命令格式.html","title":"Linux 终端命令格式","keywords":"","body":"07_Linux 终端命令格式 目标 了解终端命令格式 知道如何查阅终端命令帮助信息 01. 终端命令格式 command [-options] [parameter] 说明： command：命令名，相应功能的英文单词或单词的缩写 [-options]：选项，可用来对命令进行控制，也可以省略 parameter：传给命令的参数，可以是 零个、一个 或者 多个 [] 代表可选 02. 查阅命令帮助信息（知道） 提示 现阶段只需要 知道 通过以下两种方式可以查询命令的帮助信息 先学习常用命令及常用选项的使用即可，工作中如果遇到问题可以借助 网络搜索 2.1 --help command --help 说明： 显示 command 命令的帮助信息 2.2 man man command 说明： 查阅 command 命令的使用手册 man 是 manual 的缩写，是 Linux 提供的一个 手册，包含了绝大部分的命令、函数的详细使用说明 使用 man 时的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/文件和目录常用命令.html":{"url":"python/01/文件和目录常用命令.html","title":"文件和目录常用命令","keywords":"","body":"08_文件和目录常用命令 目标 查看目录内容 ls 切换目录 cd 创建和删除操作 touch rm mkdir 拷贝和移动文件 cp mv 查看文件内容 cat more grep 其他 echo 重定向 > 和 >> 管道 | 01. 查看目录内容 1.1 终端实用技巧 1> 自动补全 在敲出 文件 ／ 目录 ／ 命令 的前几个字母之后，按下 tab 键 如果输入的没有歧义，系统会自动补全 如果还存在其他 文件／目录／命令，再按一下 tab 键，系统会提示可能存在的命令 2> 曾经使用过的命令 按 上／下 光标键可以在曾经使用过的命令之间来回切换 如果想要退出选择，并且不想执行当前选中的命令，可以按 ctrl + c 1.2 ls 命令说明 ls 是英文单词 list 的简写，其功能为列出目录的内容，是用户最常用的命令之一，类似于 DOS 下的 dir 命令 Linux 下文件和目录的特点 Linux 文件 或者 目录 名称最长可以有 256 个字符 以 . 开头的文件为隐藏文件，需要用 -a 参数才能显示 . 代表当前目录 .. 代表上一级目录 1.3 ls 常用选项 参数 含义 -a 显示指定目录下所有子目录与文件，包括隐藏文件 -l 以列表方式显示文件的详细信息 -h 配合 -l 以人性化的方式显示文件大小 计算机中文件大小的表示方式（科普） 单位 英文 含义 字节 B（Byte） 在计算机中作为一个数字单元，一般为 8 位二进制数 千 K（Kibibyte） 1 KB = 1024 B，千字节 （1024 = 2 ** 10） 兆 M（Mebibyte） 1 MB = 1024 KB，百万字节 千兆 G（Gigabyte） 1 GB = 1024 MB，十亿字节，千兆字节 太 T（Terabyte） 1 TB = 1024 GB，万亿字节，太字节 拍 P（Petabyte） 1 PB = 1024 TB，千万亿字节，拍字节 艾 E（Exabyte） 1 EB = 1024 PB，百亿亿字节，艾字节 泽 Z（Zettabyte） 1 ZB = 1024 EB，十万亿亿字节，泽字节 尧 Y（Yottabyte） 1 YB = 1024 ZB，一亿亿亿字节，尧字节 1.4 ls 通配符的使用 通配符 含义 * 代表任意个数个字符 ? 代表任意一个字符，至少 1 个 [] 表示可以匹配字符组中的任一一个 [abc] 匹配 a、b、c 中的任意一个 [a-f] 匹配从 a 到 f 范围内的的任意一个字符 02. 切换目录 2.1 cd cd 是英文单词 change directory 的简写，其功能为更改当前的工作目录，也是用户最常用的命令之一 注意：Linux 所有的 目录 和 文件名 都是大小写敏感的 命令 含义 cd 切换到当前用户的主目录(/home/用户目录) cd ~ 切换到当前用户的主目录(/home/用户目录) cd . 保持在当前目录不变 cd .. 切换到上级目录 cd - 可以在最近两次工作目录之间来回切换 2.2 相对路径和绝对路径 相对路径 在输入路径时，最前面不是 / 或者 ~，表示相对 当前目录 所在的目录位置 绝对路径 在输入路径时，最前面是 / 或者 ~，表示从 根目录/家目录 开始的具体目录位置 03. 创建和删除操作 3.1 touch 创建文件或修改文件时间 如果文件 不存在，可以创建一个空白文件 如果文件 已经存在，可以修改文件的末次修改日期 3.2 mkdir 创建一个新的目录 选项 含义 -p 可以递归创建目录 新建目录的名称 不能与当前目录中 已有的目录或文件 同名 3.3 rm 删除文件或目录 使用 rm 命令要小心，因为文件删除后不能恢复 选项 含义 -f 强制删除，忽略不存在的文件，无需提示 -r 递归地删除目录下的内容，删除文件夹 时必须加此参数 04. 拷贝和移动文件 序号 命令 对应英文 作用 01 tree [目录名] tree 以树状图列出文件目录结构 02 cp 源文件 目标文件 copy 复制文件或者目录 03 mv 源文件 目标文件 move 移动文件或者目录／文件或者目录重命名 4.1 tree tree 命令可以以树状图列出文件目录结构 选项 含义 -d 只显示目录 4.2 cp cp 命令的功能是将给出的 文件 或 目录 复制到另一个 文件 或 目录 中，相当于 DOS 下的 copy 命令 选项 含义 -i 覆盖文件前提示 -r 若给出的源文件是目录文件，则 cp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 4.3 mv mv 命令可以用来 移动 文件 或 目录，也可以给 文件或目录重命名 选项 含义 -i 覆盖文件前提示 05. 查看文件内容 序号 命令 对应英文 作用 01 cat 文件名 concatenate 查看文件内容、创建文件、文件合并、追加文件内容等功能 02 more 文件名 more 分屏显示文件内容 03 grep 搜索文本 文件名 grep 搜索文本文件内容 5.1 cat cat 命令可以用来 查看文件内容、创建文件、文件合并、追加文件内容 等功能 cat 会一次显示所有的内容，适合 查看内容较少 的文本文件 选项 含义 -b 对非空输出行编号 -n 对输出的所有行编号 Linux 中还有一个 nl 的命令和 cat -b 的效果等价 5.2 more more 命令可以用于分屏显示文件内容，每次只显示一页内容 适合于 查看内容较多的文本文件 使用 more 的操作键： 操作键 功能 空格键 显示手册页的下一屏 Enter 键 一次滚动手册页的一行 b 回滚一屏 f 前滚一屏 q 退出 /word 搜索 word 字符串 5.3 grep Linux 系统中 grep 命令是一种强大的文本搜索工具 grep允许对文本文件进行 模式查找，所谓模式查找，又被称为正则表达式，在就业班会详细讲解 选项 含义 -n 显示匹配行及行号 -v 显示不包含匹配文本的所有行（相当于求反） -i 忽略大小写 常用的两种模式查找 参数 含义 ^a 行首，搜寻以 a 开头的行 ke$ 行尾，搜寻以 ke 结束的行 06. 其他 6.1 echo 文字内容 echo 会在终端中显示参数指定的文字，通常会和 重定向 联合使用 6.2 重定向 > 和 >> Linux 允许将命令执行结果 重定向到一个 文件 将本应显示在终端上的内容 输出／追加 到指定文件中 其中 > 表示输出，会覆盖文件原有的内容 >> 表示追加，会将内容追加到已有文件的末尾 6.3 管道 | Linux 允许将 一个命令的输出 可以通过管道 做为 另一个命令的输入 可以理解现实生活中的管子，管子的一头塞东西进去，另一头取出来，这里 | 的左右分为两端，左端塞东西（写），右端取东西（读） 常用的管道命令有： more：分屏显示内容 grep：在命令执行结果的基础上查询指定的文本 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/远程管理常用命令.html":{"url":"python/01/远程管理常用命令.html","title":"远程管理常用命令","keywords":"","body":"09_远程管理常用命令 目标 关机/重启 shutdown 查看或配置网卡信息 ifconfig ping 远程登录和复制文件 ssh scp 01. 关机/重启 序号 命令 对应英文 作用 01 shutdown 选项 时间 shutdown 关机／重新启动 1.1 shutdown shutdown 命令可以 安全 关闭 或者 重新启动系统 选项 含义 -r 重新启动 提示： 不指定选项和参数，默认表示 1 分钟之后 关闭电脑 远程维护服务器时，最好不要关闭系统，而应该重新启动系统 常用命令示例 # 重新启动操作系统，其中 now 表示现在 $ shutdown -r now # 立刻关机，其中 now 表示现在 $ shutdown now # 系统在今天的 20:25 会关机 $ shutdown 20:25 # 系统再过十分钟后自动关机 $ shutdown +10 # 取消之前指定的关机计划 $ shutdown -c 02. 查看或配置网卡信息 序号 命令 对应英文 作用 01 ifconfig configure a network interface 查看/配置计算机当前的网卡配置信息 02 ping ip地址 ping 检测到目标 ip地址 的连接是否正常 2.1 网卡 和 IP 地址 网卡 网卡是一个专门负责网络通讯的硬件设备 IP 地址是设置在网卡上的地址信息 我们可以把 电脑 比作 电话，网卡 相当于 SIM 卡，IP 地址 相当于 电话号码 IP 地址 每台联网的电脑上都有 IP 地址，是保证电脑之间正常通讯的重要设置 注意：每台电脑的 IP 地址不能相同，否则会出现 IP 地址冲突，并且没有办法正常通讯 提示：有关 IP 地址的详细内容，在就业班会详细讲解！ 2.2 ifconfig ifconfig 可以查看／配置计算机当前的网卡配置信息 # 查看网卡配置信息 $ ifconfig # 查看网卡对应的 IP 地址 $ ifconfig | grep inet 提示：一台计算机中有可能会有一个 物理网卡 和 多个虚拟网卡，在 Linux 中物理网卡的名字通常以 ensXX 表示 127.0.0.1 被称为 本地回环/环回地址，一般用来测试本机网卡是否正常 2.3 ping # 检测到目标主机是否连接正常 $ ping IP地址 # 检测本地网卡工作正常 $ ping 127.0.0.1 ping 一般用于检测当前计算机到目标计算机之间的网络 是否通畅，数值越大，速度越慢 ping 的工作原理与潜水艇的声纳相似，ping 这个命令就是取自 声纳的声音 网络管理员之间也常将 ping 用作动词 —— ping 一下计算机X，看他是否开着 原理：网络上的机器都有 唯一确定的 IP 地址，我们给目标 IP 地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在 提示：在 Linux 中，想要终止一个终端程序的执行，绝大多数都可以使用 CTRL + C 03. 远程登录和复制文件 序号 命令 对应英文 作用 01 ssh 用户名@ip secure shell 关机／重新启动 02 scp 用户名@ip:文件名或路径 用户名@ip:文件名或路径 secure copy 远程复制文件 3.1 ssh 基础（重点） 在 Linux 中 SSH 是 非常常用 的工具，通过 SSH 客户端 我们可以连接到运行了 SSH 服务器 的远程机器上 ￼ SSH 客户端是一种使用 Secure Shell（SSH） 协议连接到远程计算机的软件程序 SSH 是目前较可靠， 专为远程登录会话和其他网络服务 提供安全性的协议 利用 SSH 协议 可以有效防止远程管理过程中的信息泄露 通过 SSH 协议 可以对所有传输的数据进行加密，也能够防止 DNS 欺骗和 IP 欺骗 SSH 的另一项优点是传输的数据可以是经过压缩的，所以可以加快传输的速度 1) 域名 和 端口号 域名 由一串 用点分隔 的名字组成，例如：www.itcast.cn 是 IP 地址 的别名，方便用户记忆 端口号 IP 地址：通过 IP 地址 找到网络上的 计算机 端口号：通过 端口号 可以找到 计算机上运行的应用程序 SSH 服务器 的默认端口号是 22，如果是默认端口号，在连接的时候，可以省略 常见服务端口号列表： 序号 服务 端口号 01 SSH 服务器 22 02 Web 服务器 80 03 HTTPS 443 04 FTP 服务器 21 提示：有关 端口号的详细内容，在就业班会详细讲解！ 2) SSH 客户端的简单使用 ssh [-p port] user@remote user 是在远程机器上的用户名，如果不指定的话默认为当前用户 remote 是远程机器的地址，可以是 IP／域名，或者是 后面会提到的别名 port 是 SSH Server 监听的端口，如果不指定，就为默认值 22 提示： 使用 exit 退出当前用户的登录 注意： ssh 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY 或者 XShell 客户端软件即可 提示： 在工作中，SSH 服务器的端口号很有可能不是 22，如果遇到这种情况就需要使用 -p 选项，指定正确的端口号，否则无法正常连接到服务器 3) Windows 下 SSH 客户端的安装 Putty http://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html XShell http://xshellcn.com 建议从官方网站下载正式的安装程序 3.2 scp（掌握） scp 就是 secure copy，是一个在 Linux 下用来进行 远程拷贝文件 的命令 它的地址格式与 ssh 基本相同，需要注意的是，在指定端口时用的是大写的 -P 而不是小写的 ￼ # 把本地当前目录下的 01.py 文件 复制到 远程 家目录下的 Desktop/01.py # 注意：`:` 后面的路径如果不是绝对路径，则以用户的家目录作为参照路径 scp -P port 01.py user@remote:Desktop/01.py # 把远程 家目录下的 Desktop/01.py 文件 复制到 本地当前目录下的 01.py scp -P port user@remote:Desktop/01.py 01.py # 加上 -r 选项可以传送文件夹 # 把当前目录下的 demo 文件夹 复制到 远程 家目录下的 Desktop scp -r demo user@remote:Desktop # 把远程 家目录下的 Desktop 复制到 当前目录下的 demo 文件夹 scp -r user@remote:Desktop demo 选项 含义 -r 若给出的源文件是目录文件，则 scp 将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名 -P 若远程 SSH 服务器的端口不是 22，需要使用大写字母 -P 选项指定端口 注意： scp 这个终端命令只能在 Linux 或者 UNIX 系统下使用 如果在 Windows 系统中，可以安装 PuTTY，使用 pscp 命令行工具或者安装 FileZilla 使用 FTP 进行文件传输 FileZilla 官方网站：https://www.filezilla.cn/download/client FileZilla 在传输文件时，使用的是 FTP 服务 而不是 SSH 服务，因此端口号应该设置为 21 3.3 SSH 高级（知道） 免密码登录 配置别名 提示：有关 SSH 配置信息都保存在用户家目录下的 .ssh 目录下 1）免密码登录 步骤 配置公钥 执行 ssh-keygen 即可生成 SSH 钥匙，一路回车即可 上传公钥到服务器 执行 ssh-copy-id -p port user@remote，可以让远程服务器记住我们的公钥 示意图 ￼ 非对称加密算法 使用 公钥 加密的数据，需要使用 私钥 解密 使用 私钥 加密的数据，需要使用 公钥 解密 2) 配置别名 每次都输入 ssh -p port user@remote，时间久了会觉得很麻烦，特别是当 user, remote 和 port 都得输入，而且还不好记忆 而 配置别名 可以让我们进一步偷懒，譬如用：ssh mac 来替代上面这么一长串，那么就在 ~/.ssh/config 里面追加以下内容： Host mac HostName ip地址 User itheima Port 22 保存之后，即可用 ssh mac 实现远程登录了，scp 同样可以使用 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/用户权限相关命令.html":{"url":"python/01/用户权限相关命令.html","title":"用户权限相关命令","keywords":"","body":"10_用户权限相关命令 目标 用户 和 权限 的基本概念 用户管理 终端命令 组管理 终端命令 修改权限 终端命令 01. 用户 和 权限 的基本概念 1.1 基本概念 用户 是 Linux 系统工作中重要的一环，用户管理包括 用户 与 组 管理 在 Linux 系统中，不论是由本机或是远程登录系统，每个系统都必须拥有一个账号，并且对于不同的系统资源拥有不同的使用权限 在 Linux 中，可以指定 每一个用户 针对 不同的文件或者目录 的 不同权限 对 文件／目录 的权限包括： 序号 权限 英文 缩写 数字代号 01 读 read r 4 02 写 write w 2 03 执行 excute x 1 1.2 组 为了方便用户管理，提出了 组 的概念，如下图所示 ￼ 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 1.3 ls -l 扩展 ls -l 可以查看文件夹下文件的详细信息，从左到右依次是： 权限，第 1 个字符如果是 d 表示目录 硬链接数，通俗地讲，就是有多少种方式，可以访问到当前目录／文件 拥有者，家目录下 文件／目录 的拥有者通常都是当前用户 组，在 Linux 中，很多时候，会出现组名和用户名相同的情况，后续会讲 大小 时间 名称 ￼ 1.4 chmod 简单使用（重要） chmod 可以修改 用户／组 对 文件／目录 的权限 命令格式如下： chmod +/-rwx 文件名|目录名 提示：以上方式会一次性修改 拥有者 / 组 权限，有关 chmod 的高级用法，后续会讲 1.5 超级用户 Linux 系统中的 root 账号通常 用于系统的维护和管理，对操作系统的所有资源 具有所有访问权限 在大多数版本的 Linux 中，都不推荐 直接使用 root 账号登录系统 在 Linux 安装的过程中，系统会自动创建一个用户账号，而这个默认的用户就称为“标准用户” sudo su 是 substitute user 的缩写，表示 使用另一个用户的身份 sudo 命令用来以其他身份来执行命令，预设的身份为 root 用户使用 sudo 时，必须先输入密码，之后有 5 分钟的有效期限，超过期限则必须重新输入密码 若其未经授权的用户企图使用 sudo，则会发出警告邮件给管理员 02. 组管理 终端命令 提示：创建组 / 删除组 的终端命令都需要通过 sudo 执行 序号 命令 作用 01 groupadd 组名 添加组 02 groupdel 组名 删除组 03 cat /etc/group 确认组信息 04 chgrp -R 组名 文件/目录名 递归修改文件/目录的所属组 提示： 组信息保存在 /etc/group 文件中 /etc 目录是专门用来保存 系统配置信息 的目录 ￼ 在实际应用中，可以预先针对 组 设置好权限，然后 将不同的用户添加到对应的组中，从而不用依次为每一个用户设置权限 演练目标 在 python 用户的桌面文件夹下创建 Python学习 目录 新建 dev 组 将 Python学习 目录的组修改为 dev 03. 用户管理 终端命令 提示：创建用户 / 删除用户 / 修改其他用户密码 的终端命令都需要通过 sudo 执行 3.1 创建用户／设置密码／删除用户 序号 命令 作用 说明 01 useradd -m -g 组 新建用户名 添加新用户 -m 自动建立用户家目录-g 指定用户所在的组，否则会建立一个和同名的组 02 passwd 用户名 设置用户密码 如果是普通用户，直接用 passwd 可以修改自己的账户密码 03 userdel -r 用户名 删除用户 -r 选项会自动删除用户家目录 04 cat /etc/passwd \\ grep 用户名 确认用户信息 新建用户后，用户信息会保存在 /etc/passwd 文件中 提示： 创建用户时，如果忘记添加 -m 选项指定新用户的家目录 —— 最简单的方法就是删除用户，重新创建 创建用户时，默认会创建一个和用户名同名的组名 用户信息保存在 /etc/passwd 文件中 3.2 查看用户信息 序号 命令 作用 01 id [用户名] 查看用户 UID 和 GID 信息 02 who 查看当前所有登录的用户列表 03 whoami 查看当前登录用户的账户名 passwd 文件 /etc/passwd 文件存放的是用户的信息，由 6 个分号组成的 7 个信息，分别是 用户名 密码（x，表示加密的密码） UID（用户标识） GID（组标识） 用户全名或本地帐号 家目录 登录使用的 Shell，就是登录之后，使用的终端命令，ubuntu 默认是 dash usermod usermod 可以用来设置 用户 的 主组 ／ 附加组 和 登录 Shell，命令格式如下： 主组：通常在新建用户时指定，在 etc/passwd 的第 4 列 GID 对应的组 附加组：在 etc/group 中最后一列表示该组的用户列表，用于指定 用户的附加权限 提示：设置了用户的附加组之后，需要重新登录才能生效！ # 修改用户的主组（passwd 中的 GID） usermod -g 组 用户名 # 修改用户的附加组 usermod -G 组 用户名 # 修改用户登录 Shell usermod -s /bin/bash 用户名 注意：默认使用 useradd 添加的用户是没有权限使用 sudo 以 root 身份执行命令的，可以使用以下命令，将用户添加到 sudo 附加组中 usermod -G sudo 用户名 which（重要） 提示 /etc/passwd 是用于保存用户信息的文件 /usr/bin/passwd 是用于修改用户密码的程序 which 命令可以查看执行命令所在位置，例如： which ls # 输出 # /bin/ls which useradd # 输出 # /usr/sbin/useradd bin 和 sbin 在 Linux 中，绝大多数可执行文件都是保存在 /bin、/sbin、/usr/bin、/usr/sbin /bin（binary）是二进制执行文件目录，主要用于具体应用 /sbin（system binary）是系统管理员专用的二进制代码存放目录，主要用于系统管理 /usr/bin（user commands for applications）后期安装的一些软件 /usr/sbin（super user commands for applications）超级用户的一些管理程序 提示： cd 这个终端命令是内置在系统内核中的，没有独立的文件，因此用 which 无法找到 cd 命令的位置 3.3 切换用户 序号 命令 作用 说明 01 su - 用户名 切换用户，并且切换目录 - 可以切换到用户家目录，否则保持位置不变 02 exit 退出当前登录账户 su 不接用户名，可以切换到 root，但是不推荐使用，因为不安全 exit 示意图如下： ￼ 04. 修改文件权限 序号 命令 作用 01 chown 修改拥有者 02 chgrp 修改组 03 chmod 修改权限 命令格式如下： # 修改文件|目录的拥有者 chown 用户名 文件名|目录名 # 递归修改文件|目录的组 chgrp -R 组名 文件名|目录名 # 递归修改文件权限 chmod -R 755 文件名|目录名 chmod 在设置权限时，可以简单地使用三个数字分别对应 拥有者 ／ 组 和 其他 用户的权限 # 直接修改文件|目录的 读|写|执行 权限，但是不能精确到 拥有者|组|其他 chmod +/-rwx 文件名|目录名 ￼ 常见数字组合有（ u 表示用户／ g 表示组／ o 表示其他）： 777 ===> u=rwx,g=rwx,o=rwx 755 ===> u=rwx,g=rx,o=rx 644 ===> u=rw,g=r,o=r chmod 演练目标 将 01.py 的权限修改为 u=rwx,g=rx,o=r 将 123.txt 的权限修改为 u=rw,g=r,o=- 将 test 目录以及目录下的 所有 文件权限修改为 u=rwx,g=rwx,o=rx Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/系统信息相关命令.html":{"url":"python/01/系统信息相关命令.html","title":"系统信息相关命令","keywords":"","body":"11_系统信息相关命令 本节内容主要是为了方便通过远程终端维护服务器时，查看服务器上当前 系统日期和时间 ／ 磁盘空间占用情况 ／ 程序执行情况 本小结学习的终端命令基本都是查询命令，通过这些命令对系统资源的使用情况有个了解 目标 时间和日期 date cal 磁盘和目录空间 df du 进程信息 ps top kill 01. 时间和日期 序号 命令 作用 01 date 查看系统时间 02 cal calendar 查看日历，-y 选项可以查看一年的日历 02. 磁盘信息 序号 命令 作用 01 df -h disk free 显示磁盘剩余空间 02 du -h [目录名] disk usage 显示目录下的文件大小 选项说明 参数 含义 -h 以人性化的方式显示文件大小 03. 进程信息 所谓 进程，通俗地说就是 当前正在执行的一个程序 序号 命令 作用 01 ps aux process status 查看进程的详细状况 02 top 动态显示运行中的进程并且排序 03 kill [-9] 进程代号 终止指定代号的进程，-9 表示强行终止 ps 默认只会显示当前用户通过终端启动的应用程序 ps 选项说明功能 选项 含义 a 显示终端上的所有进程，包括其他用户的进程 u 显示进程的详细状态 x 显示没有控制终端的进程 提示：使用 kill 命令时，最好只终止由当前用户开启的进程，而不要终止 root 身份开启的进程，否则可能导致系统崩溃 要退出 top 可以直接输入 q Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/01/其他命令.html":{"url":"python/01/其他命令.html","title":"其他命令","keywords":"","body":"12_其他命令 目标 查找文件 find 软链接 ln 打包和压缩 tar 软件安装 apt-get 01. 查找文件 find 命令功能非常强大，通常用来在 特定的目录下 搜索 符合条件的文件 序号 命令 作用 01 find [路径] -name \"*.py\" 查找指定路径下扩展名是 .py 的文件，包括子目录 如果省略路径，表示在当前文件夹下查找 之前学习的通配符，在使用 find 命令时同时可用 有关 find 的高级使用，在就业班会讲 演练目标 \\1. 搜索桌面目录下，文件名包含 1 的文件 find -name \"*1*\" \\2. 搜索桌面目录下，所有以 .txt 为扩展名的文件 find -name \"*.txt\" \\3. 搜索桌面目录下，以数字 1 开头的文件 find -name \"1*\" 02. 软链接 序号 命令 作用 01 ln -s 被链接的源文件 链接文件 建立文件的软链接，用通俗的方式讲类似于 Windows 下的快捷方式 注意： \\1. 没有 -s 选项建立的是一个 硬链接文件 两个文件占用相同大小的硬盘空间，工作中几乎不会建立文件的硬链接 \\2. 源文件要使用绝对路径，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用 演练目标 \\1. 将桌面目录下的 01.py 移动到 demo/b/c 目录下 \\2. 在桌面目录下新建 01.py 的 软链接 FirstPython 分别使用 相对路径 和 绝对路径 建立 FirstPython 的软链接 \\3. 将 FirstPython 移动到 demo 目录下，对比使用 相对路径 和 绝对路径 的区别 硬链接简介（知道） 在使用 ln 创建链接时，如果没有 -s 选项，会创建一个 硬链接，而不是软链接 硬链接演练 \\1. 在 ~/Desktop/demo 目录下建立 ~/Desktop/demo/b/c/01.py 的硬链接 01_hard \\2. 使用 ls -l 查看文件的硬链接数（硬链接——有多少种方式可以访问文件或者目录） \\3. 删除 ~/Desktop/demo/b/c/01.py，并且使用 tree 来确认 demo 目录下的三个链接文件 文件软硬链接的示意图 ￼ 在 Linux 中，文件名 和 文件的数据 是分开存储的 提示： 在 Linux 中，只有文件的 硬链接数 == 0 才会被删除 使用 ls -l 可以查看一个文件的硬链接的数量 在日常工作中，几乎不会建立文件的硬链接，知道即可 03. 打包压缩 打包压缩 是日常工作中备份文件的一种方式 在不同操作系统中，常用的打包压缩方式是不同的 Windows 常用 rar Mac 常用 zip Linux 常用 tar.gz 3.1 打包 ／ 解包 tar 是 Linux 中最常用的 备份工具，此命令可以 把一系列文件 打包到 一个大文件中，也可以把一个 打包的大文件恢复成一系列文件 tar 的命令格式如下： # 打包文件 tar -cvf 打包文件.tar 被打包的文件／路径... # 解包文件 tar -xvf 打包文件.tar tar 选项说明 选项 含义 c 生成档案文件，创建打包文件 x 解开档案文件 v 列出归档解档的详细过程，显示进度 f 指定档案文件名称，f 后面一定是 .tar 文件，所以必须放选项最后 注意：f 选项必须放在最后，其他选项顺序可以随意 打包解包演练 删除桌面下的所有内容 在桌面下新建三个空白文件 01.py、02.py、03.py 将这三个文件打一个 py.tar 的包 新建 tar 目录，并且将 py.tar 移动到 tar 目录下 解包 py.tar 3.2 压缩／解压缩 1) gzip tar 与 gzip 命令结合可以使用实现文件 打包和压缩 tar 只负责打包文件，但不压缩 用 gzip 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.gz 在 Linux 中，最常见的压缩文件格式就是 xxx.tar.gz 在 tar 命令中有一个选项 -z 可以调用 gzip，从而可以方便的实现压缩和解压缩的功能 命令格式如下： # 压缩文件 tar -zcvf 打包文件.tar.gz 被压缩的文件／路径... # 解压缩文件 tar -zxvf 打包文件.tar.gz # 解压缩到指定路径 tar -zxvf 打包文件.tar.gz -C 目标路径 选项 含义 -C 解压缩到指定目录，注意：要解压缩的目录必须存在 2) bzip2(two) tar 与 bzip2 命令结合可以使用实现文件 打包和压缩（用法和 gzip 一样） tar 只负责打包文件，但不压缩， 用 bzip2 压缩 tar 打包后的文件，其扩展名一般用 xxx.tar.bz2 在 tar 命令中有一个选项 -j 可以调用 bzip2，从而可以方便的实现压缩和解压缩的功能 命令格式如下： # 压缩文件 tar -jcvf 打包文件.tar.bz2 被压缩的文件／路径... # 解压缩文件 tar -jxvf 打包文件.tar.bz2 04. 软件安装 4.1 通过 apt 安装／卸载软件 apt 是 Advanced Packaging Tool，是 Linux 下的一款安装包管理工具 可以在终端中方便的 安装／卸载／更新软件包 # 1. 安装软件 $ sudo apt install 软件包 # 2. 卸载软件 $ sudo apt remove 软件名 # 3. 更新已安装的包 $ sudo apt upgrade 安装演练 # 一个小火车提示 $ sudo apt install sl # 一个比较漂亮的查看当前进程排名的软件 $ sudo apt install htop 4.2 配置软件源 如果希望在 ubuntu 中安装软件，更加快速，可以通过设置镜像源，选择一个访问网速更快的服务器，来提供软件下载／安装服务 提示：更换服务器之后，需要一个相对比较长时间的更新过程，需要耐心等待。更新完成后，再安装软件都会从新设置的服务器下载软件了 所谓镜像源，就是所有服务器的内容是相同的（镜像），但是根据所在位置不同，国内服务器通常速度会更快一些！ ￼ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/intro.html":{"url":"python/02/intro.html","title":"Python 基础","keywords":"","body":"linux基础 自学使用-黑马培训班上海37期 Python 侵删 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/认识Python.html":{"url":"python/02/认识Python.html","title":"认识 Python","keywords":"","body":"认识 Python 人生苦短，我用 Python —— Life is short, you need Python 目标 Python 的起源 为什么要用 Python？ Python 的特点 Python 的优缺点 01. Python 的起源 Python 的创始人为吉多·范罗苏姆（Guido van Rossum） 1989 年的圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间，决心开发一个新的解释程序，作为 ABC 语言的一种继承（感觉下什么叫牛人） ABC 是由吉多参加设计的一种教学语言，就吉多本人看来，ABC 这种语言非常优美和强大，是专门为非专业程序员设计的。但是 ABC 语言并没有成功，究其原因，吉多认为是非开放造成的。吉多决心在 Python 中避免这一错误，并获取了非常好的效果 之所以选中 Python（蟒蛇） 作为程序的名字，是因为他是 BBC 电视剧——蒙提·派森的飞行马戏团（Monty Python's Flying Circus）的爱好者 1991 年，第一个 Python 解释器 诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件 1.1 解释器（科普） 计算机不能直接理解任何除机器语言以外的语言，所以必须要把程序员所写的程序语言翻译成机器语言，计算机才能执行程序。将其他语言翻译成机器语言的工具，被称为编译器 编译器翻译的方式有两种：一个是编译，另外一个是解释。两种方式之间的区别在于翻译时间点的不同。当编译器以解释方式运行的时候，也称之为解释器 编译型语言：程序在执行之前需要一个专门的编译过程，把程序编译成为机器语言的文件，运行时不需要重新翻译，直接使用编译的结果就行了。程序执行效率高，依赖编译器，跨平台性差些。如 C、C++ 解释型语言：解释型语言编写的程序不进行预先编译，以文本方式存储程序代码，会将代码一句一句直接运行。在发布程序时，看起来省了道编译工序，但是在运行程序的时候，必须先解释再运行 编译型语言和解释型语言对比 速度 —— 编译型语言比解释型语言执行速度快 跨平台性 —— 解释型语言比编译型语言跨平台性好 1.2 Python 的设计目标 1999 年，吉多·范罗苏姆向 DARPA 提交了一条名为 “Computer Programming for Everybody” 的资金申请，并在后来说明了他对 Python 的目标： 一门简单直观的语言并与主要竞争者一样强大 开源，以便任何人都可以为它做贡献 代码像纯英语那样容易理解 适用于短期开发的日常任务 这些想法中的基本都已经成为现实，Python 已经成为一门流行的编程语言 1.3 Python 的设计哲学 优雅 明确 简单 在 Python 解释器内运行 `import this` 可以获得完整的列表 --> Python 开发者的哲学是：用一种方法，最好是只有一种方法来做一件事 如果面临多种选择，Python 开发者一般会拒绝花俏的语法，而选择明确没有或者很少有歧义的语法 在 Python 社区，吉多被称为“仁慈的独裁者” 02. 为什么选择 Python？ 代码量少 …… 同一样问题，用不同的语言解决，代码量差距还是很多的，一般情况下 Python 是 Java 的 1/5，所以说 人生苦短，我用 Python 03. Python 特点 Python 是完全面向对象的语言 函数、模块、数字、字符串都是对象，在 Python 中一切皆对象 完全支持继承、重载、多重继承 支持重载运算符，也支持泛型设计 Python 拥有一个强大的标准库，Python 语言的核心只包含 数字、字符串、列表、字典、文件 等常见类型和函数，而由 Python 标准库提供了 系统管理、网络通信、文本处理、数据库接口、图形系统、XML 处理 等额外的功能 Python 社区提供了大量的第三方模块，使用方式与标准库类似。它们的功能覆盖 科学计算、人工智能、机器学习、Web 开发、数据库接口、图形系统 多个领域 面向对象的思维方式 面向对象 是一种 思维方式，也是一门 程序设计技术 要解决一个问题前，首先考虑 由谁 来做，怎么做事情是 谁 的职责，最后把事情做好就行！ 对象 就是 谁 要解决复杂的问题，就可以找多个不同的对象，各司其职，共同实现，最终完成需求 04. Python 的优缺点 4.1 优点 简单、易学 免费、开源 面向对象 丰富的库 可扩展性 如果需要一段关键代码运行得更快或者希望某些算法不公开，可以把这部分程序用 C 或 C++ 编写，然后在 Python 程序中使用它们 …… 4.2 缺点 运行速度 国内市场较小 中文资料匮乏 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/第一个Python程序.html":{"url":"python/02/第一个Python程序.html","title":"第一个Python程序","keywords":"","body":"第一个 Python 程序 目标 第一个 HelloPython 程序 Python 2.x 与 3​​.x 版本简介 执行 Python 程序的三种方式 解释器 —— python / python3 交互式 —— ipython 集成开发环境 —— PyCharm 01. 第一个 HelloPython 程序 1.1 Python 源程序的基本概念 Python 源程序就是一个特殊格式的文本文件，可以使用任意文本编辑软件做 Python 的开发 Python 程序的 文件扩展名 通常都是 .py 1.2 演练步骤 在桌面下，新建 认识Python 目录 在 认识Python 目录下新建 01-HelloPython.py 文件 使用 gedit 编辑 01-HelloPython.py 并且输入以下内容： print(\"hello python\") print(\"hello world\") 在终端中输入以下命令执行 01-HelloPython.py $ python 01-HelloPython.py print 是 python 中我们学习的第一个 函数 print 函数的作用，可以把 \"\" 内部的内容，输出到屏幕上 1.3 演练扩展 —— 认识错误（BUG） 关于错误 编写的程序不能正常执行，或者执行的结果不是我们期望的 俗称 BUG，是程序员在开发时非常常见的，初学者常见错误的原因包括： 手误 对已经学习过的知识理解还存在不足 对语言还有需要学习和提升的内容 在学习语言时，不仅要学会语言的语法，而且还要学会如何认识错误和解决错误的方法 每一个程序员都是在不断地修改错误中成长的 第一个演练中的常见错误 1> 手误，例如使用 pirnt(\"Hello world\") NameError: name 'pirnt' is not defined 名称错误：'pirnt' 名字没有定义 2> 将多条 print 写在一行 SyntaxError: invalid syntax 语法错误：语法无效 每行代码负责完成一个动作 3> 缩进错误 IndentationError: unexpected indent 缩进错误：不期望出现的缩进 Python 是一个格式非常严格的程序设计语言 目前而言，大家记住每行代码前面都不要增加空格 4> python 2.x 默认不支持中文 目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x Python 2.x 默认不支持中文，具体原因，等到介绍 字符编码 时给大家讲解 Python 2.x 的解释器名称是 python Python 3.x 的解释器名称是 python3 SyntaxError: Non-ASCII character '\\xe4' in file 01-HelloPython.py on line 3, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 语法错误： 在 01-HelloPython.py 中第 3 行出现了非 ASCII 字符 '\\xe4'，但是没有声明文件编码 请访问 http://python.org/dev/peps/pep-0263/ 了解详细信息 ASCII 字符只包含 256 个字符，不支持中文 有关字符编码的问题，后续会讲 单词列表 * error 错误 * name 名字 * defined 已经定义 * syntax 语法 * invalid 无效 * Indentation 索引 * unexpected 意外的，不期望的 * character 字符 * line 行 * encoding 编码 * declared 声明 * details 细节，详细信息 * ASCII 一种字符编码 02. Python 2.x 与 3​​.x 版本简介 目前市场上有两个 Python 的版本并存着，分别是 Python 2.x 和 Python 3.x 新的 Python 程序建议使用 Python 3.0 版本的语法 Python 2.x 是 过去的版本 解释器名称是 python Python 3.x 是 现在和未来 主流的版本 解释器名称是 python3 相对于 Python 的早期版本，这是一个 较大的升级 为了不带入过多的累赘，Python 3.0 在设计的时候 没有考虑向下兼容 许多早期 Python 版本设计的程序都无法在 Python 3.0 上正常执行 Python 3.0 发布于 2008 年 到目前为止，Python 3.0 的稳定版本已经有很多年了 Python 3.3 发布于 2012 Python 3.4 发布于 2014 Python 3.5 发布于 2015 Python 3.6 发布于 2016 为了照顾现有的程序，官方提供了一个过渡版本 —— Python 2.6 基本使用了 Python 2.x 的语法和库 同时考虑了向 Python 3.0 的迁移，允许使用部分 Python 3.0 的语法与函数 2010 年中推出的 Python 2.7 被确定为 最后一个Python 2.x 版本 提示：如果开发时，无法立即使用 Python 3.0（还有极少的第三方库不支持 3.0 的语法），建议 先使用 Python 3.0 版本进行开发 然后使用 Python 2.6、Python 2.7 来执行，并且做一些兼容性的处理 03. 执行 Python 程序的三种方式 3.1. 解释器 python / python3 Python 的解释器 # 使用 python 2.x 解释器 $ python xxx.py # 使用 python 3.x 解释器 $ python3 xxx.py 其他解释器（知道） Python 的解释器 如今有多个语言的实现，包括： CPython —— 官方版本的 C 语言实现 Jython —— 可以运行在 Java 平台 IronPython —— 可以运行在 .NET 和 Mono 平台 PyPy —— Python 实现的，支持 JIT 即时编译 3.2. 交互式运行 Python 程序 直接在终端中运行解释器，而不输入要执行的文件名 在 Python 的 Shell 中直接输入 Python 的代码，会立即看到程序执行结果 1) 交互式运行 Python 的优缺点 优点 适合于学习/验证 Python 语法或者局部代码 缺点 代码不能保存 不适合运行太大的程序 2) 退出 官方的解释器 1> 直接输入 exit() >>> exit() 2> 使用热键退出 在 python 解释器中，按热键 ctrl + d 可以退出解释器 3) IPython IPython 中 的 “I” 代表 交互 interactive 特点 IPython 是一个 python 的 交互式 shell，比默认的 python shell 好用得多 支持自动补全 自动缩进 支持 bash shell 命令 内置了许多很有用的功能和函数 IPython 是基于 BSD 开源的 版本 Python 2.x 使用的解释器是 ipython Python 3.x 使用的解释器是 ipython3 要退出解释器可以有以下两种方式： 1> 直接输入 exit In [1]: exit 2> 使用热键退出 在 IPython 解释器中，按热键 ctrl + d，IPython 会询问是否退出解释器 IPython 的安装 $ sudo apt install ipython 3.3. Python 的 IDE —— PyCharm 1） 集成开发环境（IDE） 集成开发环境（IDE，Integrated Development Environment）—— 集成了开发软件需要的所有工具，一般包括以下工具： 图形用户界面 代码编辑器（支持 代码补全／自动缩进） 编译器／解释器 调试器（断点／单步执行） …… 2）PyCharm 介绍 PyCharm 是 Python 的一款非常优秀的集成开发环境 PyCharm 除了具有一般 IDE 所必备功能外，还可以在 Windows、Linux、macOS 下使用 PyCharm 适合开发大型项目 一个项目通常会包含 很多源文件 每个 源文件 的代码行数是有限的，通常在几百行之内 每个 源文件 各司其职，共同完成复杂的业务功能 3）PyCharm 快速体验 文件导航区域 能够 浏览／定位／打开 项目文件 文件编辑区域 能够 编辑 当前打开的文件 控制台区域 能够： 输出程序执行内容 跟踪调试代码的执行 右上角的 工具栏 能够 执行(SHIFT + F10) / 调试(SHIFT + F9) 代码 通过控制台上方的单步执行按钮(F8)，可以单步执行代码 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/PyCharm的初始设置（知道）.html":{"url":"python/02/PyCharm的初始设置（知道）.html","title":"PyCharm 的初始设置（知道）","keywords":"","body":"PyCharm 的初始设置（知道） 目标 恢复 PyCharm 的初始设置 第一次启动 PyCharm 新建一个 Python 项目 设置 PyCharm 的字体显示 PyCharm 的升级以及其他 PyCharm 的官方网站地址是：https://www.jetbrains.com/pycharm/ 01. 恢复 PyCharm 的初始设置 PyCharm 的 配置信息 是保存在 用户家目录下 的 .PyCharmxxxx.x 目录下的，xxxx.x 表示当前使用的 PyCharm 的版本号 如果要恢复 PyCharm 的初始设置，可以按照以下步骤进行： 关闭正在运行的 PyCharm 在终端中执行以下终端命令，删除 PyCharm 的配置信息目录： $ rm -r ~/.PyCharm2016.3 重新启动 PyCharm 02. 第一次启动 PyCharm 导入配置信息 选择许可协议 配置初始界面 2.1 导入配置信息 在第一次启动 PyCharm 时，会首先提示用户是否导入 之前的配置信息 如果是第一次使用，直接点击 OK 按钮 2.2 选择许可协议 PyCharm 是一个付费软件，购买费用为 199$ / 年 或者 19.90$ ／ 月 不过 PyCharm 提供了对 学生和教师免费使用的版本 下载地址是：https://www.jetbrains.com/pycharm-edu/download/#section=linux 商业版本会提示输入注册信息，或者选择免费评估 2.3 PyCharm 的配置初始界面 在初始配置界面，可以通过 Editor colors and fonts 选择 编辑器的配色方案 2.4 欢迎界面 所有基础配置工作结束之后，就可以看到 PyCharm 的 欢迎界面了，通过 欢迎界面 就可以开始开发 Python 项目了 03. 新建/打开一个 Python 项目 3.1 项目简介 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 3.2 打开 Python 项目 直接点击 Open 按钮，然后浏览到之前保存 Python 文件的目录，既可以打开项目 打开之后，会在目录下新建一个 .idea 的目录，用于保存 项目相关的信息，例如：解释器版本、项目包含的文件等等 第一次打开项目，需要耐心等待 PyCharm 对项目进行初始设置 设置项目使用的解释器版本 打开的目录如果不是由 PyCharm 建立的项目目录，有的时候 使用的解释器版本是 Python 2.x 的，需要单独设置解释器的版本 通过 File / Settings... 可以打开设置窗口，如下图所示： 3.3 新建项目 1) 命名规则 以后 项目名 前面都以 数字编号，随着知识点递增，编号递增 例如：01_Python 基础、02_分支、03_循环... 每个项目下的 文件名 都以 hm_xx_知识点 方式来命名 其中 xx 是演练文件的序号 注意 命名文件名时建议只使用 小写字母、数字 和 下划线 文件名不能以数字开始 通过 欢迎界面 或者菜单 File / New Project 可以新建项目 2) 演练步骤 新建 01_Python基础 项目，使用 Python 3.x 解释器 在项目下新建 hm_01_hello.py Python 文件 编写 print(\"Hello Python\") 代码 04. 设置 PyCharm 的字体显示 05. PyCharm 的升级以及其他 PyCharm 提供了对 学生和教师免费使用的版本 教育版下载地址：https://www.jetbrains.com/pycharm-edu/download/#section=linux 专业版下载地址：https://www.jetbrains.com/pycharm/download/#section=linux 5.1 安装和启动步骤 执行以下终端命令，解压缩下载后的安装包 $ tar -zxvf pycharm-professional-2017.1.3.tar.gz 将解压缩后的目录移动到 /opt 目录下，可以方便其他用户使用 /opt 目录用户存放给主机额外安装的软件 $ sudo mv pycharm-2017.1.3/ /opt/ 切换工作目录 $ cd /opt/pycharm-2017.1.3/bin 启动 PyCharm $ ./pycharm.sh 5.2 设置专业版启动图标 在专业版中，选择菜单 Tools / Create Desktop Entry... 可以设置任务栏启动图标 注意：设置图标时，需要勾选 Create the entry for all users 5.3 卸载之前版本的 PyCharm 1) 程序安装 程序文件目录 将安装包解压缩，并且移动到 /opt 目录下 所有的相关文件都保存在解压缩的目录中 配置文件目录 启动 PyCharm 后，会在用户家目录下建立一个 .PyCharmxxx 的隐藏目录 保存 PyCharm 相关的配置信息 快捷方式文件 /usr/share/applications/jetbrains-pycharm.desktop 在 ubuntu 中，应用程序启动的快捷方式通常都保存在 /usr/share/applications 目录下 2) 程序卸载 要卸载 PyCharm 只需要做以下两步工作： 删除解压缩目录 $ sudo rm -r /opt/pycharm-2016.3.1/ 删除家目录下用于保存配置信息的隐藏目录 $ rm -r ~/.PyCharm2016.3/ 如果不再使用 PyCharm 还需要将 /usr/share/applications/ 下的 jetbrains-pycharm.desktop 删掉 5.4 教育版安装演练 # 1. 解压缩下载后的安装包 $ tar -zxvf pycharm-edu-3.5.1.tar.gz # 2. 将解压缩后的目录移动到 `/opt` 目录下，可以方便其他用户使用 $ sudo mv pycharm-edu-3.5.1/ /opt/ # 3. 启动 `PyCharm` /opt/pycharm-edu-3.5.1/bin/pycharm.sh 后续课程都使用专业版本演练 设置启动图标 编辑快捷方式文件 $ sudo gedit /usr/share/applications/jetbrains-pycharm.desktop 按照以下内容修改文件内容，需要注意指定正确的 pycharm 目录 [Desktop Entry] Version=1.0 Type=Application Name=PyCharm Icon=/opt/pycharm-edu-3.5.1/bin/pycharm.png Exec=\"/opt/pycharm-edu-3.5.1/bin/pycharm.sh\" %f Comment=The Drive to Develop Categories=Development;IDE; Terminal=false StartupWMClass=jetbrains-pycharm Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/多文件项目的演练.html":{"url":"python/02/多文件项目的演练.html","title":"多文件项目的演练","keywords":"","body":"多文件项目的演练 开发 项目 就是开发一个 专门解决一个复杂业务功能的软件 通常每 一个项目 就具有一个 独立专属的目录，用于保存 所有和项目相关的文件 一个项目通常会包含 很多源文件 目标 在项目中添加多个文件，并且设置文件的执行 多文件项目演练 在 01_Python基础 项目中新建一个 hm_02_第2个Python程序.py 在 hm_02_第2个Python程序.py 文件中添加一句 print(\"hello\") 点击右键执行 hm_02_第2个Python程序.py 提示 在 PyCharm 中，要想让哪一个 Python 程序能够执行，必须首先通过 鼠标右键的方式执行 一下 对于初学者而言，在一个项目中设置多个程序可以执行，是非常方便的，可以方便对不同知识点的练习和测试 对于商业项目而言，通常在一个项目中，只有一个 可以直接执行的 Python 源程序 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/注释.html":{"url":"python/02/注释.html","title":"注释","keywords":"","body":"注释 目标 注释的作用 单行注释（行注释） 多行注释（块注释） 01. 注释的作用 使用用自己熟悉的语言，在程序中对某些代码进行标注说明，增强程序的可读性 02. 单行注释(行注释) 以 # 开头，# 右边的所有东西都被当做说明文字，而不是真正要执行的程序，只起到辅助说明作用 示例代码如下： # 这是第一个单行注释 print(\"hello python\") 为了保证代码的可读性，# 后面建议先添加一个空格，然后再编写相应的说明文字 在代码后面增加的单行注释 在程序开发时，同样可以使用 # 在代码的后面（旁边）增加说明性的文字 但是，需要注意的是，为了保证代码的可读性，注释和代码之间 至少要有 两个空格 示例代码如下： print(\"hello python\") # 输出 `hello python` 03. 多行注释（块注释） 如果希望编写的 注释信息很多，一行无法显示，就可以使用多行注释 要在 Python 程序中使用多行注释，可以用 一对 连续的 三个 引号(单引号和双引号都可以) 示例代码如下： \"\"\" 这是一个多行注释 在多行注释之间，可以写很多很多的内容…… \"\"\" print(\"hello python\") 什么时候需要使用注释？ 注释不是越多越好，对于一目了然的代码，不需要添加注释 对于 复杂的操作，应该在操作开始前写上若干行注释 对于 不是一目了然的代码，应在其行尾添加注释（为了提高可读性，注释应该至少离开代码 2 个空格） 绝不要描述代码，假设阅读代码的人比你更懂 Python，他只是不知道你的代码要做什么 在一些正规的开发团队，通常会有 代码审核 的惯例，就是一个团队中彼此阅读对方的代码 关于代码规范 Python 官方提供有一系列 PEP（Python Enhancement Proposals） 文档 其中第 8 篇文档专门针对 Python 的代码格式 给出了建议，也就是俗称的 PEP 8 文档地址：https://www.python.org/dev/peps/pep-0008/ 谷歌有对应的中文文档：http://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/ 任何语言的程序员，编写出符合规范的代码，是开始程序生涯的第一步 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/算数运算符.html":{"url":"python/02/算数运算符.html","title":"算数运算符","keywords":"","body":"算数运算符 计算机，顾名思义就是负责进行 数学计算 并且 存储计算结果 的电子设备 目标 算术运算符的基本使用 01. 算数运算符 算数运算符是 运算符的一种 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 In [1]: \"-\" * 50 Out[1]: '----------------------------------------' 02. 算数运算符的优先级 和数学中的运算符的优先级一致，在 Python 中进行数学计算时，同样也是： 先乘除后加减 同级运算符是 从左至右 计算 可以使用 () 调整计算的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 例如： 2 + 3 * 5 = 17 (2 + 3) * 5 = 25 2 * 3 + 5 = 11 2 * (3 + 5) = 16 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/程序执行原理（科普）.html":{"url":"python/02/程序执行原理（科普）.html","title":"程序执行原理（科普）","keywords":"","body":"程序执行原理（科普） 目标 计算机中的 三大件 程序执行的原理 程序的作用 01. 计算机中的三大件 计算机中包含有较多的硬件，但是一个程序要运行，有 三个 核心的硬件，分别是： CPU 中央处理器，是一块超大规模的集成电路 负责 处理数据／计算 内存 临时 存储数据（断电之后，数据会消失） 速度快 空间小（单位价格高） 硬盘 永久 存储数据 速度慢 空间大（单位价格低） CPU 内存 硬盘 思考题 计算机中哪一个硬件设备负责执行程序？ CPU 内存 的速度快还是 硬盘 的速度快？ 内存 我们的程序是安装在内存中的，还是安装在硬盘中的？ 硬盘 我买了一个内存条，有 500G 的空间！！！，这句话对吗？ 不对，内存条通常只有 4G / 8G / 16G / 32G 计算机关机之后，内存中的数据都会消失，这句话对吗？ 正确 02. 程序执行的原理 程序 运行之前，程序是 保存在硬盘 中的 当要运行一个程序时 操作系统会首先让 CPU 把程序复制到 内存 中 CPU 执行 内存 中的 程序代码 程序要执行，首先要被加载到内存 2.1 Python 程序执行原理 操作系统会首先让 CPU 把 Python 解释器 的程序复制到 内存 中 Python 解释器 根据语法规则，从上向下 让 CPU 翻译 Python 程序中的代码 CPU 负责执行翻译完成的代码 Python 的解释器有多大？ 执行以下终端命令可以查看 Python 解释器的大小 # 1. 确认解释器所在位置 $ which python # 2. 查看 python 文件大小(只是一个软链接) $ ls -lh /usr/bin/python # 3. 查看具体文件大小 $ ls -lh /usr/bin/python2.7 提示：建立 软链接 的目的，是为了方便使用者不用记住使用的解释器是 哪一个具体版本 03. 程序的作用 程序就是 用来处理数据 的！ 新闻软件 提供的 新闻内容、评论…… 是数据 电商软件 提供的 商品信息、配送信息…… 是数据 运动类软件 提供的 运动数据…… 是数据 地图类软件 提供的 地图信息、定位信息、车辆信息…… 是数据 即时通讯软件 提供的 聊天信息、好友信息…… 是数据 …… 3.1 思考 QQ 程序的启动过程 QQ 在运行之前，是保存在 硬盘 中的 运行之后，QQ 程序就会被加载到 内存 中了 3.2 思考 QQ 程序的 登录 过程 读取用户输入的 QQ 号码 读取用户输入的 QQ 密码 将 QQ 号码 和 QQ 密码 发送给腾讯的服务器，等待服务器确认用户信息 思考 1 在 QQ 这个程序将 QQ 号码 和 QQ 密码 发送给服务器之前，是否需要先存储一下 QQ 号码 和 密码? 答案 肯定需要！—— 否则 QQ 这个程序就不知道把什么内容发送给服务器了！ 思考 2 QQ 这个程序把 QQ 号码 和 QQ 密码 保存在哪里？ 答案 保存在 内存 中，因为 QQ 程序自己就在内存中 思考 3 QQ 这个程序是怎么保存用户的 QQ 号码 和 QQ 密码 的？ 答案 在内存中为 QQ 号码 和 QQ 密码 各自分配一块空间 在 QQ 程序结束之前，这两块空间是由 QQ 程序负责管理的，其他任何程序都不允许使用 在 QQ 自己使用完成之前，这两块空间始终都只负责保存 QQ 号码 和 QQ 密码 使用一个 别名 标记 QQ 号码 和 QQ 密码 在内存中的位置 在程序内部，为 QQ 号码 和 QQ 密码 在内存中分配的空间就叫做 变量 程序就是用来处理数据的，而变量就是用来存储数据的 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/变量的基本使用.html":{"url":"python/02/变量的基本使用.html","title":"变量的基本使用","keywords":"","body":"变量的基本使用 程序就是用来处理数据的，而变量就是用来存储数据的 目标 变量定义 变量的类型 变量的命名 01. 变量定义 在 Python 中，每个变量 在使用前都必须赋值，变量 赋值以后 该变量 才会被创建 等号（=）用来给变量赋值 = 左边是一个变量名 = 右边是存储在变量中的值 变量名 = 值 变量定义之后，后续就可以直接使用了 1) 变量演练1 —— iPython # 定义 qq_number 的变量用来保存 qq 号码 In [1]: qq_number = \"1234567\" # 输出 qq_number 中保存的内容 In [2]: qq_number Out[2]: '1234567' # 定义 qq_password 的变量用来保存 qq 密码 In [3]: qq_password = \"123\" # 输出 qq_password 中保存的内容 In [4]: qq_password Out[4]: '123' 使用交互式方式，如果要查看变量内容，直接输入变量名即可，不需要使用 print 函数 2) 变量演练 2 —— PyCharm # 定义 qq 号码变量 qq_number = \"1234567\" # 定义 qq 密码变量 qq_password = \"123\" # 在程序中，如果要输出变量的内容，需要使用 print 函数 print(qq_number) print(qq_password) 使用解释器执行，如果要输出变量的内容，必须要要使用 print 函数 3) 变量演练 3 —— 超市买苹果 可以用 其他变量的计算结果 来定义变量 变量定义之后，后续就可以直接使用了 需求 苹果的价格是 8.5 元/斤 买了 7.5 斤 苹果 计算付款金额 # 定义苹果价格变量 price = 8.5 # 定义购买重量 weight = 7.5 # 计算金额 money = price * weight print(money) 思考题 如果 只要买苹果，就返 5 块钱 请重新计算购买金额 # 定义苹果价格变量 price = 8.5 # 定义购买重量 weight = 7.5 # 计算金额 money = price * weight # 只要买苹果就返 5 元 money = money - 5 print(money) 提问 上述代码中，一共定义有几个变量？ 三个：price／weight／money money = money - 5 是在定义新的变量还是在使用变量？ 直接使用之前已经定义的变量 变量名 只有在 第一次出现 才是 定义变量 变量名 再次出现，不是定义变量，而是直接使用之前定义过的变量 在程序开发中，可以修改之前定义变量中保存的值吗？ 可以 变量中存储的值，就是可以 变 的 02. 变量的类型 在内存中创建一个变量，会包括： 变量的名称 变量保存的数据 变量存储数据的类型 变量的地址（标示） 2.1 变量类型的演练 —— 个人信息 需求 定义变量保存小明的个人信息 姓名：小明 年龄：18 岁 性别：是男生 身高：1.75 米 体重：75.0 公斤 利用 单步调试 确认变量中保存数据的类型 提问 在演练中，一共有几种数据类型？ 4 种 str —— 字符串 bool —— 布尔（真假） int —— 整数 float —— 浮点数（小数） 在 Python 中定义变量时需要指定类型吗？ 不需要 Python 可以根据 = 等号右侧的值，自动推导出变量中存储数据的类型 2.2 变量的类型 在 Python 中定义变量是 不需要指定类型（在其他很多高级语言中都需要） 数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 提示：在 Python 2.x 中，整数 根据保存数值的长度还分为： int（整数） long（长整数） 使用 type 函数可以查看一个变量的类型 In [1]: type(name) 2.3 不同类型变量之间的计算 1) 数字型变量 之间可以直接计算 在 Python 中，两个数字型变量是可以直接进行 算数运算的 如果变量是 bool 型，在计算时 True 对应的数字是 1 False 对应的数字是 0 演练步骤 定义整数 i = 10 定义浮点数 f = 10.5 定义布尔型 b = True 在 iPython 中，使用上述三个变量相互进行算术运算 2) 字符串变量 之间使用 + 拼接字符串 在 Python 中，字符串之间可以使用 + 拼接生成新的字符串 In [1]: first_name = \"三\" In [2]: last_name = \"张\" In [3]: first_name + last_name Out[3]: '三张' 3) 字符串变量 可以和 整数 使用 * 重复拼接相同的字符串 In [1]: \"-\" * 50 Out[1]: '--------------------------------------------------' 4) 数字型变量 和 字符串 之间 不能进行其他计算 In [1]: first_name = \"zhang\" In [2]: x = 10 In [3]: x + first_name --------------------------------------------------------------------------- TypeError: unsupported operand type(s) for +: 'int' and 'str' 类型错误：`+` 不支持的操作类型：`int` 和 `str` 2.4 变量的输入 所谓 输入，就是 用代码 获取 用户通过 键盘 输入的信息 例如：去银行取钱，在 ATM 上输入密码 在 Python 中，如果要获取用户在 键盘 上的输入信息，需要使用到 input 函数 1) 关于函数 一个 提前准备好的功能(别人或者自己写的代码)，可以直接使用，而 不用关心内部的细节 目前已经学习过的函数 函数 说明 print(x) 将 x 输出到控制台 type(x) 查看 x 的变量类型 2) input 函数实现键盘输入 在 Python 中可以使用 input 函数从键盘等待用户的输入 用户输入的 任何内容 Python 都认为是一个 字符串 语法如下： 字符串变量 = input(\"提示信息：\") 3) 类型转换函数 函数 说明 int(x) 将 x 转换为一个整数 float(x) 将 x 转换到一个浮点数 4) 变量输入演练 —— 超市买苹果增强版 需求 收银员输入 苹果的价格，单位：元／斤 收银员输入 用户购买苹果的重量，单位：斤 计算并且 输出 付款金额 演练方式 1 # 1. 输入苹果单价 price_str = input(\"请输入苹果价格：\") # 2. 要求苹果重量 weight_str = input(\"请输入苹果重量：\") # 3. 计算金额 # 1> 将苹果单价转换成小数 price = float(price_str) # 2> 将苹果重量转换成小数 weight = float(weight_str) # 3> 计算付款金额 money = price * weight print(money) 提问 演练中，针对 价格 定义了几个变量？ 两个 price_str 记录用户输入的价格字符串 price 记录转换后的价格数值 思考 —— 如果开发中，需要用户通过控制台 输入 很多个 数字，针对每一个数字都要定义两个变量，方便吗？ 演练方式 2 —— 买苹果改进版 定义 一个 浮点变量 接收用户输入的同时，就使用 float 函数进行转换 price = float(input(\"请输入价格:\")) 改进后的好处： 节约空间，只需要为一个变量分配空间 起名字方便，不需要为中间变量起名字 改进后的“缺点”： 初学者需要知道，两个函数能够嵌套使用，稍微有一些难度 提示 如果输入的不是一个数字，程序执行时会出错，有关数据转换的高级话题，后续会讲！ 2.5 变量的格式化输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 在 Python 中可以使用 print 函数将信息输出到控制台 如果希望输出文字信息的同时，一起输出 数据，就需要使用到 格式化操作符 % 被称为 格式化操作符，专门用于处理字符串中的格式 包含 % 的字符串，被称为 格式化字符串 % 和不同的 字符 连用，不同类型的数据 需要使用 不同的格式化字符 格式化字符 含义 %s 字符串 %d 有符号十进制整数，%06d 表示输出的整数显示位数，不足的地方使用 0 补全 %f 浮点数，%.2f 表示小数点后只显示两位 %% 输出 % 语法格式如下： print(\"格式化字符串\" % 变量1) print(\"格式化字符串\" % (变量1, 变量2...)) 格式化输出演练 —— 基本练习 需求 定义字符串变量 name，输出 我的名字叫 小明，请多多关照！ 定义整数变量 student_no，输出 我的学号是 000001 定义小数 price、weight、money，输出 苹果单价 9.00 元／斤，购买了 5.00 斤，需要支付 45.00 元 定义一个小数 scale，输出 数据比例是 10.00% print(\"我的名字叫 %s，请多多关照！\" % name) print(\"我的学号是 %06d\" % student_no) print(\"苹果单价 %.02f 元／斤，购买 %.02f 斤，需要支付 %.02f 元\" % (price, weight, money)) print(\"数据比例是 %.02f%%\" % (scale * 100)) 课后练习 —— 个人名片 需求 在控制台依次提示用户输入：姓名、公司、职位、电话、邮箱 按照以下格式输出： ************************************************** 公司名称 姓名 (职位) 电话：电话 邮箱：邮箱 ************************************************** 实现代码如下： \"\"\" 在控制台依次提示用户输入：姓名、公司、职位、电话、电子邮箱 \"\"\" name = input(\"请输入姓名：\") company = input(\"请输入公司：\") title = input(\"请输入职位：\") phone = input(\"请输入电话：\") email = input(\"请输入邮箱：\") print(\"*\" * 50) print(company) print() print(\"%s (%s)\" % (name, title)) print() print(\"电话：%s\" % phone) print(\"邮箱：%s\" % email) print(\"*\" * 50) Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/变量的命名.html":{"url":"python/02/变量的命名.html","title":"变量的命名","keywords":"","body":"变量的命名 目标 标识符和关键字 变量的命名规则 0.1 标识符和关键字 1.1 标识符 标示符就是程序员定义的 变量名、函数名 名字 需要有 见名知义 的效果，见下图： 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 思考：下面的标示符哪些是正确的，哪些不正确为什么？ fromNo12 from#12 my_Boolean my-Boolean Obj2 2ndObj myInt My_tExt _test test!32 haha(da)tt jack_rose jack&rose GUI G.U.I 1.2 关键字 关键字 就是在 Python 内部已经使用的标识符 关键字 具有特殊的功能和含义 开发者 不允许定义和关键字相同的名字的标示符 通过以下命令可以查看 Python 中的关键字 In [1]: import keyword In [2]: print(keyword.kwlist) 提示：关键字的学习及使用，会在后面的课程中不断介绍 import 关键字 可以导入一个 “工具包” 在 Python 中不同的工具包，提供有不同的工具 02. 变量的命名规则 命名规则 可以被视为一种 惯例，并无绝对与强制 目的是为了 增加代码的识别和可读性 注意 Python 中的 标识符 是 区分大小写的 在定义变量时，为了保证代码格式，= 的左右应该各保留一个空格 在 Python 中，如果 变量名 需要由 二个 或 多个单词 组成时，可以按照以下方式命名 每个单词都使用小写字母 单词与单词之间使用 _下划线 连接 例如：first_name、last_name、qq_number、qq_password 驼峰命名法 当 变量名 是由二个或多个单词组成时，还可以利用驼峰命名法来命名 小驼峰式命名法 第一个单词以小写字母开始，后续单词的首字母大写 例如：firstName、lastName 大驼峰式命名法 每一个单词的首字母都采用大写字母 例如：FirstName、LastName、CamelCase Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/判断（if）语句.html":{"url":"python/02/判断（if）语句.html","title":"判断（if）语句","keywords":"","body":"判断（if）语句 目标 开发中的应用场景 if 语句体验 if 语句进阶 综合应用 01. 开发中的应用场景 生活中的判断几乎是无所不在的，我们每天都在做各种各样的选择，如果这样？如果那样？…… 程序中的判断 if 今天发工资: 先还信用卡的钱 if 有剩余: 又可以happy了，O(∩_∩)O哈哈~ else: 噢，no。。。还的等30天 else: 盼着发工资 判断的定义 如果 条件满足，才能做某件事情， 如果 条件不满足，就做另外一件事情，或者什么也不做 正是因为有了判断，才使得程序世界丰富多彩，充满变化！ 判断语句 又被称为 “分支语句”，正是因为有了判断，才让程序有了很多的分支 02. if 语句体验 2.1 if 判断语句基本语法 在 Python 中，if 语句 就是用来进行判断的，格式如下： if 要判断的条件: 条件成立时，要做的事情 …… 注意：代码的缩进为一个 tab 键，或者 4 个空格 —— 建议使用空格 在 Python 开发中，Tab 和空格不要混用！ 我们可以把整个 if 语句看成一个完整的代码块 2.2 判断语句演练 —— 判断年龄 需求 定义一个整数变量记录年龄 判断是否满 18 岁 （>=） 如果满 18 岁，允许进网吧嗨皮 # 1. 定义年龄变量 age = 18 # 2. 判断是否满 18 岁 # if 语句以及缩进部分的代码是一个完整的代码块 if age >= 18: print(\"可以进网吧嗨皮……\") # 3. 思考！- 无论条件是否满足都会执行 print(\"这句代码什么时候执行?\") 注意： if 语句以及缩进部分是一个 完整的代码块 2.3 else 处理条件不满足的情况 思考 在使用 if 判断时，只能做到满足条件时要做的事情。那如果需要在 不满足条件的时候，做某些事情，该如何做呢？ 答案 else，格式如下： if 要判断的条件: 条件成立时，要做的事情 …… else: 条件不成立时，要做的事情 …… 注意： if 和 else 语句以及各自的缩进部分共同是一个 完整的代码块 2.4 判断语句演练 —— 判断年龄改进 需求 输入用户年龄 判断是否满 18 岁 （>=） 如果满 18 岁，允许进网吧嗨皮 如果未满 18 岁，提示回家写作业 # 1. 输入用户年龄 age = int(input(\"今年多大了？\")) # 2. 判断是否满 18 岁 # if 语句以及缩进部分的代码是一个完整的语法块 if age >= 18: print(\"可以进网吧嗨皮……\") else: print(\"你还没长大，应该回家写作业！\") # 3. 思考！- 无论条件是否满足都会执行 print(\"这句代码什么时候执行?\") 03. 逻辑运算 在程序开发中，通常 在判断条件时，会需要同时判断多个条件 只有多个条件都满足，才能够执行后续代码，这个时候需要使用到 逻辑运算符 逻辑运算符 可以把 多个条件 按照 逻辑 进行 连接，变成 更复杂的条件 Python 中的 逻辑运算符 包括：与 and／或 or／非 not 三种 3.1 and 条件1 and 条件2 与／并且 两个条件同时满足，返回 True 只要有一个不满足，就返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 不成立 不成立 成立 不成立 不成立 不成立 不成立 3.2 or 条件1 or 条件2 或／或者 两个条件只要有一个满足，返回 True 两个条件都不满足，返回 False 条件 1 条件 2 结果 成立 成立 成立 成立 不成立 成立 不成立 成立 成立 不成立 不成立 不成立 3.3 not not 条件 非／不是 条件 结果 成立 不成立 不成立 成立 逻辑运算演练 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确 要求人的年龄在 0-120 之间 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩 要求只要有一门成绩 > 60 分就算合格 练习3: 定义一个布尔型变量 is_employee，编写代码判断是否是本公司员工 如果不是提示不允许入内 答案 1： # 练习1: 定义一个整数变量 age，编写代码判断年龄是否正确 age = 100 # 要求人的年龄在 0-120 之间 if age >= 0 and age 答案 2： # 练习2: 定义两个整数变量 python_score、c_score，编写代码判断成绩 python_score = 50 c_score = 50 # 要求只要有一门成绩 > 60 分就算合格 if python_score > 60 or c_score > 60: print(\"考试通过\") else: print(\"再接再厉！\") 答案 3： # 练习3: 定义一个布尔型变量 `is_employee`，编写代码判断是否是本公司员工 is_employee = True # 如果不是提示不允许入内 if not is_employee: print(\"非公勿内\") 04. if 语句进阶 4.1 elif 在开发中，使用 if 可以 判断条件 使用 else 可以处理 条件不成立 的情况 但是，如果希望 再增加一些条件，条件不同，需要执行的代码也不同 时，就可以使用 elif 语法格式如下： if 条件1: 条件1满足执行的代码 …… elif 条件2: 条件2满足时，执行的代码 …… elif 条件3: 条件3满足时，执行的代码 …… else: 以上条件都不满足时，执行的代码 …… 对比逻辑运算符的代码 if 条件1 and 条件2: 条件1满足 并且 条件2满足 执行的代码 …… 注意 elif 和 else 都必须和 if 联合使用，而不能单独使用 可以将 if、elif 和 else 以及各自缩进的代码，看成一个 完整的代码块 elif 演练 —— 女友的节日 需求 定义 holiday_name 字符串变量记录节日名称 如果是 情人节 应该 买玫瑰／看电影 如果是 平安夜 应该 买苹果／吃大餐 如果是 生日 应该 买蛋糕 其他的日子每天都是节日啊…… holiday_name = \"平安夜\" if holiday_name == \"情人节\": print(\"买玫瑰\") print(\"看电影\") elif holiday_name == \"平安夜\": print(\"买苹果\") print(\"吃大餐\") elif holiday_name == \"生日\": print(\"买蛋糕\") else: print(\"每天都是节日啊……\") 4.2 if 的嵌套 elif 的应用场景是：同时 判断 多个条件，所有的条件是 平级 的 在开发中，使用 if 进行条件判断，如果希望 在条件成立的执行语句中 再 增加条件判断，就可以使用 if 的嵌套 if 的嵌套 的应用场景就是：在之前条件满足的前提下，再增加额外的判断 if 的嵌套 的语法格式，除了缩进之外 和之前的没有区别 语法格式如下： if 条件 1: 条件 1 满足执行的代码 …… if 条件 1 基础上的条件 2: 条件 2 满足时，执行的代码 …… # 条件 2 不满足的处理 else: 条件 2 不满足时，执行的代码 # 条件 1 不满足的处理 else: 条件1 不满足时，执行的代码 …… if 的嵌套 演练 —— 火车站安检 需求 定义布尔型变量 has_ticket 表示是否有车票 定义整型变量 knife_length 表示刀的长度，单位：厘米 首先检查是否有车票，如果有，才允许进行 安检 安检时，需要检查刀的长度，判断是否超过 20 厘米 如果超过 20 厘米，提示刀的长度，不允许上车 如果不超过 20 厘米，安检通过 如果没有车票，不允许进门 # 定义布尔型变量 has_ticket 表示是否有车票 has_ticket = True # 定义整数型变量 knife_length 表示刀的长度，单位：厘米 knife_length = 20 # 首先检查是否有车票，如果有，才允许进行 安检 if has_ticket: print(\"有车票，可以开始安检...\") # 安检时，需要检查刀的长度，判断是否超过 20 厘米 # 如果超过 20 厘米，提示刀的长度，不允许上车 if knife_length >= 20: print(\"不允许携带 %d 厘米长的刀上车\" % knife_length) # 如果不超过 20 厘米，安检通过 else: print(\"安检通过，祝您旅途愉快……\") # 如果没有车票，不允许进门 else: print(\"大哥，您要先买票啊\") 05. 综合应用 —— 石头剪刀布 目标 强化 多个条件 的 逻辑运算 体会 import 导入模块（“工具包”）的使用 需求 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3） 电脑 随机 出拳 —— 先假定电脑只会出石头，完成整体代码功能 比较胜负 序号 规则 1 石头 胜 剪刀 2 剪刀 胜 布 3 布 胜 石头 5.1 基础代码实现 先 假定电脑就只会出石头，完成整体代码功能 # 从控制台输入要出的拳 —— 石头（1）／剪刀（2）／布（3） player = int(input(\"请出拳 石头（1）／剪刀（2）／布（3）：\")) # 电脑 随机 出拳 - 假定电脑永远出石头 computer = 1 # 比较胜负 # 如果条件判断的内容太长，可以在最外侧的条件增加一对大括号 # 再在每一个条件之间，使用回车，PyCharm 可以自动增加 8 个空格 if ((player == 1 and computer == 2) or (player == 2 and computer == 3) or (player == 3 and computer == 1)): print(\"噢耶！！！电脑弱爆了！！！\") elif player == computer: print(\"心有灵犀，再来一盘！\") else: print(\"不行，我要和你决战到天亮！\") 5.2 随机数的处理 在 Python 中，要使用随机数，首先需要导入 随机数 的 模块 —— “工具包” import random 导入模块后，可以直接在 模块名称 后面敲一个 . 然后按 Tab 键，会提示该模块中包含的所有函数 random.randint(a, b) ，返回 [a, b] 之间的整数，包含 a 和 b 例如： random.randint(12, 20) # 生成的随机数n: 12 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/运算符.html":{"url":"python/02/运算符.html","title":"运算符","keywords":"","body":"运算符 目标 算数运算符 比较（关系）运算符 逻辑运算符 赋值运算符 运算符的优先级 数学符号表链接：https://zh.wikipedia.org/wiki/数学符号表 01. 算数运算符 是完成基本的算术运算使用的符号，用来处理四则运算 运算符 描述 实例 + 加 10 + 20 = 30 - 减 10 - 20 = -10 * 乘 10 * 20 = 200 / 除 10 / 20 = 0.5 // 取整除 返回除法的整数部分（商） 9 // 2 输出结果 4 % 取余数 返回除法的余数 9 % 2 = 1 ** 幂 又称次方、乘方，2 ** 3 = 8 在 Python 中 * 运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果 In [1]: \"-\" * 50 Out[1]: '----------------------------------------' 02. 比较（关系）运算符 运算符 描述 == 检查两个操作数的值是否 相等，如果是，则条件成立，返回 True != 检查两个操作数的值是否 不相等，如果是，则条件成立，返回 True > 检查左操作数的值是否 大于 右操作数的值，如果是，则条件成立，返回 True 检查左操作数的值是否 小于 右操作数的值，如果是，则条件成立，返回 True >= 检查左操作数的值是否 大于或等于 右操作数的值，如果是，则条件成立，返回 True 检查左操作数的值是否 小于或等于 右操作数的值，如果是，则条件成立，返回 True Python 2.x 中判断 不等于 还可以使用 <> 运算符 != 在 Python 2.x 中同样可以用来判断 不等于 03. 逻辑运算符 运算符 逻辑表达式 描述 and x and y 只有 x 和 y 的值都为 True，才会返回 True否则只要 x 或者 y 有一个值为 False，就返回 False or x or y 只要 x 或者 y 有一个值为 True，就返回 True只有 x 和 y 的值都为 False，才会返回 False not not x 如果 x 为 True，返回 False如果 x 为 False，返回 True 04. 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 05. 运算符的优先级 以下表格的算数优先级由高到最低顺序排列 运算符 描述 ** 幂 (最高优先级) * / % // 乘、除、取余数、取整除 + - 加法、减法 >= 比较运算符 == != 等于运算符 = %= /= //= -= += = *= 赋值运算符 not or and 逻辑运算符 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/循环.html":{"url":"python/02/循环.html","title":"循环","keywords":"","body":"循环 目标 程序的三大流程 while 循环基本使用 break 和 continue while 循环嵌套 01. 程序的三大流程 在程序开发中，一共有三种流程方式： 顺序 —— 从上向下，顺序执行代码 分支 —— 根据条件判断，决定执行代码的 分支 循环 —— 让 特定代码 重复 执行 02. while 循环基本使用 循环的作用就是让 指定的代码 重复的执行 while 循环最常用的应用场景就是 让执行的代码 按照 指定的次数 重复 执行 需求 —— 打印 5 遍 Hello Python 思考 —— 如果要求打印 100 遍怎么办？ 2.1 while 语句基本语法 初始条件设置 —— 通常是重复执行的 计数器 while 条件(判断 计数器 是否达到 目标次数): 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件(计数器 + 1) 注意： while 语句以及缩进部分是一个 完整的代码块 第一个 while 循环 需求 打印 5 遍 Hello Python # 1. 定义重复次数计数器 i = 1 # 2. 使用 while 判断条件 while i 注意：循环结束后，之前定义的计数器条件的数值是依旧存在的 死循环 由于程序员的原因，忘记 在循环内部 修改循环的判断条件，导致循环持续执行，程序无法终止！ 2.2 赋值运算符 在 Python 中，使用 = 可以给变量赋值 在算术运算时，为了简化代码的编写，Python 还提供了一系列的 与 算术运算符 对应的 赋值运算符 注意：赋值运算符中间不能使用空格 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c = a 等效于 c = c a /= 除法赋值运算符 c /= a 等效于 c = c / a //= 取整除赋值运算符 c //= a 等效于 c = c // a %= 取 模 (余数)赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c = a 等效于 c = c a 2.3 Python 中的计数方法 常见的计数方法有两种，可以分别称为： 自然计数法（从 1 开始）—— 更符合人类的习惯 程序计数法（从 0 开始）—— 几乎所有的程序语言都选择从 0 开始计数 因此，大家在编写程序时，应该尽量养成习惯：除非需求的特殊要求，否则 循环 的计数都从 0 开始 2.4 循环计算 在程序开发中，通常会遇到 利用循环 重复计算 的需求 遇到这种需求，可以： 在 while 上方定义一个变量，用于 存放最终计算结果 在循环体内部，每次循环都用 最新的计算结果，更新 之前定义的变量 需求 计算 0 ~ 100 之间所有数字的累计求和结果 # 计算 0 ~ 100 之间所有数字的累计求和结果 # 0. 定义最终结果的变量 result = 0 # 1. 定义一个整数的变量记录循环的次数 i = 0 # 2. 开始循环 while i 需求进阶 计算 0 ~ 100 之间 所有 偶数 的累计求和结果 开发步骤 编写循环 确认 要计算的数字 添加 结果 变量，在循环内部 处理计算结果 # 0. 最终结果 result = 0 # 1. 计数器 i = 0 # 2. 开始循环 while i 03. break 和 continue break 和 continue 是专门在循环中使用的关键字 break 某一条件满足时，退出循环，不再执行后续重复的代码 continue 某一条件满足时，不执行后续重复的代码 break 和 continue 只针对 当前所在循环 有效 3.1 break 在循环过程中，如果 某一个条件满足后，不 再希望 循环继续执行，可以使用 break 退出循环 i = 0 while i break 只针对当前所在循环有效 3.2 continue 在循环过程中，如果 某一个条件满足后，不 希望 执行循环代码，但是又不希望退出循环，可以使用 continue 也就是：在整个循环中，只有某些条件，不需要执行循环代码，而其他条件都需要执行 i = 0 while i 需要注意：使用 continue 时，条件处理部分的代码，需要特别注意，不小心会出现 死循环 continue 只针对当前所在循环有效 04. while 循环嵌套 4.1 循环嵌套 while 嵌套就是：while 里面还有 while while 条件 1: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... while 条件 2: 条件满足时，做的事情1 条件满足时，做的事情2 条件满足时，做的事情3 ...(省略)... 处理条件 2 处理条件 1 4.2 循环嵌套演练 —— 九九乘法表 第 1 步：用嵌套打印小星星 需求 在控制台连续输出五行 *，每一行星号的数量依次递增 * ** *** **** ***** 使用字符串 * 打印 # 1. 定义一个计数器变量，从数字1开始，循环会比较方便 row = 1 while row 第 2 步：使用循环嵌套打印小星星 知识点 对 print 函数的使用做一个增强 在默认情况下，print 函数输出内容之后，会自动在内容末尾增加换行 如果不希望末尾增加换行，可以在 print 函数输出内容的后面增加 , end=\"\" 其中 \"\" 中间可以指定 print 函数输出内容之后，继续希望显示的内容 语法格式如下： # 向控制台输出内容结束之后，不会换行 print(\"*\", end=\"\") # 单纯的换行 print(\"\") end=\"\" 表示向控制台输出内容结束之后，不会换行 假设 Python 没有提供 字符串的 * 操作 拼接字符串 需求 在控制台连续输出五行 *，每一行星号的数量依次递增 * ** *** **** ***** 开发步骤 1> 完成 5 行内容的简单输出 2> 分析每行内部的 * 应该如何处理？ 每行显示的星星和当前所在的行数是一致的 嵌套一个小的循环，专门处理每一行中 列 的星星显示 row = 1 while row 第 3 步： 九九乘法表 需求 输出 九九乘法表，格式如下： 1 * 1 = 1 1 * 2 = 2 2 * 2 = 4 1 * 3 = 3 2 * 3 = 6 3 * 3 = 9 1 * 4 = 4 2 * 4 = 8 3 * 4 = 12 4 * 4 = 16 1 * 5 = 5 2 * 5 = 10 3 * 5 = 15 4 * 5 = 20 5 * 5 = 25 1 * 6 = 6 2 * 6 = 12 3 * 6 = 18 4 * 6 = 24 5 * 6 = 30 6 * 6 = 36 1 * 7 = 7 2 * 7 = 14 3 * 7 = 21 4 * 7 = 28 5 * 7 = 35 6 * 7 = 42 7 * 7 = 49 1 * 8 = 8 2 * 8 = 16 3 * 8 = 24 4 * 8 = 32 5 * 8 = 40 6 * 8 = 48 7 * 8 = 56 8 * 8 = 64 1 * 9 = 9 2 * 9 = 18 3 * 9 = 27 4 * 9 = 36 5 * 9 = 45 6 * 9 = 54 7 * 9 = 63 8 * 9 = 72 9 * 9 = 81 开发步骤 打印 9 行小星星 * ** *** **** ***** ****** ******* ******** ********* 将每一个 * 替换成对应的行与列相乘 # 定义起始行 row = 1 # 最大打印 9 行 while row 字符串中的转义字符 \\t 在控制台输出一个 制表符，协助在输出文本时 垂直方向 保持对齐 \\n 在控制台输出一个 换行符 制表符 的功能是在不使用表格的情况下在 垂直方向 按列对齐文本 转义字符 描述 \\\\ 反斜杠符号 \\' 单引号 \\\" 双引号 \\n 换行 \\t 横向制表符 \\r 回车 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/函数基础.html":{"url":"python/02/函数基础.html","title":"函数基础","keywords":"","body":"函数基础 目标 函数的快速体验 函数的基本使用 函数的参数 函数的返回值 函数的嵌套调用 在模块中定义函数 01. 函数的快速体验 1.1 快速体验 所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的使用包含两个步骤： 定义函数 —— 封装 独立的功能 调用函数 —— 享受 封装 的成果 函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用 演练步骤 新建 04_函数 项目 复制之前完成的 乘法表 文件 修改文件，增加函数定义 multiple_table(): 新建另外一个文件，使用 import 导入并且调用函数 02. 函数基本使用 2.1 函数的定义 定义函数的格式如下： def 函数名(): 函数封装的代码 …… def 是英文 define 的缩写 函数名称 应该能够表达 函数封装代码 的功能，方便后续的调用 函数名称 的命名应该 符合 标识符的命名规则 可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 2.2 函数调用 调用函数很简单的，通过 函数名() 即可完成对函数的调用 2.3 第一个函数演练 需求 编写一个打招呼 say_hello 的函数，封装三行打招呼的代码 在函数下方调用打招呼的代码 name = \"小明\" # 解释器知道这里定义了一个函数 def say_hello(): print(\"hello 1\") print(\"hello 2\") print(\"hello 3\") print(name) # 只有在调用函数时，之前定义的函数才会被执行 # 函数执行完成之后，会重新回到之前的程序中，继续执行后续的代码 say_hello() print(name) 用 单步执行 F8 和 F7 观察以下代码的执行过程 定义好函数之后，只表示这个函数封装了一段代码而已 如果不主动调用函数，函数是不会主动执行的 思考 能否将 函数调用 放在 函数定义 的上方？ 不能！ 因为在 使用函数名 调用函数之前，必须要保证 Python 已经知道函数的存在 否则控制台会提示 NameError: name 'say_hello' is not defined (名称错误：say_hello 这个名字没有被定义) 2.4 PyCharm 的调试工具 F8 Step Over 可以单步执行代码，会把函数调用看作是一行代码直接执行 F7 Step Into 可以单步执行代码，如果是函数，会进入函数内部 2.5 函数的文档注释 在开发中，如果希望给函数添加注释，应该在 定义函数 的下方，使用 连续的三对引号 在 连续的三对引号 之间编写对函数的说明文字 在 函数调用 位置，使用快捷键 CTRL + Q 可以查看函数的说明信息 注意：因为 函数体相对比较独立，函数定义的上方，应该和其他代码（包括注释）保留 两个空行 03. 函数的参数 演练需求 开发一个 sum_2_num 的函数 函数能够实现 两个数字的求和 功能 演练代码如下： def sum_2_num(): num1 = 10 num2 = 20 result = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, result)) sum_2_num() 思考一下存在什么问题 函数只能处理 固定数值 的相加 如何解决？ 如果能够把需要计算的数字，在调用函数时，传递到函数内部就好了！ 3.1 函数参数的使用 在函数名的后面的小括号内部填写 参数 多个参数之间使用 , 分隔 def sum_2_num(num1, num2): result = num1 + num2 print(\"%d + %d = %d\" % (num1, num2, result)) sum_2_num(50, 20) 3.2 参数的作用 函数，把 具有独立功能的代码块 组织为一个小模块，在需要的时候 调用 函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够 适应更多的数据 在函数 内部，把参数当做 变量 使用，进行需要的数据处理 函数调用时，按照函数定义的参数顺序，把 希望在函数内部处理的数据，通过参数 传递 3.3 形参和实参 形参：定义 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用 实参：调用 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的 04. 函数的返回值 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 注意：return 表示返回，后续的代码都不会被执行 def sum_2_num(num1, num2): \"\"\"对两个数字的求和\"\"\" return num1 + num2 # 调用函数，并使用 result 变量接收计算结果 result = sum_2_num(10, 20) print(\"计算结果是 %d\" % result) 05. 函数的嵌套调用 一个函数里面 又调用 了 另外一个函数，这就是 函数嵌套调用 如果函数 test2 中，调用了另外一个函数 test1 那么执行到调用 test1 函数时，会先把函数 test1 中的任务都执行完 才会回到 test2 中调用函数 test1 的位置，继续执行后续的代码 def test1(): print(\"*\" * 50) print(\"test 1\") print(\"*\" * 50) def test2(): print(\"-\" * 50) print(\"test 2\") test1() print(\"-\" * 50) test2() 函数嵌套的演练 —— 打印分隔线 体会一下工作中 需求是多变 的 需求 1 定义一个 print_line 函数能够打印 * 组成的 一条分隔线 def print_line(char): print(\"*\" * 50) 需求 2 定义一个函数能够打印 由任意字符组成 的分隔线 def print_line(char): print(char * 50) 需求 3 定义一个函数能够打印 任意重复次数 的分隔线 def print_line(char, times): print(char * times) 需求 4 定义一个函数能够打印 5 行 的分隔线，分隔线要求符合需求 3 提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数！ def print_line(char, times): print(char * times) def print_lines(char, times): row = 0 while row 06. 使用模块中的函数 模块是 Python 程序架构的一个核心概念 模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入 import 这个模块 每一个以扩展名 py 结尾的 Python 源代码文件都是一个 模块 在模块中定义的 全局变量 、 函数 都是模块能够提供给外界直接使用的工具 6.1 第一个模块体验 步骤 新建 hm_10_分隔线模块.py 复制 hm_09_打印多条分隔线.py 中的内容，最后一行 print 代码除外 增加一个字符串变量 name = \"黑马程序员\" 新建 hm_10_体验模块.py 文件，并且编写以下代码： import hm_10_分隔线模块 hm_10_分隔线模块.print_line(\"-\", 80) print(hm_10_分隔线模块.name) 体验小结 可以 在一个 Python 文件 中 定义 变量 或者 函数 然后在 另外一个文件中 使用 import 导入这个模块 导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，使用这个模块中定义的变量或者函数 模块可以让 曾经编写过的代码 方便的被 复用！ 6.2 模块名也是一个标识符 标示符可以由 字母、下划线 和 数字 组成 不能以数字开头 不能与关键字重名 注意：如果在给 Python 文件起名时，以数字开头 是无法在 PyCharm 中通过导入这个模块的 6.3 Pyc 文件（了解） C 是 compiled 编译过 的意思 操作步骤 浏览程序目录会发现一个 __pycache__ 的目录 目录下会有一个 hm_10_分隔线模块.cpython-35.pyc 文件，cpython-35 表示 Python 解释器的版本 这个 pyc 文件是由 Python 解释器将 模块的源码 转换为 字节码 Python 这样保存 字节码 是作为一种启动 速度的优化 字节码 Python 在解释源程序时是分成两个步骤的 首先处理源代码，编译 生成一个二进制 字节码 再对 字节码 进行处理，才会生成 CPU 能够识别的 机器码 有了模块的字节码文件之后，下一次运行程序时，如果在 上次保存字节码之后 没有修改过源代码，Python 将会加载 .pyc 文件并跳过编译这个步骤 当 Python 重编译时，它会自动检查源文件和字节码文件的时间戳 如果你又修改了源代码，下次程序运行时，字节码将自动重新创建 提示：有关模块以及模块的其他导入方式，后续课程还会逐渐展开！ 模块是 Python 程序架构的一个核心概念 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/高级变量类型.html":{"url":"python/02/高级变量类型.html","title":"高级变量类型","keywords":"","body":"高级变量类型 目标 列表 元组 字典 字符串 公共方法 变量高级 知识点回顾 Python 中数据类型可以分为 数字型 和 非数字型 数字型 整型 (int) 浮点型（float） 布尔型（bool） 真 True 非 0 数 —— 非零即真 假 False 0 复数型 (complex) 主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题 非数字型 字符串 列表 元组 字典 在 Python 中，所有 非数字型变量 都支持以下特点： 都是一个 序列 sequence，也可以理解为 容器 取值 [] 遍历 for in 计算长度、最大/最小值、比较、删除 链接 + 和 重复 * 切片 01. 列表 1.1 列表的定义 List（列表） 是 Python 中使用 最频繁 的数据类型，在其他语言中通常叫做 数组 专门用于存储 一串 信息 列表用 [] 定义，数据 之间使用 , 分隔 列表的 索引 从 0 开始 索引 就是数据在 列表 中的位置编号，索引 又可以被称为 下标 注意：从列表中取值时，如果 超出索引范围，程序会报错 name_list = [\"zhangsan\", \"lisi\", \"wangwu\"] 1.2 列表常用操作 在 ipython3 中定义一个 列表，例如：name_list = [] 输入 name_list. 按下 TAB 键，ipython 会提示 列表 能够使用的 方法 如下： In [1]: name_list. name_list.append name_list.count name_list.insert name_list.reverse name_list.clear name_list.extend name_list.pop name_list.sort name_list.copy name_list.index name_list.remove 序号 分类 关键字 / 函数 / 方法 说明 1 增加 列表.insert(索引, 数据) 在指定位置插入数据 列表.append(数据) 在末尾追加数据 列表.extend(列表2) 将列表2 的数据追加到列表 2 修改 列表[索引] = 数据 修改指定索引的数据 3 删除 del 列表[索引] 删除指定索引的数据 列表.remove[数据] 删除第一个出现的指定数据 列表.pop 删除末尾数据 列表.pop(索引) 删除指定索引数据 列表.clear 清空列表 4 统计 len(列表) 列表长度 列表.count(数据) 数据在列表中出现的次数 5 排序 列表.sort() 升序排序 列表.sort(reverse=True) 降序排序 列表.reverse() 逆序、反转 del 关键字（科普） 使用 del 关键字(delete) 同样可以删除列表中元素 del 关键字本质上是用来 将一个变量从内存中删除的 如果使用 del 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了 del name_list[1] 在日常开发中，要从列表删除数据，建议 使用列表提供的方法 关键字、函数和方法（科普） 关键字 是 Python 内置的、具有特殊意义的标识符 In [1]: import keyword In [2]: print(keyword.kwlist) In [3]: print(len(keyword.kwlist)) 关键字后面不需要使用括号 函数 封装了独立功能，可以直接调用 函数名(参数) 函数需要死记硬背 方法 和函数类似，同样是封装了独立的功能 方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作 对象.方法名(参数) 在变量后面输入 .，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多 1.3 循环遍历 遍历 就是 从头到尾 依次 从 列表 中获取数据 在 循环体内部 针对 每一个元素，执行相同的操作 在 Python 中为了提高列表的遍历效率，专门提供的 迭代 iteration 遍历 使用 for 就能够实现迭代遍历 # for 循环内部使用的变量 in 列表 for name in name_list: 循环内部针对列表元素进行操作 print(name) 1.4 应用场景 尽管 Python 的 列表 中可以 存储不同类型的数据 但是在开发中，更多的应用场景是 列表 存储相同类型的数据 通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作 02. 元组 2.1 元组的定义 Tuple（元组）与列表类似，不同之处在于元组的 元素不能修改 元组 表示多个元素组成的序列 元组 在 Python 开发中，有特定的应用场景 用于存储 一串 信息，数据 之间使用 , 分隔 元组用 () 定义 元组的 索引 从 0 开始 索引 就是数据在 元组 中的位置编号 info_tuple = (\"zhangsan\", 18, 1.75) 创建空元组 info_tuple = () 元组中 只包含一个元素 时，需要 在元素后面添加逗号 info_tuple = (50, ) 2.2 元组常用操作 在 ipython3 中定义一个 元组，例如：info = () 输入 info. 按下 TAB 键，ipython 会提示 元组 能够使用的函数如下： info.count info.index 有关 元组 的 常用操作 可以参照上图练习 2.3 循环遍历 取值 就是从 元组 中获取存储在指定位置的数据 遍历 就是 从头到尾 依次 从 元组 中获取数据 # for 循环内部使用的变量 in 元组 for item in info: 循环内部针对元组元素进行操作 print(item) 在 Python 中，可以使用 for 循环遍历所有非数字型类型的变量：列表、元组、字典 以及 字符串 提示：在实际开发中，除非 能够确认元组中的数据类型，否则针对元组的循环遍历需求并不是很多 2.4 应用场景 尽管可以使用 for in 遍历 元组 但是在开发中，更多的应用场景是： 函数的 参数 和 返回值，一个函数可以接收 任意多个参数，或者 一次返回多个数据 有关 函数的参数 和 返回值，在后续 函数高级 给大家介绍 格式字符串，格式化字符串后面的 () 本质上就是一个元组 让列表不可以被修改，以保护数据安全 info = (\"zhangsan\", 18) print(\"%s 的年龄是 %d\" % info) 元组和列表之间的转换 使用 list 函数可以把元组转换成列表 list(元组) 使用 tuple 函数可以把列表转换成元组 tuple(列表) 03. 字典 3.1 字典的定义 dictionary（字典） 是 除列表以外 Python 之中 最灵活 的数据类型 字典同样可以用来 存储多个数据 通常用于存储 描述一个 物体 的相关信息 和列表的区别 列表 是 有序 的对象集合 字典 是 无序 的对象集合 字典用 {} 定义 字典使用 键值对 存储数据，键值对之间使用 , 分隔 键 key 是索引 值 value 是数据 键 和 值 之间使用 : 分隔 键必须是唯一的 值 可以取任何数据类型，但 键 只能使用 字符串、数字或 元组 xiaoming = {\"name\": \"小明\", \"age\": 18, \"gender\": True, \"height\": 1.75} 3.2 字典常用操作 在 ipython3 中定义一个 字典，例如：xiaoming = {} 输入 xiaoming. 按下 TAB 键，ipython 会提示 字典 能够使用的函数如下： In [1]: xiaoming. xiaoming.clear xiaoming.items xiaoming.setdefault xiaoming.copy xiaoming.keys xiaoming.update xiaoming.fromkeys xiaoming.pop xiaoming.values xiaoming.get xiaoming.popitem 有关 字典 的 常用操作 可以参照上图练习 3.3 循环遍历 遍历 就是 依次 从 字典 中获取所有键值对 # for 循环内部使用的 `key 的变量` in 字典 for k in xiaoming: print(\"%s: %s\" % (k, xiaoming[k])) 提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多 3.4 应用场景 尽管可以使用 for in 遍历 字典 但是在开发中，更多的应用场景是： 使用 多个键值对，存储 描述一个 物体 的相关信息 —— 描述更复杂的数据信息 将 多个字典 放在 一个列表 中，再进行遍历，在循环体内部针对每一个字典进行 相同的处理 card_list = [{\"name\": \"张三\", \"qq\": \"12345\", \"phone\": \"110\"}, {\"name\": \"李四\", \"qq\": \"54321\", \"phone\": \"10086\"} ] 04. 字符串 4.1 字符串的定义 字符串 就是 一串字符，是编程语言中表示文本的数据类型 在 Python 中可以使用 一对双引号 \" 或者 一对单引号 ' 定义一个字符串 虽然可以使用 \\\" 或者 \\' 做字符串的转义，但是在实际开发中： 如果字符串内部需要使用 \"，可以使用 ' 定义字符串 如果字符串内部需要使用 '，可以使用 \" 定义字符串 可以使用 索引 获取一个字符串中 指定位置的字符，索引计数从 0 开始 也可以使用 for 循环遍历 字符串中每一个字符 大多数编程语言都是用 \" 来定义字符串 string = \"Hello Python\" for c in string: print(c) 4.2 字符串的常用操作 在 ipython3 中定义一个 字符串，例如：hello_str = \"\" 输入 hello_str. 按下 TAB 键，ipython 会提示 字符串 能够使用的 方法 如下： In [1]: hello_str. hello_str.capitalize hello_str.isidentifier hello_str.rindex hello_str.casefold hello_str.islower hello_str.rjust hello_str.center hello_str.isnumeric hello_str.rpartition hello_str.count hello_str.isprintable hello_str.rsplit hello_str.encode hello_str.isspace hello_str.rstrip hello_str.endswith hello_str.istitle hello_str.split hello_str.expandtabs hello_str.isupper hello_str.splitlines hello_str.find hello_str.join hello_str.startswith hello_str.format hello_str.ljust hello_str.strip hello_str.format_map hello_str.lower hello_str.swapcase hello_str.index hello_str.lstrip hello_str.title hello_str.isalnum hello_str.maketrans hello_str.translate hello_str.isalpha hello_str.partition hello_str.upper hello_str.isdecimal hello_str.replace hello_str.zfill hello_str.isdigit hello_str.rfind 提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！ 1) 判断类型 - 9 方法 说明 string.isspace() 如果 string 中只包含空格，则返回 True string.isalnum() 如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True string.isalpha() 如果 string 至少有一个字符并且所有字符都是字母则返回 True string.isdecimal() 如果 string 只包含数字则返回 True，全角数字 string.isdigit() 如果 string 只包含数字则返回 True，全角数字、⑴、\\u00b2 string.isnumeric() 如果 string 只包含数字则返回 True，全角数字，汉字数字 string.istitle() 如果 string 是标题化的(每个单词的首字母大写)则返回 True string.islower() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True string.isupper() 如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True 2) 查找和替换 - 7 方法 说明 string.startswith(str) 检查字符串是否是以 str 开头，是则返回 True string.endswith(str) 检查字符串是否是以 str 结束，是则返回 True string.find(str, start=0, end=len(string)) 检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 -1 string.rfind(str, start=0, end=len(string)) 类似于 find()，不过是从右边开始查找 string.index(str, start=0, end=len(string)) 跟 find() 方法类似，不过如果 str 不在 string 会报错 string.rindex(str, start=0, end=len(string)) 类似于 index()，不过是从右边开始 string.replace(old_str, new_str, num=string.count(old)) 把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次 3) 大小写转换 - 5 方法 说明 string.capitalize() 把字符串的第一个字符大写 string.title() 把字符串的每个单词首字母大写 string.lower() 转换 string 中所有大写字符为小写 string.upper() 转换 string 中的小写字母为大写 string.swapcase() 翻转 string 中的大小写 4) 文本对齐 - 3 方法 说明 string.ljust(width) 返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串 string.rjust(width) 返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串 string.center(width) 返回一个原字符串居中，并使用空格填充至长度 width 的新字符串 5) 去除空白字符 - 3 方法 说明 string.lstrip() 截掉 string 左边（开始）的空白字符 string.rstrip() 截掉 string 右边（末尾）的空白字符 string.strip() 截掉 string 左右两边的空白字符 6) 拆分和连接 - 5 方法 说明 string.partition(str) 把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面) string.rpartition(str) 类似于 partition() 方法，不过是从右边开始查找 string.split(str=\"\", num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\\r', '\\t', '\\n' 和空格 string.splitlines() 按照行('\\r', '\\n', '\\r\\n')分隔，返回一个包含各行作为元素的列表 string.join(seq) 以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串 字符串的切片 切片 方法适用于 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 字符串[开始索引:结束索引:步长] 注意： 指定的区间属于 左闭右开 型 [开始索引, 结束索引) => 开始索引 >= 范围 从 起始 位开始，到 结束位的前一位 结束（不包含结束位本身) 从头开始，开始索引 数字可以省略，冒号不能省略 到末尾结束，结束索引 数字可以省略，冒号不能省略 步长默认为 1，如果连续切片，数字和冒号都可以省略 索引的顺序和倒序 在 Python 中不仅支持 顺序索引，同时还支持 倒序索引 所谓倒序索引就是 从右向左 计算索引 最右边的索引值是 -1，依次递减 演练需求 截取从 2 ~ 5 位置 的字符串 截取从 2 ~ 末尾 的字符串 截取从 开始 ~ 5 位置 的字符串 截取完整的字符串 从开始位置，每隔一个字符截取字符串 从索引 1 开始，每隔一个取一个 截取从 2 ~ 末尾 - 1 的字符串 截取字符串末尾两个字符 字符串的逆序（面试题） 答案 num_str = \"0123456789\" # 1. 截取从 2 ~ 5 位置 的字符串 print(num_str[2:6]) # 2. 截取从 2 ~ `末尾` 的字符串 print(num_str[2:]) # 3. 截取从 `开始` ~ 5 位置 的字符串 print(num_str[:6]) # 4. 截取完整的字符串 print(num_str[:]) # 5. 从开始位置，每隔一个字符截取字符串 print(num_str[::2]) # 6. 从索引 1 开始，每隔一个取一个 print(num_str[1::2]) # 倒序切片 # -1 表示倒数第一个字符 print(num_str[-1]) # 7. 截取从 2 ~ `末尾 - 1` 的字符串 print(num_str[2:-1]) # 8. 截取字符串末尾两个字符 print(num_str[-2:]) # 9. 字符串的逆序（面试题） print(num_str[::-1]) 05. 公共方法 5.1 Python 内置函数 Python 包含了以下内置函数： 函数 描述 备注 len(item) 计算容器中元素个数 del(item) 删除变量 del 有两种方式 max(item) 返回容器中元素最大值 如果是字典，只针对 key 比较 min(item) 返回容器中元素最小值 如果是字典，只针对 key 比较 cmp(item1, item2) 比较两个值，-1 小于/0 相等/1 大于 Python 3.x 取消了 cmp 函数 注意 字符串 比较符合以下规则： \"0\" 5.2 切片 描述 Python 表达式 结果 支持的数据类型 切片 \"0123456789\"[::-2] \"97531\" 字符串、列表、元组 切片 使用 索引值 来限定范围，从一个大的 字符串 中 切出 小的 字符串 列表 和 元组 都是 有序 的集合，都能够 通过索引值 获取到对应的数据 字典 是一个 无序 的集合，是使用 键值对 保存数据 5.3 运算符 运算符 Python 表达式 结果 描述 支持的数据类型 + [1, 2] + [3, 4] [1, 2, 3, 4] 合并 字符串、列表、元组 * [\"Hi!\"] * 4 ['Hi!', 'Hi!', 'Hi!', 'Hi!'] 重复 字符串、列表、元组 in 3 in (1, 2, 3) True 元素是否存在 字符串、列表、元组、字典 not in 4 not in (1, 2, 3) True 元素是否不存在 字符串、列表、元组、字典 > >= == (1, 2, 3) True 元素比较 字符串、列表、元组 注意 in 在对 字典 操作时，判断的是 字典的键 in 和 not in 被称为 成员运算符 成员运算符 成员运算符用于 测试 序列中是否包含指定的 成员 运算符 描述 实例 in 如果在指定的序列中找到值返回 True，否则返回 False 3 in (1, 2, 3) 返回 True not in 如果在指定的序列中没有找到值返回 True，否则返回 False 3 not in (1, 2, 3) 返回 False 注意：在对 字典 操作时，判断的是 字典的键 5.4 完整的 for 循环语法 在 Python 中完整的 for 循环 的语法如下： for 变量 in 集合: 循环体代码 else: 没有通过 break 退出循环，循环结束后，会执行的代码 应用场景 在 迭代遍历 嵌套的数据类型时，例如 一个列表包含了多个字典 需求：要判断 某一个字典中 是否存在 指定的 值 如果 存在，提示并且退出循环 如果 不存在，在 循环整体结束 后，希望 得到一个统一的提示 students = [ {\"name\": \"阿土\", \"age\": 20, \"gender\": True, \"height\": 1.7, \"weight\": 75.0}, {\"name\": \"小美\", \"age\": 19, \"gender\": False, \"height\": 1.6, \"weight\": 45.0}, ] find_name = \"阿土\" for stu_dict in students: print(stu_dict) # 判断当前遍历的字典中姓名是否为find_name if stu_dict[\"name\"] == find_name: print(\"找到了\") # 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较 break else: print(\"没有找到\") print(\"循环结束\") Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/综合应用——名片管理系统.html":{"url":"python/02/综合应用——名片管理系统.html","title":"综合应用 —— 名片管理系统","keywords":"","body":"综合应用 —— 名片管理系统 目标 综合应用已经学习过的知识点： 变量 流程控制 函数 模块 开发 名片管理系统 系统需求 程序启动，显示名片管理系统欢迎界面，并显示功能菜单 ************************************************** 欢迎使用【名片管理系统】V1.0 1. 新建名片 2. 显示全部 3. 查询名片 0. 退出系统 ************************************************** 用户用数字选择不同的功能 根据功能选择，执行不同的功能 用户名片需要记录用户的 姓名、电话、QQ、邮件 如果查询到指定的名片，用户可以选择 修改 或者 删除 名片 步骤 框架搭建 新增名片 显示所有名片 查询名片 查询成功后修改、删除名片 让 Python 程序能够直接运行 01. 框架搭建 目标 搭建名片管理系统 框架结构 准备文件，确定文件名，保证能够 在需要的位置 编写代码 编写 主运行循环，实现基本的 用户输入和判断 1.1 文件准备 新建 cards_main.py 保存 主程序功能代码 程序的入口 每一次启动名片管理系统都通过 main 这个文件启动 新建 cards_tools.py 保存 所有名片功能函数 将对名片的 新增、查询、修改、删除 等功能封装在不同的函数中 1.2 编写主运行循环 在 cards_main 中添加一个 无限循环 while True: # TODO(小明) 显示系统菜单 action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: pass elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入\") 字符串判断 if action in [\"1\", \"2\", \"3\"]: if action == \"1\" or action == \"2\" or action == \"3\": 使用 in 针对 列表 判断，避免使用 or 拼接复杂的逻辑条件 没有使用 int 转换用户输入，可以避免 一旦用户输入的不是数字，导致程序运行出错 pass pass 就是一个空语句，不做任何事情，一般用做占位语句 是为了保持程序结构的完整性 无限循环 在开发软件时，如果 不希望程序执行后 立即退出 可以在程序中增加一个 无限循环 由用户来决定 退出程序的时机 TODO 注释 在 # 后跟上 TODO，用于标记需要去做的工作 # TODO(作者/邮件) 显示系统菜单 1.3 在 cards_tools 中增加四个新函数 def show_menu(): \"\"\"显示菜单 \"\"\" pass def new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\") def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") 1.4 导入模块 在 cards_main.py 中使用 import 导入 cards_tools 模块 import cards_tools 修改 while 循环的代码如下： import cards_tools while True: cards_tools.show_menu() action = input(\"请选择操作功能：\") print(\"您选择的操作是：%s\" % action) # 根据用户输入决定后续的操作 if action in [\"1\", \"2\", \"3\"]: if action == \"1\": cards_tools.new_card() elif action == \"2\": cards_tools.show_all() elif action == \"3\": cards_tools.search_card() elif action == \"0\": print(\"欢迎再次使用【名片管理系统】\") break else: print(\"输入错误，请重新输入：\") 至此：cards_main 中的所有代码全部开发完毕！ 1.5 完成 show_menu 函数 def show_menu(): \"\"\"显示菜单 \"\"\" print(\"*\" * 50) print(\"欢迎使用【菜单管理系统】V1.0\") print(\"\") print(\"1. 新建名片\") print(\"2. 显示全部\") print(\"3. 查询名片\") print(\"\") print(\"0. 退出系统\") print(\"*\" * 50) 02. 保存名片数据的结构 程序就是用来处理数据的，而变量就是用来存储数据的 使用 字典 记录 每一张名片 的详细信息 使用 列表 统一记录所有的 名片字典 定义名片列表变量 在 cards_tools 文件的顶部增加一个 列表变量 # 所有名片记录的列表 card_list = [] 注意 所有名片相关操作，都需要使用这个列表，所以应该 定义在程序的顶部 程序刚运行时，没有数据，所以是 空列表 03. 新增名片 3.1 功能分析 提示用户依次输入名片信息 将名片信息保存到一个字典 将字典添加到名片列表 提示名片添加完成 3.2 实现 new_card 方法 根据步骤实现代码 def new_card(): \"\"\"新建名片 \"\"\" print(\"-\" * 50) print(\"功能：新建名片\") # 1. 提示用户输入名片信息 name = input(\"请输入姓名：\") phone = input(\"请输入电话：\") qq = input(\"请输入 QQ 号码：\") email = input(\"请输入邮箱：\") # 2. 将用户信息保存到一个字典 card_dict = {\"name\": name, \"phone\": phone, \"qq\": qq, \"email\": email} # 3. 将用户字典添加到名片列表 card_list.append(card_dict) print(card_list) # 4. 提示添加成功信息 print(\"成功添加 %s 的名片\" % card_dict[\"name\"]) 技巧：在 PyCharm 中，可以使用 SHIFT + F6 统一修改变量名 04. 显示所有名片 4.1 功能分析 循环遍历名片列表，顺序显示每一个字典的信息 4.2 基础代码实现 def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") for card_dict in card_list: print(card_dict) 显示效果不好！ 4.3 增加标题和使用 \\t 显示 def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 打印表头 for name in [\"姓名\", \"电话\", \"QQ\", \"邮箱\"]: print(name, end=\"\\t\\t\") print(\"\") # 打印分隔线 print(\"=\" * 50) for card_dict in card_list: print(\"%s\\t\\t%s\\t\\t%s\\t\\t%s\" % (card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) 4.4 增加没有名片记录判断 def show_all(): \"\"\"显示全部 \"\"\" print(\"-\" * 50) print(\"功能：显示全部\") # 1. 判断是否有名片记录 if len(card_list) == 0: print(\"提示：没有任何名片记录\") return 注意 在函数中使用 return 表示返回 如果在 return 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码 05. 查询名片 5.1 功能分析 提示用户要搜索的姓名 根据用户输入的姓名遍历列表 搜索到指定的名片后，再执行后续的操作 5.2 代码实现 查询功能实现 def search_card(): \"\"\"搜索名片 \"\"\" print(\"-\" * 50) print(\"功能：搜索名片\") # 1. 提示要搜索的姓名 find_name = input(\"请输入要搜索的姓名：\") # 2. 遍历字典 for card_dict in card_list: if card_dict[\"name\"] == find_name: print(\"姓名\\t\\t\\t电话\\t\\t\\tQQ\\t\\t\\t邮箱\") print(\"-\" * 40) print(\"%s\\t\\t\\t%s\\t\\t\\t%s\\t\\t\\t%s\" % ( card_dict[\"name\"], card_dict[\"phone\"], card_dict[\"qq\"], card_dict[\"email\"])) print(\"-\" * 40) # TODO(小明) 针对找到的字典进行后续操作：修改/删除 break else: print(\"没有找到 %s\" % find_name) 增加名片操作函数：修改/删除/返回主菜单 def deal_card(find_dict): \"\"\"操作搜索到的名片字典 :param find_dict:找到的名片字典 \"\"\" print(find_dict) action_str = input(\"请选择要执行的操作 \" \"[1] 修改 [2] 删除 [0] 返回上级菜单\") if action == \"1\": print(\"修改\") elif action == \"2\": print(\"删除\") 06. 修改和删除 6.1 查询成功后删除名片 由于找到的字典记录已经在列表中保存 要删除名片记录，只需要把列表中对应的字典删除即可 elif action == \"2\": card_list.remove(find_dict) print(\"删除成功\") 6.2 修改名片 由于找到的字典记录已经在列表中保存 要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可 if action == \"1\": find_dict[\"name\"] = input(\"请输入姓名：\") find_dict[\"phone\"] = input(\"请输入电话：\") find_dict[\"qq\"] = input(\"请输入QQ：\") find_dict[\"email\"] = input(\"请输入邮件：\") print(\"%s 的名片修改成功\" % find_dict[\"name\"]) 修改名片细化 如果用户在使用时，某些名片内容并不想修改，应该如何做呢？—— 既然系统提供的 input 函数不能满足需求，那么就新定义一个函数 input_card_info 对系统的 input 函数进行扩展 def input_card_info(dict_value, tip_message): \"\"\"输入名片信息 :param dict_value: 字典原有值 :param tip_message: 输入提示信息 :return: 如果输入，返回输入内容，否则返回字典原有值 \"\"\" # 1. 提示用户输入内容 result_str = input(tip_message) # 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果 if len(result_str) > 0: return result_str # 3. 如果用户没有输入内容，返回 `字典中原有的值` else: return dict_value 07. LINUX 上的 Shebang 符号(#!) #!这个符号叫做 Shebang 或者 Sha-bang Shebang 通常在 Unix 系统脚本的中 第一行开头 使用 指明 执行这个脚本文件 的 解释程序 使用 Shebang 的步骤 使用 which 查询 python3 解释器所在路径 $ which python3 修改要运行的 主 python 文件，在第一行增加以下内容 #! /usr/bin/python3 修改 主 python 文件 的文件权限，增加执行权限 $ chmod +x cards_main.py 在需要时执行程序即可 ./cards_main.py Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/函数进阶.html":{"url":"python/02/函数进阶.html","title":"函数进阶","keywords":"","body":"函数进阶 目标 函数参数和返回值的作用 函数的返回值 进阶 函数的参数 进阶 递归函数 01. 函数参数和返回值的作用 函数根据 有没有参数 以及 有没有返回值，可以 相互组合，一共有 4 种 组合形式 无参数，无返回值 无参数，有返回值 有参数，无返回值 有参数，有返回值 定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的！ 如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部 如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值 1.1 无参数，无返回值 此类函数，不接收参数，也没有返回值，应用场景如下： 只是单纯地做一件事情，例如 显示菜单 在函数内部 针对全局变量进行操作，例如：新建名片，最终结果 记录在全局变量 中 注意： 如果全局变量的数据类型是一个 可变类型，在函数内部可以使用 方法 修改全局变量的内容 —— 变量的引用不会改变 在函数内部，使用赋值语句 才会 修改变量的引用 1.2 无参数，有返回值 此类函数，不接收参数，但是有返回值，应用场景如下： 采集数据，例如 温度计，返回结果就是当前的温度，而不需要传递任何的参数 1.3 有参数，无返回值 此类函数，接收参数，没有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据 例如 名片管理系统 针对 找到的名片 做 修改、删除 操作 1.4 有参数，有返回值 此类函数，接收参数，同时有返回值，应用场景如下： 函数内部的代码保持不变，针对 不同的参数 处理 不同的数据，并且 返回期望的处理结果 例如 名片管理系统 使用 字典默认值 和 提示信息 提示用户输入内容 如果输入，返回输入内容 如果没有输入，返回字典默认值 02. 函数的返回值 进阶 在程序开发中，有时候，会希望 一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理 返回值 是函数 完成工作后，最后 给调用者的 一个结果 在函数中使用 return 关键字可以返回结果 调用函数一方，可以 使用变量 来 接收 函数的返回结果 问题：一个函数执行后能否返回多个结果？ 示例 —— 温度和湿度测量 假设要开发一个函数能够同时返回当前的温度和湿度 先完成返回温度的功能如下： def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 print(\"测量结束...\") return temp result = measure() print(result) 在利用 元组 在返回温度的同时，也能够返回 湿度 改造如下： def measure(): \"\"\"返回当前的温度\"\"\" print(\"开始测量...\") temp = 39 wetness = 10 print(\"测量结束...\") return (temp, wetness) 提示：如果一个函数返回的是元组，括号可以省略 技巧 在 Python 中，可以 将一个元组 使用 赋值语句 同时赋值给 多个变量 注意：变量的数量需要和元组中的元素数量保持一致 result = temp, wetness = measure() 面试题 —— 交换两个数字 题目要求 有两个整数变量 a = 6, b = 100 不使用其他变量，交换两个变量的值 解法 1 —— 使用其他变量 # 解法 1 - 使用临时变量 c = b b = a a = c 解法 2 —— 不使用临时变量 # 解法 2 - 不使用临时变量 a = a + b b = a - b a = a - b 解法 3 —— Python 专有，利用元组 a, b = b, a 03. 函数的参数 进阶 3.1. 不可变和可变的参数 问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？ —— 不会！ 无论传递的参数是 可变 还是 不可变 只要 针对参数 使用 赋值语句，会在 函数内部 修改 局部变量的引用，不会影响到 外部变量的引用 def demo(num, num_list): print(\"函数内部\") # 赋值语句 num = 200 num_list = [1, 2, 3] print(num) print(num_list) print(\"函数代码完成\") gl_num = 99 gl_list = [4, 5, 6] demo(gl_num, gl_list) print(gl_num) print(gl_list) 问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据 def mutable(num_list): # num_list = [1, 2, 3] num_list.extend([1, 2, 3]) print(num_list) gl_list = [6, 7, 8] mutable(gl_list) print(gl_list) 面试题 —— += 在 python 中，列表变量调用 += 本质上是在执行列表变量的 extend 方法，不会修改变量的引用 def demo(num, num_list): print(\"函数内部代码\") # num = num + num num += num # num_list.extend(num_list) 由于是调用方法，所以不会修改变量的引用 # 函数执行结束后，外部数据同样会发生变化 num_list += num_list print(num) print(num_list) print(\"函数代码完成\") gl_num = 9 gl_list = [1, 2, 3] demo(gl_num, gl_list) print(gl_num) print(gl_list) 3.2 缺省参数 定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数 调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值 函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用 例如：对列表排序的方法 gl_num_list = [6, 3, 9] # 默认就是升序排序，因为这种应用需求更多 gl_num_list.sort() print(gl_num_list) # 只有当需要降序排序时，才需要传递 `reverse` 参数 gl_num_list.sort(reverse=True) print(gl_num_list) 指定函数的缺省参数 在参数后使用赋值语句，可以指定参数的缺省值 def print_info(name, gender=True): gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s 是 %s\" % (name, gender_text)) 提示 缺省参数，需要使用 最常见的值 作为默认值！ 如果一个参数的值 不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递！ 缺省参数的注意事项 1) 缺省参数的定义位置 必须保证 带有默认值的缺省参数 在参数列表末尾 所以，以下定义是错误的！ def print_info(name, gender=True, title): 2) 调用带有多个缺省参数的函数 在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系！ def print_info(name, title=\"\", gender=True): \"\"\" :param title: 职位 :param name: 班上同学的姓名 :param gender: True 男生 False 女生 \"\"\" gender_text = \"男生\" if not gender: gender_text = \"女生\" print(\"%s%s 是 %s\" % (title, name, gender_text)) # 提示：在指定缺省参数的默认值时，应该使用最常见的值作为默认值！ print_info(\"小明\") print_info(\"老王\", title=\"班长\") print_info(\"小美\", gender=False) 3.3 多值参数（知道） 定义支持多值参数的函数 有时可能需要 一个函数 能够处理的参数 个数 是不确定的，这个时候，就可以使用 多值参数 python 中有 两种 多值参数： 参数名前增加 一个 * 可以接收 元组 参数名前增加 两个 * 可以接收 字典 一般在给多值参数命名时，习惯使用以下两个名字 *args —— 存放 元组 参数，前面有一个 * **kwargs —— 存放 字典 参数，前面有两个 * args 是 arguments 的缩写，有变量的含义 kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数 def demo(num, *args, **kwargs): print(num) print(args) print(kwargs) demo(1, 2, 3, 4, 5, name=\"小明\", age=18, gender=True) 提示：多值参数 的应用会经常出现在网络上一些大牛开发的框架中，知道多值参数，有利于我们能够读懂大牛的代码 多值参数案例 —— 计算任意多个数字的和 需求 定义一个函数 sum_numbers，可以接收的 任意多个整数 功能要求：将传递的 所有数字累加 并且返回累加结果 def sum_numbers(*args): num = 0 # 遍历 args 元组顺序求和 for n in args: num += n return num print(sum_numbers(1, 2, 3)) 元组和字典的拆包（知道） 在调用带有多值参数的函数时，如果希望： 将一个 元组变量，直接传递给 args 将一个 字典变量，直接传递给 kwargs 就可以使用 拆包，简化参数的传递，拆包 的方式是： 在 元组变量前，增加 一个 * 在 字典变量前，增加 两个 * def demo(*args, **kwargs): print(args) print(kwargs) # 需要将一个元组变量/字典变量传递给函数对应的参数 gl_nums = (1, 2, 3) gl_xiaoming = {\"name\": \"小明\", \"age\": 18} # 会把 num_tuple 和 xiaoming 作为元组传递个 args # demo(gl_nums, gl_xiaoming) demo(*gl_nums, **gl_xiaoming) 04. 函数的递归 函数调用自身的 编程技巧 称为递归 4.1 递归函数的特点 特点 一个函数 内部 调用自己 函数内部可以调用其他函数，当然在函数内部也可以调用自己 代码特点 函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同 当 参数满足一个条件 时，函数不再执行 这个非常重要，通常被称为递归的出口，否则 会出现死循环！ 示例代码 def sum_numbers(num): print(num) # 递归的出口很重要，否则会出现死循环 if num == 1: return sum_numbers(num - 1) sum_numbers(3) 4.2 递归案例 —— 计算数字累加 需求 定义一个函数 sum_numbers 能够接收一个 num 的整数参数 计算 1 + 2 + ... num 的结果 def sum_numbers(num): if num == 1: return 1 # 假设 sum_numbers 能够完成 num - 1 的累加 temp = sum_numbers(num - 1) # 函数内部的核心算法就是 两个数字的相加 return num + temp print(sum_numbers(2)) 提示：递归是一个 编程技巧，初次接触递归会感觉有些吃力！在处理 不确定的循环条件时，格外的有用，例如：遍历整个文件目录的结构 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/02/变量进阶（理解）.html":{"url":"python/02/变量进阶（理解）.html","title":"变量进阶（理解）","keywords":"","body":"变量进阶（理解） 目标 变量的引用 可变和不可变类型 局部变量和全局变量 01. 变量的引用 变量 和 数据 都是保存在 内存 中的 在 Python 中 函数 的 参数传递 以及 返回值 都是靠 引用 传递的 1.1 引用的概念 在 Python 中 变量 和 数据 是分开存储的 数据 保存在内存中的一个位置 变量 中保存着数据在内存中的地址 变量 中 记录数据的地址，就叫做 引用 使用 id() 函数可以查看变量中保存数据所在的 内存地址 注意：如果变量已经被定义，当给一个变量赋值的时候，本质上是 修改了数据的引用 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 1.2 变量引用 的示例 在 Python 中，变量的名字类似于 便签纸 贴在 数据 上 定义一个整数变量 a，并且赋值为 1 代码 图示 a = 1 将变量 a 赋值为 2 代码 图示 a = 2 定义一个整数变量 b，并且将变量 a 的值赋值给 b 代码 图示 b = a 变量 b 是第 2 个贴在数字 2 上的标签 1.3 函数的参数和返回值的传递 在 Python 中，函数的 实参/返回值 都是是靠 引用 来传递来的 def test(num): print(\"-\" * 50) print(\"%d 在函数内的内存地址是 %x\" % (num, id(num))) result = 100 print(\"返回值 %d 在内存中的地址是 %x\" % (result, id(result))) print(\"-\" * 50) return result a = 10 print(\"调用函数前 内存地址是 %x\" % id(a)) r = test(a) print(\"调用函数后 实参内存地址是 %x\" % id(a)) print(\"调用函数后 返回值内存地址是 %x\" % id(r)) 02. 可变和不可变类型 不可变类型，内存中的数据不允许被修改： 数字类型 int, bool, float, complex, long(2.x) 字符串 str 元组 tuple 可变类型，内存中的数据可以被修改： 列表 list 字典 dict a = 1 a = \"hello\" a = [1, 2, 3] a = [3, 2, 1] demo_list = [1, 2, 3] print(\"定义列表后的内存地址 %d\" % id(demo_list)) demo_list.append(999) demo_list.pop(0) demo_list.remove(2) demo_list[0] = 10 print(\"修改数据后的内存地址 %d\" % id(demo_list)) demo_dict = {\"name\": \"小明\"} print(\"定义字典后的内存地址 %d\" % id(demo_dict)) demo_dict[\"age\"] = 18 demo_dict.pop(\"name\") demo_dict[\"name\"] = \"老王\" print(\"修改数据后的内存地址 %d\" % id(demo_dict)) 注意：字典的 key 只能使用不可变类型的数据 注意 可变类型的数据变化，是通过 方法 来实现的 如果给一个可变类型的变量，赋值了一个新的数据，引用会修改 变量 不再 对之前的数据引用 变量 改为 对新赋值的数据引用 哈希 (hash) Python 中内置有一个名字叫做 hash(o) 的函数 接收一个 不可变类型 的数据作为 参数 返回 结果是一个 整数 哈希 是一种 算法，其作用就是提取数据的 特征码（指纹） 相同的内容 得到 相同的结果 不同的内容 得到 不同的结果 在 Python 中，设置字典的 键值对 时，会首先对 key 进行 hash 已决定如何在内存中保存字典的数据，以方便 后续 对字典的操作：增、删、改、查 键值对的 key 必须是不可变类型数据 键值对的 value 可以是任意类型的数据 03. 局部变量和全局变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 3.1 局部变量 局部变量 是在 函数内部 定义的变量，只能在函数内部使用 函数执行结束后，函数内部的局部变量，会被系统回收 不同的函数，可以定义相同的名字的局部变量，但是 彼此之间 不会产生影响 局部变量的作用 在函数内部使用，临时 保存 函数内部需要使用的数据 def demo1(): num = 10 print(num) num = 20 print(\"修改后 %d\" % num) def demo2(): num = 100 print(num) demo1() demo2() print(\"over\") 局部变量的生命周期 所谓 生命周期 就是变量从 被创建 到 被系统回收 的过程 局部变量 在 函数执行时 才会被创建 函数执行结束后 局部变量 被系统回收 局部变量在生命周期 内，可以用来存储 函数内部临时使用到的数据 3.2 全局变量 全局变量 是在 函数外部定义 的变量，所有函数内部都可以使用这个变量 # 定义一个全局变量 num = 10 def demo1(): print(num) def demo2(): print(num) demo1() demo2() print(\"over\") 注意：函数执行时，需要处理变量时 会： 首先 查找 函数内部 是否存在 指定名称 的局部变量，如果有，直接使用 如果没有，查找 函数外部 是否存在 指定名称 的全局变量，如果有，直接使用 如果还没有，程序报错！ 函数不能直接修改 全局变量的引用 全局变量 是在 函数外部定义 的变量（没有定义在某一个函数内），所有函数 内部 都可以使用这个变量 提示：在其他的开发语言中，大多 不推荐使用全局变量 —— 可变范围太大，导致程序不好维护！ 在函数内部，可以 通过全局变量的引用获取对应的数据 但是，不允许直接修改全局变量的引用 —— 使用赋值语句修改全局变量的值 num = 10 def demo1(): print(\"demo1\" + \"-\" * 50) # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num) def demo2(): print(\"demo2\" + \"-\" * 50) print(num) demo1() demo2() print(\"over\") 注意：只是在函数内部定义了一个局部变量而已，只是变量名相同 —— 在函数内部不能直接修改全局变量的值 在函数内部修改全局变量的值 如果在函数中需要修改全局变量，需要使用 global 进行声明 num = 10 def demo1(): print(\"demo1\" + \"-\" * 50) # global 关键字，告诉 Python 解释器 num 是一个全局变量 global num # 只是定义了一个局部变量，不会修改到全局变量，只是变量名相同而已 num = 100 print(num) def demo2(): print(\"demo2\" + \"-\" * 50) print(num) demo1() demo2() print(\"over\") 全局变量定义的位置 为了保证所有的函数都能够正确使用到全局变量，应该 将全局变量定义在其他函数的上方 a = 10 def demo(): print(\"%d\" % a) print(\"%d\" % b) print(\"%d\" % c) b = 20 demo() c = 30 注意 由于全局变量 c，是在调用函数之后，才定义的，在执行函数时，变量还没有定义，所以程序会报错！ 代码结构示意图如下 全局变量命名的建议 为了避免局部变量和全局变量出现混淆，在定义全局变量时，有些公司会有一些开发要求，例如： 全局变量名前应该增加 g_ 或者 gl_ 的前缀 提示：具体的要求格式，各公司要求可能会有些差异 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/03/intro.html":{"url":"python/03/intro.html","title":"Python 面对对象","keywords":"","body":"linux基础 自学使用-黑马培训班上海37期 Python 侵删 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:10 "},"python/03/面向对象OOP基本概念.html":{"url":"python/03/面向对象OOP基本概念.html","title":"面向对象(OOP)基本概念","keywords":"","body":"面向对象(OOP)基本概念 面向对象编程 —— Object Oriented Programming 简写 OOP 目标 了解 面向对象 基本概念 01. 面向对象基本概念 我们之前学习的编程方式就是 面向过程 的 面相过程 和 面相对象，是两种不同的 编程方式 对比 面向过程 的特点，可以更好地了解什么是 面向对象 1.1 过程和函数（科普） 过程 是早期的一个编程概念 过程 类似于函数，只能执行，但是没有返回值 函数 不仅能执行，还可以返回结果 1.2 面相过程 和 面相对象 基本概念 1) 面相过程 —— 怎么做？ 把完成某一个需求的 所有步骤 从头到尾 逐步实现 根据开发需求，将某些 功能独立 的代码 封装 成一个又一个 函数 最后完成的代码，就是顺序地调用 不同的函数 特点 注重 步骤与过程，不注重职责分工 如果需求复杂，代码会变得很复杂 开发复杂项目，没有固定的套路，开发难度很大！ ￼ 2) 面向对象 —— 谁来做？ 相比较函数，面向对象 是 更大 的 封装，根据 职责 在 一个对象中 封装 多个方法 在完成某一个需求前，首先确定 职责 —— 要做的事情（方法） 根据 职责 确定不同的 对象，在 对象 内部封装不同的 方法（多个） 最后完成的代码，就是顺序地让 不同的对象 调用 不同的方法 特点 注重 对象和职责，不同的对象承担不同的职责 更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路 需要在面向过程基础上，再学习一些面向对象的语法 ￼ ￼ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "},"python/03/类和对象.html":{"url":"python/03/类和对象.html","title":"类和对象","keywords":"","body":"类和对象 目标 类和对象的概念 类和对象的关系 类的设计 01. 类和对象的概念 类 和 对象 是 面向对象编程的 两个 核心概念 1.1 类 类 是对一群具有 相同 特征 或者 行为 的事物的一个统称，是抽象的， 不能直接使用 特征 被称为 属性 行为 被称为 方法 类 就相当于制造飞机时的图纸，是一个 模板，是 负责创建对象的 ￼ 1.2 对象 对象 是 由类创建出来的一个具体存在，可以直接使用 由 哪一个类 创建出来的 对象 ，就拥有在 哪一个类 中定义的： 属性 方法 对象 就相当于用 图纸 制造 的飞机 在程序开发中，应该 先有类，再有对象 ￼ 02. 类和对象的关系 类是模板，对象 是根据 类 这个模板创建出来的，应该 先有类，再有对象 类 只有一个，而 对象 可以有很多个 不同的对象 之间 属性 可能会各不相同 类 中定义了什么 属性和方法，对象 中就有什么属性和方法，不可能多，也不可能少 03. 类的设计 在使用面相对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！ ￼ 在程序开发中，要设计一个类，通常需要满足一下三个要素： 类名 这类事物的名字，满足大驼峰命名法 属性 这类事物具有什么样的特征 方法 这类事物具有什么样的行为 大驼峰命名法 CapWords 每一个单词的首字母大写 单词与单词之间没有下划线 3.1 类名的确定 名词提炼法 分析 整个业务流程，出现的 名词，通常就是找到的类 3.2 属性和方法的确定 对 对象的特征描述，通常可以定义成 属性 对象具有的行为（动词），通常可以定义成 方法 提示：需求中没有涉及的属性或者方法在设计类时，不需要考虑 练习 1 需求 小明 今年 18 岁，身高 1.75，每天早上 跑 完步，会去 吃 东西 小美 今年 17 岁，身高 1.65，小美不跑步，小美喜欢 吃 东西 ￼ 练习 2 需求 一只 黄颜色 的 狗狗 叫 大黄 看见生人 汪汪叫 看见家人 摇尾巴 ￼ Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "},"python/03/面相对象基础语法.html":{"url":"python/03/面相对象基础语法.html","title":"面相对象基础语法","keywords":"","body":"面相对象基础语法 目标 dir 内置函数 定义简单的类（只包含方法） 方法中的 self 参数 初始化方法 内置方法和属性 01. dir 内置函数（知道） 在 Python 中 对象几乎是无所不在的，我们之前学习的 变量、数据、函数 都是对象 在 Python 中可以使用以下两个方法验证： 在 标识符 / 数据 后输入一个 .，然后按下 TAB 键，iPython 会提示该对象能够调用的 方法列表 使用内置函数 dir 传入 标识符 / 数据，可以查看对象内的 所有属性及方法 提示 __方法名__ 格式的方法是 Python 提供的 内置方法 / 属性，稍后会给大家介绍一些常用的 内置方法 / 属性 序号 方法名 类型 作用 01 __new__ 方法 创建对象时，会被 自动 调用 02 __init__ 方法 对象被初始化时，会被 自动 调用 03 __del__ 方法 对象被从内存中销毁前，会被 自动 调用 04 __str__ 方法 返回对象的描述信息，print 函数输出使用 提示 利用好 dir() 函数，在学习时很多内容就不需要死记硬背了 02. 定义简单的类（只包含方法） 面向对象 是 更大 的 封装，在 一个类中 封装 多个方法，这样 通过这个类创建出来的对象，就可以直接调用这些方法了！ 2.1 定义只包含方法的类 在 Python 中要定义一个只包含方法的类，语法格式如下： class 类名: def 方法1(self, 参数列表): pass def 方法2(self, 参数列表): pass 方法 的定义格式和之前学习过的函数 几乎一样 区别在于第一个参数必须是 self，大家暂时先记住，稍后介绍 self 注意：类名 的 命名规则 要符合 大驼峰命名法 2.2 创建对象 当一个类定义完成之后，要使用这个类来创建对象，语法格式如下： 对象变量 = 类名() 2.3 第一个面向对象程序 需求 小猫 爱 吃 鱼，小猫 要 喝 水 分析 定义一个猫类 Cat 定义两个方法 eat 和 drink 按照需求 —— 不需要定义属性 ￼ class Cat: \"\"\"这是一个猫类\"\"\" def eat(self): print(\"小猫爱吃鱼\") def drink(self): print(\"小猫在喝水\") tom = Cat() tom.drink() tom.eat() 引用概念的强调 在面向对象开发中，引用的概念是同样适用的！ 在 Python 中使用类 创建对象之后，tom 变量中 仍然记录的是 对象在内存中的地址 也就是 tom 变量 引用 了 新建的猫对象 使用 print 输出 对象变量，默认情况下，是能够输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示） 提示：在计算机中，通常使用 十六进制 表示 内存地址 十进制 和 十六进制 都是用来表达数字的，只是表示的方式不一样 十进制 和 十六进制 的数字之间可以来回转换 %d 可以以 10 进制 输出数字 %x 可以以 16 进制 输出数字 案例进阶 —— 使用 Cat 类再创建一个对象 lazy_cat = Cat() lazy_cat.eat() lazy_cat.drink() 提问：tom 和 lazy_cat 是同一个对象吗？ 03. 方法中的 self 参数 3.1 案例改造 —— 给对象增加属性 在 Python 中，要 给对象设置属性 ，非常的容易， 但是不推荐使用 因为：对象属性的封装应该封装在类的内部 只需要在 类的外部的代码 中直接通过 . 设置一个属性即可 注意：这种方式虽然简单，但是不推荐使用！ tom.name = \"Tom\" ... lazy_cat.name = \"大懒猫\" 3.2 使用 self 在方法内部输出每一只猫的名字 由 哪一个对象 调用的方法，方法内的 self 就是 哪一个对象的引用 在类封装的方法内部，self 就表示 当前调用方法的对象自己 调用方法时，程序员不需要传递 self 参数 在方法内部 可以通过 self. 访问对象的属性 也可以通过 self. 调用其他的对象方法 改造代码如下： class Cat: def eat(self): print(\"%s 爱吃鱼\" % self.name) tom = Cat() tom.name = \"Tom\" tom.eat() lazy_cat = Cat() lazy_cat.name = \"大懒猫\" lazy_cat.eat() ￼ 在 类的外部，通过 变量名. 访问对象的 属性和方法 在 类封装的方法中，通过 self. 访问对象的 属性和方法 04. 初始化方法 4.1 之前代码存在的问题 —— 在类的外部给对象增加属性 将案例代码进行调整，先调用方法 再设置属性，观察一下执行效果 tom = Cat() tom.drink() tom.eat() tom.name = \"Tom\" print(tom) 程序执行报错如下： AttributeError: 'Cat' object has no attribute 'name' 属性错误：'Cat' 对象没有 'name' 属性 提示 在日常开发中，不推荐在 类的外部 给对象增加属性 如果在运行时，没有找到属性，程序会报错 对象应该包含有哪些属性，应该 封装在类的内部 4.2 初始化方法 当使用 类名() 创建对象时，会 自动 执行以下操作： 为对象在内存中 分配空间 —— 创建对象 为对象的属性 设置初始值 —— 初始化方法(init) 这个 初始化方法 就是 __init__ 方法，__init__ 是对象的内置方法 __init__ 方法是 专门 用来定义一个类 具有哪些属性的方法！ 在 Cat 中增加 __init__ 方法，验证该方法在创建对象时会被自动调用 class Cat: \"\"\"这是一个猫类\"\"\" def __init__(self): print(\"初始化方法\") 4.3 在初始化方法内部定义属性 在 __init__ 方法内部使用 self.属性名 = 属性的初始值 就可以 定义属性 定义属性之后，再使用 Cat 类创建的对象，都会拥有该属性 class Cat: def __init__(self): print(\"这是一个初始化方法\") # 定义用 Cat 类创建的猫对象都有一个 name 的属性 self.name = \"Tom\" def eat(self): print(\"%s 爱吃鱼\" % self.name) # 使用类名()创建对象的时候，会自动调用初始化方法 __init__ tom = Cat() tom.eat() 4.4 改造初始化方法 —— 初始化的同时设置初始值 在开发中，如果希望在 创建对象的同时，就设置对象的属性 ，可以对 __init__ 方法进行 改造 把希望设置的属性值，定义成 __init__ 方法的参数 在方法内部使用 self.属性 = 形参 接收外部传递的参数 在创建对象时，使用 类名(属性1, 属性2...) 调用 class Cat: def __init__(self, name): print(\"初始化方法 %s\" % name) self.name = name ... tom = Cat(\"Tom\") ... lazy_cat = Cat(\"大懒猫\") ... 05. 内置方法和属性 序号 方法名 类型 作用 01 __del__ 方法 对象被从内存中销毁前，会被 自动 调用 02 __str__ 方法 返回对象的描述信息，print 函数输出使用 5.1 __del__ 方法（知道） 在 Python 中 当使用 类名() 创建对象时，为对象 分配完空间后，自动 调用 __init__ 方法 当一个 对象被从内存中销毁 前，会 自动 调用 __del__ 方法 应用场景 __init__ 改造初始化方法，可以让创建对象更加灵活 __del__ 如果希望在对象被销毁前，再做一些事情，可以考虑一下 __del__ 方法 生命周期 一个对象从调用 类名() 创建，生命周期开始 一个对象的 __del__ 方法一旦被调用，生命周期结束 在对象的生命周期内，可以访问对象属性，或者让对象调用方法 class Cat: def __init__(self, new_name): self.name = new_name print(\"%s 来了\" % self.name) def __del__(self): print(\"%s 去了\" % self.name) # tom 是一个全局变量 tom = Cat(\"Tom\") print(tom.name) # del 关键字可以删除一个对象 del tom print(\"-\" * 50) 5.2 __str__ 方法 在 Python 中，使用 print 输出 对象变量，默认情况下，会输出这个变量 引用的对象 是 由哪一个类创建的对象，以及 在内存中的地址（十六进制表示） 如果在开发中，希望使用 print 输出 对象变量 时，能够打印 自定义的内容，就可以利用 __str__ 这个内置方法了 注意：__str__ 方法必须返回一个字符串 class Cat: def __init__(self, new_name): self.name = new_name print(\"%s 来了\" % self.name) def __del__(self): print(\"%s 去了\" % self.name) def __str__(self): return \"我是小猫：%s\" % self.name tom = Cat(\"Tom\") print(tom) Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "},"python/03/面向对象封装案例.html":{"url":"python/03/面向对象封装案例.html","title":"面向对象封装案例","keywords":"","body":"面向对象封装案例 目标 封装 小明爱跑步 存放家具 01. 封装 封装 是面向对象编程的一大特点 面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中 外界 使用 类 创建 对象，然后 让对象调用方法 对象方法的细节 都被 封装 在 类的内部 02. 小明爱跑步 需求 小明 体重 75.0 公斤 小明每次 跑步 会减肥 0.5 公斤 小明每次 吃东西 体重增加 1 公斤 ￼ 提示：在 对象的方法内部，是可以 直接访问对象的属性 的！ 代码实现： class Person: \"\"\"人类\"\"\" def __init__(self, name, weight): self.name = name self.weight = weight def __str__(self): return \"我的名字叫 %s 体重 %.2f 公斤\" % (self.name, self.weight) def run(self): \"\"\"跑步\"\"\" print(\"%s 爱跑步，跑步锻炼身体\" % self.name) self.weight -= 0.5 def eat(self): \"\"\"吃东西\"\"\" print(\"%s 是吃货，吃完这顿再减肥\" % self.name) self.weight += 1 xiaoming = Person(\"小明\", 75) xiaoming.run() xiaoming.eat() xiaoming.eat() print(xiaoming) 2.1 小明爱跑步扩展 —— 小美也爱跑步 需求 小明 和 小美 都爱跑步 小明 体重 75.0 公斤 小美 体重 45.0 公斤 每次 跑步 都会减少 0.5 公斤 每次 吃东西 都会增加 1 公斤 ￼ 提示 在 对象的方法内部，是可以 直接访问对象的属性 的 同一个类 创建的 多个对象 之间，属性 互不干扰！ ￼ 03. 摆放家具 需求 房子(House) 有 户型 、 总面积 和 家具名称列表 新房子没有任何的家具 家具(HouseItem) 有 名字 和 占地面积 ，其中 席梦思(bed) 占地 4 平米 衣柜(chest) 占地 2 平米 餐桌(table) 占地 1.5 平米 将以上三件 家具 添加 到 房子 中 打印房子时，要求输出：户型、总面积、剩余面积、家具名称列表 ￼ 剩余面积 在创建房子对象时，定义一个 剩余面积的属性，初始值和总面积相等 当调用 add_item 方法，向房间 添加家具 时，让 剩余面积 -= 家具面积 思考：应该先开发哪一个类？ 答案 —— 家具类 家具简单 房子要使用到家具，被使用的类，通常应该先开发 3.1 创建家具 class HouseItem: def __init__(self, name, area): \"\"\" :param name: 家具名称 :param area: 占地面积 \"\"\" self.name = name self.area = area def __str__(self): return \"[%s] 占地面积 %.2f\" % (self.name, self.area) # 1. 创建家具 bed = HouseItem(\"席梦思\", 4) chest = HouseItem(\"衣柜\", 2) table = HouseItem(\"餐桌\", 1.5) print(bed) print(chest) print(table) 小结 创建了一个 家具类，使用到 __init__ 和 __str__ 两个内置方法 使用 家具类 创建了 三个家具对象，并且 输出家具信息 3.2 创建房间 class House: def __init__(self, house_type, area): \"\"\" :param house_type: 户型 :param area: 总面积 \"\"\" self.house_type = house_type self.area = area # 剩余面积默认和总面积一致 self.free_area = area # 默认没有任何的家具 self.item_list = [] def __str__(self): # Python 能够自动的将一对括号内部的代码连接在一起 return (\"户型：%s\\n总面积：%.2f[剩余：%.2f]\\n家具：%s\" % (self.house_type, self.area, self.free_area, self.item_list)) def add_item(self, item): print(\"要添加 %s\" % item) ... # 2. 创建房子对象 my_home = House(\"两室一厅\", 60) my_home.add_item(bed) my_home.add_item(chest) my_home.add_item(table) print(my_home) 小结 创建了一个 房子类，使用到 __init__ 和 __str__ 两个内置方法 准备了一个 add_item 方法 准备添加家具 使用 房子类 创建了 一个房子对象 让 房子对象 调用了三次 add_item 方法，将 三件家具 以实参传递到 add_item 内部 3.3 添加家具 需求 1> 判断 家具的面积 是否 超过剩余面积，如果超过，提示不能添加这件家具 2> 将 家具的名称 追加到 家具名称列表 中 3> 用 房子的剩余面积 - 家具面积 def add_item(self, item): print(\"要添加 %s\" % item) # 1. 判断家具面积是否大于剩余面积 if item.area > self.free_area: print(\"%s 的面积太大，不能添加到房子中\" % item.name) return # 2. 将家具的名称追加到名称列表中 self.item_list.append(item.name) # 3. 计算剩余面积 self.free_area -= item.area 3.4 小结 主程序只负责创建 房子 对象和 家具 对象 让 房子 对象调用 add_item 方法 将家具添加到房子中 面积计算、剩余面积、家具列表 等处理都被 封装 到 房子类的内部 Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "},"python/03/面向对象封装案例II.html":{"url":"python/03/面向对象封装案例II.html","title":"面向对象封装案例II.md","keywords":"","body":"面向对象封装案例 II 目标 士兵突击案例 身份运算符 封装 封装 是面向对象编程的一大特点 面向对象编程的 第一步 —— 将 属性 和 方法 封装 到一个抽象的 类 中 外界 使用 类 创建 对象，然后 让对象调用方法 对象方法的细节 都被 封装 在 类的内部 一个对象的 属性 可以是 另外一个类创建的对象 01. 士兵突击 需求 士兵 许三多 有一把 AK47 士兵 可以 开火 枪 能够 发射 子弹 枪 装填 装填子弹 —— 增加子弹数量 ￼ 1.1 开发枪类 shoot 方法需求 1> 判断是否有子弹，没有子弹无法射击 2> 使用 print 提示射击，并且输出子弹数量 class Gun: def __init__(self, model): # 枪的型号 self.model = model # 子弹数量 self.bullet_count = 0 def add_bullet(self, count): self.bullet_count += count def shoot(self): # 判断是否还有子弹 if self.bullet_count 1.2 开发士兵类 假设：每一个新兵 都 没有枪 定义没有初始值的属性 在定义属性时，如果 不知道设置什么初始值，可以设置为 None None 关键字 表示 什么都没有 表示一个 空对象，没有方法和属性，是一个特殊的常量 可以将 None 赋值给任何一个变量 fire 方法需求 1> 判断是否有枪，没有枪没法冲锋 2> 喊一声口号 3> 装填子弹 4> 射击 class Soldier: def __init__(self, name): # 姓名 self.name = name # 枪，士兵初始没有枪 None 关键字表示什么都没有 self.gun = None def fire(self): # 1. 判断士兵是否有枪 if self.gun is None: print(\"[%s] 还没有枪...\" % self.name) return # 2. 高喊口号 print(\"冲啊...[%s]\" % self.name) # 3. 让枪装填子弹 self.gun.add_bullet(50) # 4. 让枪发射子弹 self.gun.shoot() 小结 创建了一个 士兵类，使用到 __init__ 内置方法 在定义属性时，如果 不知道设置什么初始值，可以设置为 None 在 封装的 方法内部，还可以让 自己的 使用其他类创建的对象属性 调用已经 封装好的方法 02. 身份运算符 身份运算符用于 比较 两个对象的 内存地址 是否一致 —— 是否是对同一个对象的引用 在 Python 中针对 None 比较时，建议使用 is 判断 运算符 描述 实例 is is 是判断两个标识符是不是引用同一个对象 x is y，类似 id(x) == id(y) is not is not 是判断两个标识符是不是引用不同对象 x is not y，类似 id(a) != id(b) is 与 == 区别： is 用于判断 两个变量 引用对象是否为同一个 == 用于判断 引用变量的值 是否相等 >>> a = [1, 2, 3] >>> b = [1, 2, 3] >>> b is a False >>> b == a True Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "},"python/03/私有属性和私有方法.html":{"url":"python/03/私有属性和私有方法.html","title":"私有属性和私有方法","keywords":"","body":"私有属性和私有方法 01. 应用场景及定义方式 应用场景 在实际开发中，对象 的 某些属性或方法 可能只希望 在对象的内部被使用，而 不希望在外部被访问到 私有属性 就是 对象 不希望公开的 属性 私有方法 就是 对象 不希望公开的 方法 定义方式 在 定义属性或方法时，在 属性名或者方法名前 增加 两个下划线，定义的就是 私有 属性或方法 ￼ class Women: def __init__(self, name): self.name = name # 不要问女生的年龄 self.__age = 18 def __secret(self): print(\"我的年龄是 %d\" % self.__age) xiaofang = Women(\"小芳\") # 私有属性，外部不能直接访问 # print(xiaofang.__age) # 私有方法，外部不能直接调用 # xiaofang.__secret() 02. 伪私有属性和私有方法（科普） 提示：在日常开发中，不要使用这种方式，访问对象的 私有属性 或 私有方法 Python 中，并没有 真正意义 的 私有 在给 属性、方法 命名时，实际是对 名称 做了一些特殊处理，使得外界无法访问到 处理方式：在 名称 前面加上 _类名 => _类名__名称 # 私有属性，外部不能直接访问到 print(xiaofang._Women__age) # 私有方法，外部不能直接调用 xiaofang._Women__secret() Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "},"python/03/继承.html":{"url":"python/03/继承.html","title":"继承","keywords":"","body":"继承 目标 单继承 多继承 面向对象三大特性 封装 根据 职责 将 属性 和 方法 封装 到一个抽象的 类 中 继承 实现代码的重用，相同的代码不需要重复的编写 多态 不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度 01. 单继承 1.1 继承的概念、语法和特点 继承的概念：子类 拥有 父类 的所有 方法 和 属性 ￼ 1) 继承的语法 class 类名(父类名): pass 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发 子类 中应该根据 职责，封装 子类特有的 属性和方法 2) 专业术语 Dog 类是 Animal 类的子类，Animal 类是 Dog 类的父类，Dog 类从 Animal 类继承 Dog 类是 Animal 类的派生类，Animal 类是 Dog 类的基类，Dog 类从 Animal 类派生 3) 继承的传递性 C 类从 B 类继承，B 类又从 A 类继承 那么 C 类就具有 B 类和 A 类的所有属性和方法 子类 拥有 父类 以及 父类的父类 中封装的所有 属性 和 方法 提问 哮天犬 能够调用 Cat 类中定义的 catch 方法吗？ 答案 不能，因为 哮天犬 和 Cat 之间没有 继承 关系 1.2 方法的重写 子类 拥有 父类 的所有 方法 和 属性 子类 继承自 父类，可以直接 享受 父类中已经封装好的方法，不需要再次开发 应用场景 当 父类 的方法实现不能满足子类需求时，可以对方法进行 重写(override) ￼ 重写 父类方法有两种情况： 覆盖 父类的方法 对父类方法进行 扩展 1) 覆盖父类的方法 如果在开发中，父类的方法实现 和 子类的方法实现，完全不同 就可以使用 覆盖 的方式，在子类中 重新编写 父类的方法实现 具体的实现方式，就相当于在 子类中 定义了一个 和父类同名的方法并且实现 重写之后，在运行时，只会调用 子类中重写的方法，而不再会调用 父类封装的方法 2) 对父类方法进行 扩展 如果在开发中， 子类的方法实现 中 包含 父类的方法实现 父类原本封装的方法实现 是 子类方法的一部分 就可以使用 扩展 的方式 在子类中 重写 父类的方法 在需要的位置使用 super().父类方法 来调用父类方法的执行 代码其他的位置针对子类的需求，编写 子类特有的代码实现 关于 super 在 Python 中 super 是一个 特殊的类 super() 就是使用 super 类创建出来的对象 最常 使用的场景就是在 重写父类方法时，调用 在父类中封装的方法实现 调用父类方法的另外一种方式（知道） 在 Python 2.x 时，如果需要调用父类的方法，还可以使用以下方式： 父类名.方法(self) 这种方式，目前在 Python 3.x 还支持这种方式 这种方法 不推荐使用，因为一旦 父类发生变化，方法调用位置的 类名 同样需要修改 提示 在开发时，父类名 和 super() 两种方式不要混用 如果使用 当前子类名 调用方法，会形成递归调用，出现死循环 1.3 父类的 私有属性 和 私有方法 子类对象 不能 在自己的方法内部，直接 访问 父类的 私有属性 或 私有方法 子类对象 可以通过 父类 的 公有方法 间接 访问到 私有属性 或 私有方法 私有属性、方法 是对象的隐私，不对外公开，外界 以及 子类 都不能直接访问 私有属性、方法 通常用于做一些内部的事情 示例 ￼ B 的对象不能直接访问 __num2 属性 B 的对象不能在 demo 方法内访问 __num2 属性 B 的对象可以在 demo 方法内，调用父类的 test 方法 父类的 test 方法内部，能够访问 __num2 属性和 __test 方法 02. 多继承 概念 子类 可以拥有 多个父类，并且具有 所有父类 的 属性 和 方法 例如：孩子 会继承自己 父亲 和 母亲 的 特性 ￼ 语法 class 子类名(父类名1, 父类名2...) pass 2.1 多继承的使用注意事项 问题的提出 如果 不同的父类 中存在 同名的方法，子类对象 在调用方法时，会调用 哪一个父类中的方法呢？ 提示：开发时，应该尽量避免这种容易产生混淆的情况！ —— 如果 父类之间 存在 同名的属性或者方法，应该 尽量避免 使用多继承 ￼ Python 中的 MRO —— 方法搜索顺序（知道） Python 中针对 类 提供了一个 内置属性 __mro__ 可以查看 方法 搜索顺序 MRO 是 method resolution order，主要用于 在多继承时判断 方法、属性 的调用 路径 print(C.__mro__) 输出结果 (, , , ) 在搜索方法时，是按照 __mro__ 的输出结果 从左至右 的顺序查找的 如果在当前类中 找到方法，就直接执行，不再搜索 如果 没有找到，就查找下一个类 中是否有对应的方法，如果找到，就直接执行，不再搜索 如果找到最后一个类，还没有找到方法，程序报错 2.2 新式类与旧式（经典）类 object 是 Python 为所有对象提供的 基类，提供有一些内置的属性和方法，可以使用 dir 函数查看 新式类：以 object 为基类的类，推荐使用 经典类：不以 object 为基类的类，不推荐使用 在 Python 3.x 中定义类时，如果没有指定父类，会 默认使用 object 作为该类的 基类 —— Python 3.x 中定义的类都是 新式类 在 Python 2.x 中定义类时，如果没有指定父类，则不会以 object 作为 基类 新式类 和 经典类 在多继承时 —— 会影响到方法的搜索顺序 为了保证编写的代码能够同时在 Python 2.x 和 Python 3.x 运行！ 今后在定义类时，如果没有父类，建议统一继承自 object class 类名(object): pass Copyright © augustdoit 2020 all right reserved，powered by Gitbook该文件修订时间： 2020-10-12 14:43:11 "}}